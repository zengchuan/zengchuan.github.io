[{"id":"201603220000000001","sortNo":1,"contentFormatId":"1","contentTxt":"全文检索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000002","sortNo":2,"contentFormatId":"1","contentTxt":"全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000003","sortNo":3,"contentFormatId":"1","contentTxt":"全文检索的方法主要分为按字检索和按词检索两种。按字检索是指对于文章中的每一个 字都建立索引，检索时将词分解为字的组合。对于各种不同的语言而言，字有不同的含义，比如英文中字与词实际上是合一的，而中文中字与词有很大分别。按词检 索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。英文等西方文字由于按照空白切分词，因此实现上与按字处理类似，添加同义 处理也很容易。中文等东方文字则需要切分字词，以达到按词索引的目的，关于这方面的问题，是当前全文检索技术尤其是中文全文检索技术中的难点，在此不做详 述。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000004","sortNo":4,"contentFormatId":"1","contentTxt":"全文检索系统的结构","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000005","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Lucene","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000007","sortNo":7,"contentFormatId":"1","contentTxt":"Lucene是非常优秀的成熟的开源的免费的纯java语言的全文索引检索工具包。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000008","sortNo":8,"contentFormatId":"1","contentTxt":"Lucene是一个高性能、可伸缩的信息搜索(IR)库。 Information Retrieval (IR) library.它使你可以为你的应用程序添加索引和搜索能力。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Lucene的作者Doug Cutting是资深的全文索引/检索专家，最开始发布在他本人的主页上，2001年10月贡献给APACHE，成为APACHE基金的一个子项目。http://lucene.apache.org","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Lucene是一个IR库而不是现成的产品，\u000B当然也不是Lucene的初识者常常认为的web。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000410","sortNo":11,"contentFormatId":"1","contentTxt":"Lucene作为一个全文检索引擎，其具有如下突出的优点：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000411","sortNo":12,"contentFormatId":"1","contentTxt":"1、索引文件格式独立于应用平台。Lucene定义了一套以8位字节为基础的索引文件格式，使得兼容系统或者不同平台的应用能够共享建立的索引文件。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000412","sortNo":13,"contentFormatId":"1","contentTxt":"2、在传统全文检索引擎的倒排索引的基础上，实现了分块索引，能够针对新的文件建立小文件索引，提升索引速度。然后通过与原有索引的合并，达到优化的目的。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000413","sortNo":14,"contentFormatId":"1","contentTxt":"3、优秀的面向对象的系统架构，使得对于Lucene扩展的学习难度降低，方便扩充新功能。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000414","sortNo":15,"contentFormatId":"1","contentTxt":"4、设计了独立于语言和文件格式的文本分析接口，索引器通过接受Token流完成索引文件的创立，用户扩展新的语言和文件格式，只需要实现文本分析的接口。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000415","sortNo":16,"contentFormatId":"1","contentTxt":"5、已经默认实现了一套强大的查询引擎，用户无需自己编写代码即使系统可获得强大的查询能力，Lucene的查询实现中默认实现了布尔操作、模糊查询（Fuzzy Search）、分组查询等等。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000416","sortNo":17,"contentFormatId":"1","contentTxt":"6、开源,可扩展能力强,有各种语言版本,适合各种平台。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000417","sortNo":18,"contentFormatId":"1","contentTxt":"Compass","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000418","sortNo":19,"contentFormatId":"1","contentTxt":"已加入Opensymphony的Compass 是对Lucene搜索引擎在企业应用（数据库应用）中的增强。DataMirror 会把数据库的增删改变化实时映射到索引文件中 ,如果没有Compass，我们一般会在每天深夜重建一次索引 。Compass对查询的API也作了一定简化，将Lucene的索引文件放入数据库或内存，对索引文件根据不同的主题分开subIndex，对XML数据进行映射和索引 。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000419","sortNo":20,"contentFormatId":"1","contentTxt":"Nutch","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000420","sortNo":21,"contentFormatId":"1","contentTxt":"Nutch 是一个建立在Lucene核心之上的Web搜索的实现，它是一个真正的应用程序（Lucene其实是一个提供全文文本搜索的函数库，它不是一个应用软件。它提供很多API函数让你可以运用到各种实际应用程序中）。也就是说，你可以直接下载下来拿过来用。它在Lucene的基础上加了网 络爬虫和一些和Web相关的东东。其目的就是想从一个简单的站内索引和搜索推广到全球网络的搜索上，就像Google和Yahoo一样。当然，和那些巨人 竞争，你得动一些脑筋，想一些办法。我们已经测试过100M的网页，并且它的设计用在超过1B的网页上应该没有问题。当然，让它运行在一台机器上，搜索一 些服务器，也运行的很好。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000421","sortNo":22,"contentFormatId":"1","contentTxt":"Egothor","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000422","sortNo":23,"contentFormatId":"1","contentTxt":"Egothor,一个全文索引和搜索的Java库，Egothor的核心算法与Lucene类似。它已经存在了很多年并拥有少量积极的开发者和用户团体。领头人是捷克工程师Leo Galambos，一个在IR领域有深厚理论背景的博士研究生。他时常参与Lucene用户和开发者邮件列表的讨论。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000423","sortNo":24,"contentFormatId":"1","contentTxt":"Lucene入门实例","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000424","sortNo":25,"contentFormatId":"1","contentTxt":"Lucene的系统由基础结构封装、索引核心、对外接口三大部分组成。其中直接操作索引文件的索引核心又是系统的重点。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000425","sortNo":26,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000426","sortNo":27,"contentFormatId":"1","contentTxt":"Lucene包结构功能表","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000427","sortNo":28,"contentFormatId":"1","contentTxt":"lucene-core-3.0.jar（几年前的jar）","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000428","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000429","sortNo":30,"contentFormatId":"1","contentTxt":"Lucene的主要逻辑图","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000430","sortNo":31,"contentFormatId":"1","contentTxt":"Lucene功能强大，但从根本上说，主要包括两块：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000431","sortNo":32,"contentFormatId":"1","contentTxt":"1、文本内容经切词后索引入库","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000432","sortNo":33,"contentFormatId":"1","contentTxt":"2、根据查询条件返回结果","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000433","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000434","sortNo":35,"contentFormatId":"1","contentTxt":"查询逻辑","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000435","sortNo":36,"contentFormatId":"1","contentTxt":"1、查询者输入查询条件,条件之间可以通过特定运算符进行运算，比如查询希望查询到与“中国”和“北京”相关的记录，但不希望结果中包括“海淀区中关村”，于是输入条件为“中国+北京-海淀区中关村”；","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000436","sortNo":37,"contentFormatId":"1","contentTxt":"2、查询条件被传达到查询分析器中，分析器将将对“中国+北京-海 淀区中关村”进行分析，首先分析器解析字符串的连接符，即这里的加号和减号，然后对每个词进行切词，一般最小的词元是两个汉字，则中国和北京两个词不必再 切分，但对海淀区中关村需要切分，假设根据切词算法，把该词切分为“海淀区”和“中关村”两部分，则最后得到的查询条件可以表示为：“中国” AND “北京” AND NOT（“海淀区” AND “中关村”）。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000437","sortNo":38,"contentFormatId":"1","contentTxt":"3、查询器根据这个条件遍历索引树，得到查询结果，并返回结果集，返回的结果集类似于JDBC中的ResultSet。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000438","sortNo":39,"contentFormatId":"1","contentTxt":"4、将返回的结果集显示在查询结果页面，当点击某一条内容时，可以链接到原始网页，也可以打开全文检索库中存储的网页内容。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000439","sortNo":40,"contentFormatId":"1","contentTxt":"5、这就是查询的逻辑过程，需要说明的是，Lucene默认只支持英文，为了便于说明问题，以上查询过程采用中文举例，事实上，当Lucene被扩充支持中文后就是这么一个查询过程。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000440","sortNo":41,"contentFormatId":"1","contentTxt":"入库逻辑","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000441","sortNo":42,"contentFormatId":"1","contentTxt":"1、入 库者定义到库中文档的结构，比如需要把网站内容加载到全文检索库，让用户通过“站内检索”搜索到相关的网页内容。入库文档结构与关系型数据库中的表结构类 似，每个入库的文档由多个字段构成，假设这里需要入库的网站内容包括如下字段：文章标题、作者、发布时间、原文链接、正文内容（一般作为网页快照）。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000442","sortNo":43,"contentFormatId":"1","contentTxt":"2、包含N个字段的文档（DOCUMENT）在真正入库前需要经过切词（或分词）索引，切词的规则由语言分析器（ANALYZER）完成。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000443","sortNo":44,"contentFormatId":"1","contentTxt":"3、切分后的“单词”被注册到索引树上，供查询时用，另外也需要把其它不需要索引的内容入库，所有这些是文件操作均由STORAGE完成。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000444","sortNo":45,"contentFormatId":"1","contentTxt":"4、Lucene的索引树结构非常优秀，是Lucene的一大特色。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000445","sortNo":46,"contentFormatId":"1","contentTxt":"理解核心索引类","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000446","sortNo":47,"contentFormatId":"1","contentTxt":"为了对文档进行索引，Lucene 提供了五个基础的类：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000447","sortNo":48,"contentFormatId":"1","contentTxt":"public class IndexWriter ：org.apache.lucene.index.IndexWriter","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000448","sortNo":49,"contentFormatId":"1","contentTxt":"public abstract class Directory ：org.apache.lucene.store.Directory","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000449","sortNo":50,"contentFormatId":"1","contentTxt":"public abstract class Analyzer ：org.apache.lucene.analysis.Analyzer","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000450","sortNo":51,"contentFormatId":"1","contentTxt":"public final class Document ：org.apache.lucene.document.Document","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000451","sortNo":52,"contentFormatId":"1","contentTxt":"public final class Field ：org.apache.lucene.document.Field","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000452","sortNo":53,"contentFormatId":"1","contentTxt":"IndexWriter","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000453","sortNo":54,"contentFormatId":"1","contentTxt":"IndexWriter是在索引过程中的中心组件。IndexWriter这个类创建一个新的索引并且添加文档到一个已有的索引中。你可以把IndexWriter想象成让你可以对索引进行写操作的对象，但是不能让你读取或搜索。IndexWriter不是唯一的用来修改索引的类。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000578","sortNo":55,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000455","sortNo":56,"contentFormatId":"1","contentTxt":"Directory","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000456","sortNo":57,"contentFormatId":"1","contentTxt":"Directory类代表一个Lucene索引的位置。它是一个抽象类。其中的两个实现：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000457","sortNo":58,"contentFormatId":"1","contentTxt":"1、FSDirectory，它表示一个存储在文件系统中的索引的位置。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000458","sortNo":59,"contentFormatId":"1","contentTxt":"2、RAMDirectory，它表示一个存储在内存当中的索引的位置。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000459","sortNo":60,"contentFormatId":"1","contentTxt":"在我们的Indexer示例中，我们使用一个实际文件系统目录的路径传递给IndexWriter的构造函数来获得Directory的一个实例。IndexWriter然后使用Directory的一个具体实现FSDirectory，并在文件系统的一个目录中创建索引。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000460","sortNo":61,"contentFormatId":"1","contentTxt":"Analyzer","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000461","sortNo":62,"contentFormatId":"1","contentTxt":"在一个文档被索引之前，首先需要对文档内容进行分词处理，并且而剔除一些冗余的词句（例如：a，the,they等),这部分工作就是由 Analyzer 来做的。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000462","sortNo":63,"contentFormatId":"1","contentTxt":"Analyzer 类是一个抽象类，它有多个实现：BrazilianAnalyzer, ChineseAnalyzer, CJKAnalyzer, CzechAnalyzer, DutchAnalyzer, FrenchAnalyzer, GermanAnalyzer, GreekAnalyzer, KeywordAnalyzer, PatternAnalyzer, PerFieldAnalyzerWrapper, RussianAnalyzer, SimpleAnalyzer, SnowballAnalyzer, StandardAnalyzer, StopAnalyzer, ThaiAnalyzer, WhitespaceAnalyzer。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000463","sortNo":64,"contentFormatId":"1","contentTxt":"针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter 来建立索引。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000464","sortNo":65,"contentFormatId":"1","contentTxt":"Document","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000465","sortNo":66,"contentFormatId":"1","contentTxt":"Document文档类似数据库中的一条记录，可以由好几个字段（Field）组成，并且字段可以套用不同的类型。一个Field代表与这个文档相关的元数据。元数据如作者、标题、主题、修改日期等等，分别做为文档的字段索引和存储。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000466","sortNo":67,"contentFormatId":"1","contentTxt":"Document的方法：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000467","sortNo":68,"contentFormatId":"1","contentTxt":"void add(Fieldable？field)添加一个字段（Field）到Document中。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000468","sortNo":69,"contentFormatId":"1","contentTxt":"String get(String name)从文档中获得一个字段对应的文本。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000469","sortNo":70,"contentFormatId":"1","contentTxt":"Field","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000470","sortNo":71,"contentFormatId":"1","contentTxt":"Field 对象是用来描述一个文档的某个属性的，比如一封电子邮件的标题和内容可以用两个 Field 对象分别描述。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000579","sortNo":72,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000472","sortNo":73,"contentFormatId":"1","contentTxt":"创建一个索引的大致过程","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000580","sortNo":74,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000474","sortNo":75,"contentFormatId":"1","contentTxt":"理解核心搜索类","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000475","sortNo":76,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000476","sortNo":77,"contentFormatId":"1","contentTxt":"IndexSearcher","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000477","sortNo":78,"contentFormatId":"1","contentTxt":"IndexSearcher是用来在建立好的索引上进行搜索的。它只能以只读的方式打开一个索引，所以可以有多个IndexSearcher的实例在一个索引上进行操作。它提供几个搜索方法，其中一些在抽象基类Searcher中实现。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000478","sortNo":79,"contentFormatId":"1","contentTxt":"Search方法1","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000479","sortNo":80,"contentFormatId":"1","contentTxt":"返回值为Hits型的对象：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000581","sortNo":81,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000481","sortNo":82,"contentFormatId":"1","contentTxt":"Search方法2（Lower-level search API）","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000482","sortNo":83,"contentFormatId":"1","contentTxt":"返回索引中得分较高的文档集合,这些方法中,都带有一个int形式参数,表示取出置于TopDocs集合中的文档数量。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000582","sortNo":84,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000484","sortNo":85,"contentFormatId":"1","contentTxt":"Term","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000485","sortNo":86,"contentFormatId":"1","contentTxt":"Term是搜索的基本单元。一个Term对象有两个String类型的域组成：字段的名称和字段的值。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000486","sortNo":87,"contentFormatId":"1","contentTxt":"在搜索时，你可能创建Term对象并和TermQuery同时使用。其中第一个参数代表了要在文档的哪一个Field上进行查找，第二个参数代表了要查询的关键词。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000583","sortNo":88,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000488","sortNo":89,"contentFormatId":"1","contentTxt":"这段代码使Lucene找出在fieldName字段中含有单词queryWord的所有文档。因为TermQuery对象继承自它的抽象父类Query，你可以在等式的左边用Query类型。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000489","sortNo":90,"contentFormatId":"1","contentTxt":"Query","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000490","sortNo":91,"contentFormatId":"1","contentTxt":"Query是一个抽象类，这个类的目的是把用户输入的查询字符串封装成Lucene能够识别的Query。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000491","sortNo":92,"contentFormatId":"1","contentTxt":"Lucene中包含一些Query的具体子类：BooleanQuery, BoostingQuery, ConstantScoreQuery, ConstantScoreRangeQuery, CustomScoreQuery, DisjunctionMaxQuery, FilteredQuery, FuzzyLikeThisQuery, MatchAllDocsQuery, MoreLikeThisQuery, MultiPhraseQuery, MultiTermQuery, PhraseQuery, PrefixQuery, RangeQuery, SpanQuery, TermQuery, ValueSourceQuery","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000492","sortNo":93,"contentFormatId":"1","contentTxt":"TermQuery","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000493","sortNo":94,"contentFormatId":"1","contentTxt":"TermQuery是抽象类Query的一个子类，它同时也是Lucene支持的最为基本的一个查询类。生成一个TermQuery对象由如下语句完成：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000494","sortNo":95,"contentFormatId":"1","contentTxt":"TermQuery termQuery = new TermQuery(new Term(“fieldName”,”queryWord”));","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000495","sortNo":96,"contentFormatId":"1","contentTxt":"Hits","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000496","sortNo":97,"contentFormatId":"1","contentTxt":"Hits是用来保存搜索的结果的。 基于性能考虑，Hits的实例并不从索引中加载所有匹配查询的所有文档，而是每次一小部分。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000497","sortNo":98,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000498","sortNo":99,"contentFormatId":"1","contentTxt":"关键词搜索的大致过程","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000499","sortNo":100,"contentFormatId":"1","contentTxt":"最简单的接受单个Query对象做为参数并返回一个Hits对象。这个方法的典型应用类似这样：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000584","sortNo":101,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000501","sortNo":102,"contentFormatId":"1","contentTxt":"内建Query对象","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000502","sortNo":103,"contentFormatId":"1","contentTxt":"BooleanQuery布尔搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000503","sortNo":104,"contentFormatId":"1","contentTxt":"BooleanQuery是实际开发过程中经常使用的一种Query。它其实是一个组合的Query，在使用时可以把各种Query对象添加进去并标明它们之间的逻辑关系。BooleanQuery是可以嵌套的(BooleanQuery是一个布尔子句的容器)。一个BooleanQuery可以成为另一个BooleanQuery的条件子句。布尔型Query的子句数目不能超过1024。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000504","sortNo":105,"contentFormatId":"1","contentTxt":"RangeQuery范围搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000505","sortNo":106,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000506","sortNo":107,"contentFormatId":"1","contentTxt":"PrefixQuery 前缀搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000507","sortNo":108,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000508","sortNo":109,"contentFormatId":"1","contentTxt":"PhraseQuery短语搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000509","sortNo":110,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000510","sortNo":111,"contentFormatId":"1","contentTxt":"FuzzyQuery模糊搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000511","sortNo":112,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000512","sortNo":113,"contentFormatId":"1","contentTxt":"WildcardQuery通配符搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000585","sortNo":114,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000514","sortNo":115,"contentFormatId":"1","contentTxt":"SpanQuery跨度搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000515","sortNo":116,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000516","sortNo":117,"contentFormatId":"1","contentTxt":"RegexQuery正则表达式搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000517","sortNo":118,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000518","sortNo":119,"contentFormatId":"1","contentTxt":"MultiFieldQueryParser 多域搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000519","sortNo":120,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000520","sortNo":121,"contentFormatId":"1","contentTxt":"ParallelMultiSearcher多线程搜索","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000521","sortNo":122,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000522","sortNo":123,"contentFormatId":"1","contentTxt":"分析器Analyzer","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000523","sortNo":124,"contentFormatId":"1","contentTxt":"YACC To JavaCC","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000524","sortNo":125,"contentFormatId":"1","contentTxt":"Lex 和yacc这两个工具是经典的词法分析和语法分析工具,但是它们都是基于C语言下面的工具,而使用JAVA的朋友们就用不上了.但是JAVA下已经有了lex和yacc的替代品javacc( Java Compiler Compiler ) 。Lucene很明智的避开了语言分析这个复杂的领域,转而使用JavaCC为其构造标准的分词器.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000586","sortNo":126,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000526","sortNo":127,"contentFormatId":"1","contentTxt":"英文分析器比较","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000527","sortNo":128,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000528","sortNo":129,"contentFormatId":"1","contentTxt":"中文分词","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000529","sortNo":130,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000530","sortNo":131,"contentFormatId":"1","contentTxt":"Query Parser","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000531","sortNo":132,"contentFormatId":"1","contentTxt":"改变QueryParser默认的布尔逻辑","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000532","sortNo":133,"contentFormatId":"1","contentTxt":"QueryParser默认的逻辑是“或”.可以通过setDefaultOperator方法来改变默认的布尔逻辑。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000587","sortNo":134,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000534","sortNo":135,"contentFormatId":"1","contentTxt":"Query Parser Syntax语法","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000535","sortNo":136,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000536","sortNo":137,"contentFormatId":"1","contentTxt":"Query Parser Syntax","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000537","sortNo":138,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000538","sortNo":139,"contentFormatId":"1","contentTxt":"索引","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000539","sortNo":140,"contentFormatId":"1","contentTxt":"使用Lucene索引分为三个主要步骤：1、将数据转化为文本；2、分析；3、将它保存至索引。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000540","sortNo":141,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000541","sortNo":142,"contentFormatId":"1","contentTxt":"在索引中清除Document","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000542","sortNo":143,"contentFormatId":"1","contentTxt":"尽管大多程序关心的是添加Document到Lucene索引中，一些也需要清除它们。例如，报纸出版社可能只想在可搜索的索引中保留最近一个周的有价值的新闻。另外的程序可能想清除所有包含特定单词的Document。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000543","sortNo":144,"contentFormatId":"1","contentTxt":"Document的删除是由IndexReader来完成的。这个类并不立即从索引中删除Document。它只做个删除的标志，等待IndexReader的close()方法调用时真正的Document删除。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000544","sortNo":145,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000545","sortNo":146,"contentFormatId":"1","contentTxt":"delete(Term)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000546","sortNo":147,"contentFormatId":"1","contentTxt":"除了我们通过指定Document编号来删除单个Document之外，你可以用IndexReader的delete(Term)方法删除多个Document。使用这个删除方法，允许你删除所有包含指定Term的Document。例如，为了删除city字段中包含单词Amsterdam的Document，你可以这样用IndexReader：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000547","sortNo":148,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000548","sortNo":149,"contentFormatId":"1","contentTxt":"恢复Document","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000549","sortNo":150,"contentFormatId":"1","contentTxt":"因为Document的删除延迟到IndexReader实例关闭时才执行，Lucene允许程序改变想法并恢复已做删除标记的Document。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000550","sortNo":151,"contentFormatId":"1","contentTxt":"对IndexReader的undeleteAll()方法的调用通过清除索引目录中的.del文件来恢复所有删除的Document。所以在关闭IndexReader实例关闭之后Document就保留在索引中了。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000551","sortNo":152,"contentFormatId":"1","contentTxt":"只能使用与删除Document时同一个IndexReader实例，才能调用undeleteAll()来恢复Document。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000552","sortNo":153,"contentFormatId":"1","contentTxt":"更新索引中的Document","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000553","sortNo":154,"contentFormatId":"1","contentTxt":"“如何才能更新索引中的文档？”是一个在Lucene用户邮件列表中经常问的问题。Lucene并没有提供更新方法；Document必须首先从索引中删除然后再重新添加它。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000554","sortNo":155,"contentFormatId":"1","contentTxt":"如果你需要删除和添加多个Document，最好是进行批操作。按以下步骤：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000555","sortNo":156,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000556","sortNo":157,"contentFormatId":"1","contentTxt":"Document增量","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000557","sortNo":158,"contentFormatId":"1","contentTxt":"默认情况下，所有的Document都没有增量――或者更恰当地说，它们都有相同的增量因数1.0。通过改变某个Document的增量因数，你可能让Lucene认为它比索引中的其他Document更重要或不重要。执行这些的API只需一个方法，document.setBoost(float)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000558","sortNo":159,"contentFormatId":"1","contentTxt":"Field增量","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000559","sortNo":160,"contentFormatId":"1","contentTxt":"就象你可以增量Document一样，你也可以增量个别的字段。当你增量Document时，Lucene内部使用相同的增量因数增量它的每个字段。field.setBoost(float)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000560","sortNo":161,"contentFormatId":"1","contentTxt":"排序","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000561","sortNo":162,"contentFormatId":"1","contentTxt":"Lucene默认按照文档得分进行排序","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000562","sortNo":163,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000563","sortNo":164,"contentFormatId":"1","contentTxt":"explain方法","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000564","sortNo":165,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000565","sortNo":166,"contentFormatId":"1","contentTxt":"改变文档的得分","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000566","sortNo":167,"contentFormatId":"1","contentTxt":"除了内置的得分算法外，Lucene还提供了一种方法来改变每个文档的得分。初始化Document后，可以使用Document的setBoost方法来改变一下文档的boost因子。这种做法的实际目的是将文档的得分乘以这个因子，以这个新的数作为文档的得分。","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000567","sortNo":168,"contentFormatId":"1","contentTxt":"sort排序","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000568","sortNo":169,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000569","sortNo":170,"contentFormatId":"1","contentTxt":"SortField","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000570","sortNo":171,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603220000000571","sortNo":172,"contentFormatId":"1","contentTxt":"这是2012年的ppt文章，希望对大家有帮助。","contentBinary":"","contentPoster":"","contentUrl":null}]
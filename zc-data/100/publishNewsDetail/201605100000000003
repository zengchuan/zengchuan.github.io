[{"id":"201605100000000121","sortNo":1,"contentFormatId":"1","contentTxt":"In the first part of this article, we deal with foundations of the form support. We then describe in a second part more advanced features to make form creation and processing more concise and robust. It’s now time to tackle the form submission.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000122","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Handling form submission</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000123","sortNo":3,"contentFormatId":"1","contentTxt":"Angular 2 automatically applies the NgForm directive to the HTML form element. The main consequence is that we need to disable the default behavior of browsers and apply the one from Angular 2. That way a specific event is fired and processing remains in the same page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000124","sortNo":4,"contentFormatId":"1","contentTxt":"<strong>Submitting data</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000125","sortNo":5,"contentFormatId":"1","contentTxt":"To submit data, we need to leverage the submit event of the form with the Angular 2 syntax. This event is triggered when clicking on an HTML submit button.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000126","sortNo":6,"contentFormatId":"1","contentTxt":"Simply register processing against this event using the bracket expression. In the following sample, we call the onSubmit method of the component when the submit event occurs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000127","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000128","sortNo":8,"contentFormatId":"1","contentTxt":"This onSubmit method will leverage the CompanyService service injected in the component to actually update the company data in the RESTful service. To give the user some feedback, we can use a submitPending property to display a spinning icon during the execution of the HTTP request. When response is back, you can hide it and display a message using the Toastr library.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000129","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000130","sortNo":10,"contentFormatId":"1","contentTxt":"We will see in the next section how to handle errors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000131","sortNo":11,"contentFormatId":"1","contentTxt":"This submitPending property also allows us to disable the submit button to prevent users from clicking several times. For this we can simply use interpolation for the disabled attribute of the button. This way the value of this attribute will be linked to the provided expression. This can be combined with the pending property of the form control to disable the button as well during asynchronous validation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000132","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000133","sortNo":13,"contentFormatId":"1","contentTxt":"Here is the result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000134","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000135","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000136","sortNo":16,"contentFormatId":"1","contentTxt":"<strong>Form submission error handling</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000137","sortNo":17,"contentFormatId":"1","contentTxt":"In the previous section, we intentionally didn’t handle errors that could occur when executing the HTTP request to save the company. To make this processing more robust, we need to handle them. This must be done at two different levels.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000138","sortNo":18,"contentFormatId":"1","contentTxt":"First in the service. Since the map operator isn’t called in the case of failures, we need to extract the JSON error content from the payload using the catch operator, as described below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000139","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000140","sortNo":20,"contentFormatId":"1","contentTxt":"Observables provide operators to configure asynchronous data streams. This aspect is part of Reactive Programming that will be discussed in a following article. We used the map operator in a previous Angular2 article in the section “Interacting with the Web API”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000141","sortNo":21,"contentFormatId":"1","contentTxt":"This way we will receive the error as JSON object when defining a second callback at the level of the subscribe method in the component. We can then directly handle it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000142","sortNo":22,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000143","sortNo":23,"contentFormatId":"1","contentTxt":"Now we receive the error payload within the error callback registered in the subscribe method, we can distinguish two kinds of errors to handle within the displayErrors method:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000144","sortNo":24,"contentFormatId":"1","contentTxt":"1. Global errors that notify that the update fails","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000145","sortNo":25,"contentFormatId":"1","contentTxt":"2. Server validation errors that are linked to the fields of the form","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000146","sortNo":26,"contentFormatId":"1","contentTxt":"The method has the responsibility to handle both cases. In the first one, an error property is set with the message. A dedicated component will then use this property to display the message.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000147","sortNo":27,"contentFormatId":"1","contentTxt":"For field errors, the method will look for fields with errors and set them within their corresponding controls. All these hints are present in the error content as we can see within the DHC HTTP client.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000148","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000149","sortNo":29,"contentFormatId":"1","contentTxt":"Here is its complete implementation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000150","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000151","sortNo":31,"contentFormatId":"1","contentTxt":"Server validation errors for fields are displayed the same way as the local ones at the level of field inputs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000152","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000153","sortNo":33,"contentFormatId":"1","contentTxt":"To display global errors as Bootstrap does, we need to go further by creating a simple component, as described below. It will leverage the alert* classes of the library.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000154","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000155","sortNo":35,"contentFormatId":"1","contentTxt":"Simply add an tag in your form to specify where to display the error after having adding the FormErrorComponent component into the directives attribute of the component containing the form:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000156","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000157","sortNo":37,"contentFormatId":"1","contentTxt":"Here is how such messages will be displayed in the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000158","sortNo":38,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000159","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>Conclusion</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000160","sortNo":40,"contentFormatId":"1","contentTxt":"In this article, we described how to implement forms with Angular 2. We went beyond the basics to show how to leverage the power of Angular 2. We saw how the standard form support of Angular 2 can fit into its component-based approach to implement concise and powerful forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000161","sortNo":41,"contentFormatId":"1","contentTxt":"In this article, we made an effort to split form building and processing into several small components that interact together to provide the company editing feature. All this work contributes to improve code maintainability and reusability, since it’s possible to reuse most of these components into other forms of the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000162","sortNo":42,"contentFormatId":"1","contentTxt":"As stated form controls can also leverage observables and reactive programming to make other parts of the application react following user inputs. We will focus on the support of such approaches within Angular 2 in a following article, so stay tuned!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000163","sortNo":43,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000164","sortNo":44,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/restlet/restlet-sample-angular2-forms\">https://github.com/restlet/restlet-sample-angular2-forms</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
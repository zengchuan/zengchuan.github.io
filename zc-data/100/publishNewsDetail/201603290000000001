[{"id":"201603290000000001","sortNo":1,"contentFormatId":"1","contentTxt":"At the time of this post, the Angular team just released the first beta version of Angular 2. This guide assumes you have an understanding of the TypeScript language as well as the Angular 2 framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Introduction To Services","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000003","sortNo":3,"contentFormatId":"1","contentTxt":"It is considered good programming to use services when handling data manipulation or storage in your applications. The app's controllers (in Angular 2's case; the components) should merely take data from services and show that data in views or alternatively take user input and give that to a service in order to manipulate or save it. The controller shouldn't ever directly manipulate the data itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Bellow different situations; the first does not use a service where as the second does.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000005","sortNo":5,"contentFormatId":"1","contentTxt":"Bad","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000006","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000007","sortNo":7,"contentFormatId":"1","contentTxt":"Good","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000008","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000009","sortNo":9,"contentFormatId":"1","contentTxt":"As you can see, the main difference between the two scenarios is the location in which the code attempts to retrieve data from the database.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000010","sortNo":10,"contentFormatId":"1","contentTxt":"The first scenario or the 'Bad' scenario retrieves the data from within the component. This is a poor coding style as it complicated the task for the developer (or possibly another developer) in order to change how the data is retrieved (such as by moving from Firebase to MongoDB) the developer must change the code of every component that accesses that database. This technique is error prone and makes it difficult to distribute and reuse your code in other scenarios.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000011","sortNo":11,"contentFormatId":"1","contentTxt":"The second scenario or the 'Good' scenario retrieves data from a 'data service'. This initially may look like more code to write but it will ultimately lead to less errors, reduce application complexity and increase modularity and reusability. This is the case because the component does not need to know how the data is stored, all it needs to know is how to retrieve it from the data service (and this should rarely change.) This also means that when you want to change how data is accessed (such as swapping out databases), only the code in the 'data service' class needs to change while the rest of the application may work as normal. This coding technique where we seperate concerns is known as loose coupling.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Flowing Data With Observables","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000013","sortNo":13,"contentFormatId":"1","contentTxt":"So far we have separated data manipulation from the controller (or component) and put it in a service. The service works great when we want to retrieve data from an exact point in time; a callback function is run, and retrieves a Promise containing the data we want.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000014","sortNo":14,"contentFormatId":"1","contentTxt":"But what if we want to allow the data to 'flow' and receive, in real time, new data as it changes in the database. This would be necessary if we wanted to set up a persisting socket to a database (a good library to do this can be found here). Promises no longer work in the scenario as the Promise's callback only gathers data at one instance. Therefore we need to implement a new kind of datatype which allows us to keep the connection open.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Introducing Observables! Observables are a datatype that are used to persist a stream of data from a source (If you have ever coded in NodeJS, they are similar to Streams). This basically means that unlike a Promise that calls the callback with the data once, the Observable allows you to use a callback on the data every time it is updated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Let's dive into some code to demonstrate the use of Observables. We will create a simple post feed using Firebase as our database. Firebase maintains open connections to its database and feeds changes as they occur to our app which is perfect for our demonstration.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000017","sortNo":17,"contentFormatId":"1","contentTxt":"First, let's create a simple post class.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000018","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000019","sortNo":19,"contentFormatId":"1","contentTxt":"Now we need to build our service to handle the data and interact with firebase. Observables are part of the Reactive-Extensions library. As we are writing in TypeScript, we will need to install their JavaScript version known as RxJS. We will also need to install Firebase.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000020","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000021","sortNo":21,"contentFormatId":"1","contentTxt":"In our service we have built two main functions. A create() function to add a new post to the database as well as a getAll() function which will return all the post items in our database.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000022","sortNo":22,"contentFormatId":"1","contentTxt":"The getAll() function is where we create our Observable. As you can see; we call the create() function on the Observable library and then initiate a new listener to our database in the callback. Every time a new piece of data is now returned by the Firebase database, it will trigger the Observable's next() function which will persist the data through the Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000023","sortNo":23,"contentFormatId":"1","contentTxt":"The return value of getAll() is what will be called when the Subscription's unsubscribe() function is called (this is done for closing the database connection and freeing resources).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000024","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603290000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Bootstrap your app with the FeedComponent and it should start making real time database changes through the Angular 2 service!","contentBinary":"","contentPoster":"","contentUrl":null}]
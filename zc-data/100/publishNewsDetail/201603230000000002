[{"id":"201603230000000022","sortNo":1,"contentFormatId":"1","contentTxt":"One of the big (and mostly undocumented) shifts in Angular 2 is learning how to think about the DOM (Document Object Model) as an abstracted API. No longer can we be satisfied with just rendering in the browser - now our code needs to be compatible with WebWorkers, servers, and any other context for which people will write adapters (ex, NativeScript). This freedom, however, comes with a cost of complexity. And, relatively simple operations, like copying HTML, become, well, complex. Ideally, I'd like to be able to copy the innerHTML of a component in a platform-agnostic way; but, ultimately, the only way that I could figure out how to do it - without using native browser APIs - was to use the BrowserDomAdapter service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000023","sortNo":2,"contentFormatId":"1","contentTxt":"Most of the time, in an AngularJS application, you only need to represent content once. But, in some use-cases, you need to take content and clone it. And, not cloned as a component instance but rather as a static copy of some portion of the component tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000024","sortNo":3,"contentFormatId":"1","contentTxt":"Take, for example, a drag-and-drop feature where the draggable item is represented as a \"ghost\" under the user's cursor. This ghost element is not an active component (meaning, it doesn't have interpolation bindings or host-event bindings), it's just a copy of the target element at the time the drag-operation was initiated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000025","sortNo":4,"contentFormatId":"1","contentTxt":"Or, as an even simpler example, duplicating the rendering of a selected option in some sort of select-input control. In that case, one of the options needs to be rendered twice: once in the list of options and a second time in the representation of the selected option.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000026","sortNo":5,"contentFormatId":"1","contentTxt":"To explore this, I wanted to try to create a simple select control in which the user can provide an arbitrary list of select items. Then, when the user goes to select one of the items, the content of the selected item is duplicated into the \"selected item\" representation of the control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000027","sortNo":6,"contentFormatId":"1","contentTxt":"This demo requires two components: the SelectList and the SelectItem. As much as I could, I tried to keep all of the platform-specific assumptions in one place. So, for example, the SelectItem makes no assumptions about the platform. It only knows about its own host element wrapper (elementRef), which it passes up to the SelectList upon request.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000028","sortNo":7,"contentFormatId":"1","contentTxt":"The SelectList, on the other hand, is where all of the platform assumptions are made. It provides and consumes the BrowserDomAdapter and it understand the concept of innerHTML. But, even so, it still tries to interact with the innerHTML through the API of the BrowserDomAdapter instead of going directly to the native browser API. As least, with this approach, the BrowserDomAdapter service can still be mocked out or implemented in other contexts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000029","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000030","sortNo":9,"contentFormatId":"1","contentTxt":"As you can see, the SelectList is using the .getInnerHTML() and the .setInnerHTML() methods of the BrowserDomAdapter service rather than referencing the .innerHTML node properties directly. This way, those methods can be mocked out, or implemented, in other contexts. So, while this approach is more platform-specific, at least there is some safety to it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000031","sortNo":10,"contentFormatId":"1","contentTxt":"And, when we run the above code and select one of the SelectItem elements, we can see that the item content is cloned successfully:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000032","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000033","sortNo":12,"contentFormatId":"1","contentTxt":"From what I have seen, the Angular team has yet to release any \"best practice\" guides around the platform-agnostic nature of the Angular 2 framework. As such, it feels very much like unchartered territory every time that I need to interact with the DOM in an imperative way instead of a declarative way. So, right now, my strategy for success is to just try and keep those operations - like copying innerHTML - behind some sort of an API that can be mocked or implemented in other contexts.","contentBinary":"","contentPoster":"","contentUrl":null}]
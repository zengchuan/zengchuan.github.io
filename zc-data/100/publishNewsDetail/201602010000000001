[{"id":"201602010000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Managing application state is a hard problem. You need to coordinate between multiple backends, web workers, and UI components. Patterns like Redux and Flux are designed to address this problem by making this coordination more explicit. In this article, I will show how we can implement a similar pattern in just a few lines of code using RxJS. Then I will show how we can use this pattern to implement a simple Angular 2 application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000002","sortNo":2,"contentFormatId":"1","contentTxt":"CORE PROPERTIES","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000003","sortNo":3,"contentFormatId":"1","contentTxt":"When talking about an architecture pattern, I like to start with describing its core properties. Something that you can write down on the back of a napkin. The devil, of course, is in the details, and we will get to that. But a high-level overview is useful nevertheless.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000004","sortNo":4,"contentFormatId":"1","contentTxt":"In many ways what we are going to build is akin to Redux.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000005","sortNo":5,"contentFormatId":"1","contentTxt":"IMMUTABLE STATE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000006","sortNo":6,"contentFormatId":"1","contentTxt":"The whole application state is stored as an immutable data structure. So every time a change happens, a new instance of the data-structure is constructed. Even though this seems limiting at first, this constraint results in many great properties. One of which is that it can make your Angular applications quite a bit faster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000007","sortNo":7,"contentFormatId":"1","contentTxt":"INTERACTION = ACTION","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000008","sortNo":8,"contentFormatId":"1","contentTxt":"The only way to update the application state is to emit an action. As a result, most user interactions emit actions. And if you want to simulate an interaction, you just need to emit the right sequence of actions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000009","sortNo":9,"contentFormatId":"1","contentTxt":"APPLICATION IS FN(A:OBSERVABLE):OBSERVABLE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000010","sortNo":10,"contentFormatId":"1","contentTxt":"The logic of the application is expressed as a function mapping an observable of actions into an observable of application states.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000011","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000012","sortNo":12,"contentFormatId":"1","contentTxt":"This function is invoked only once. This is different from Redux, where the reducing function is invoked on every action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000013","sortNo":13,"contentFormatId":"1","contentTxt":"APPLICATION AND VIEW BOUNDARY","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000014","sortNo":14,"contentFormatId":"1","contentTxt":"The application and view logic are completely separated. The dispatcher and state objects are the boundary through which the application and the view communicate. The view emits actions using the dispatcher and listens to changes in the state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000015","sortNo":15,"contentFormatId":"1","contentTxt":"EXAMPLE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000226","sortNo":16,"contentFormatId":"1","contentTxt":"Since this pattern is similar to Redux, you may benefit from watching Dan Abramov’s excellent video course on the subject. In this course Dan shows how to build a todo application using Redux. To make it easier for you to compare the Redux implementation and my implementation, I will build the same app in this article.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000227","sortNo":17,"contentFormatId":"1","contentTxt":"APPLICATION STATE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000228","sortNo":18,"contentFormatId":"1","contentTxt":"I get a really good feel of what an application does by looking at its state’s type definitions and its list of actions. So let’s start with that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000229","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000230","sortNo":20,"contentFormatId":"1","contentTxt":"Our application’s state is just a array of todos and a filter defining which todos to display.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000231","sortNo":21,"contentFormatId":"1","contentTxt":"ACTIONS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000232","sortNo":22,"contentFormatId":"1","contentTxt":"Our application will support the following three actions: AddTodoAction, ToggleTodoAction, and SetVisibilityFilter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000233","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000234","sortNo":24,"contentFormatId":"1","contentTxt":"The type Action, which is a union of the three actions, represents everything this application will be able to do.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000235","sortNo":25,"contentFormatId":"1","contentTxt":"OBSERVABLE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000236","sortNo":26,"contentFormatId":"1","contentTxt":"We need to define the state function that will return an observable of application states. To make the example a little bit more production-like, I will split the state function into two parts: one dealing with todos and the other one dealing with the visibility filter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000237","sortNo":27,"contentFormatId":"1","contentTxt":"Let’s deal with todos first.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000238","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000239","sortNo":29,"contentFormatId":"1","contentTxt":"There are a few interesting things that I’d like to point out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000240","sortNo":30,"contentFormatId":"1","contentTxt":"First, look at the signature of the function. The function does not take a single action, but rather an RxJS observable of actions. Likewise, it does not return a list of todos, but an observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000241","sortNo":31,"contentFormatId":"1","contentTxt":"Second, actions.scan applies the accumulator function over an observable sequence and returns each intermediate result. So a new list of todos will be emitted after every action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000242","sortNo":32,"contentFormatId":"1","contentTxt":"Third, TypeScript realizes that the action inside the if clause is an AddTodoAction. This means that I can access the todoId and text properties, but not filter. This allows me to write such functions in a type-safe way. This is fantastic because such functions are where the smarts of your application live, and as a result, they quickly become non-trivial. So having some compiler support there is a big plus.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000243","sortNo":33,"contentFormatId":"1","contentTxt":"Next, let’s extend todos by adding an ability to toggle a todo.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000244","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000245","sortNo":35,"contentFormatId":"1","contentTxt":"Similar to todos, we can implement a function creating an observable of visibility filter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000246","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000247","sortNo":37,"contentFormatId":"1","contentTxt":"And, finally, we can combine them to create stateFn.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000248","sortNo":38,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000249","sortNo":39,"contentFormatId":"1","contentTxt":"There is a lot going on in this six lines of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000250","sortNo":40,"contentFormatId":"1","contentTxt":"First, we create the todos and filter observables using the functions defined above. Then, we zip them into an observable of pairs, which we map into an observable of AppState.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000251","sortNo":41,"contentFormatId":"1","contentTxt":"There is one problem with this observable. If a component subscribes to it, the component won’t receive any data until the observable emits a new event. For this to happen a new action has to be emitted. This is not what we want. What we want is for the component to receive the latest snapshot the moment it subscribes. And that is what BehaviorSubject is for.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000252","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000253","sortNo":43,"contentFormatId":"1","contentTxt":"A behavior subject is an observable that will emit the latest value to every new subscriber.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000254","sortNo":44,"contentFormatId":"1","contentTxt":"To better understand how stateFn works, let’s write a few unit tests:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000255","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000256","sortNo":46,"contentFormatId":"1","contentTxt":"If you are familiar with Redux, you can find the stateFn function to be similar to a Redux reducer. But there is actually a big difference: the stateFn function is invoked only once, whereas a Redux reducer is invoked on every action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000257","sortNo":47,"contentFormatId":"1","contentTxt":"This is important for the following reasons:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000258","sortNo":48,"contentFormatId":"1","contentTxt":"Just an Observable","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000259","sortNo":49,"contentFormatId":"1","contentTxt":"The stateFn function is called only once to create the state observable. The rest of the application (e.g., Angular 2 components) do not have to know that stateFn even exists. All they care about is the observable. This gives us a lot of flexibility in how we can implement the function. In this example, we did it in a Redux-like way. But we can change it without affecting anything else in the application. Also, since Angular 2 already ships with RxJS, we did not have to bring in any new libraries.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000260","sortNo":50,"contentFormatId":"1","contentTxt":"Synchronous and Asynchronous","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000261","sortNo":51,"contentFormatId":"1","contentTxt":"In this example, stateFn is synchronous. But since observables are push-based, we can introduce asynchronicity without changing the public API of the function. So we can make some action handlers synchronous and some asynchronous without affecting any components. This gets important with the growth of the application, when more and more actions have to be performed in a web-worker or server. One downside of using push-based collections is that they can be awkward to use, but Angular 2 provides a primitive – the async pipe – that helps with that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000262","sortNo":52,"contentFormatId":"1","contentTxt":"Power of RxJS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000263","sortNo":53,"contentFormatId":"1","contentTxt":"RxJS comes with a lot of powerful combinators, which enables implementing complex interactions in a simple and declarative way. For instance, when action A gets emitted, the application should wait for action B and then emit a new state. If however, the action B does not get emitted in five seconds, the application should emit an error state. You can implement this in just a few lines of code using RxJS.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000264","sortNo":54,"contentFormatId":"1","contentTxt":"This is key. The complexity of application state management comes from having to coordinate such interactions. A powerful tool like RxJS, which takes care of a lot of coordination logic, can dramatically decrease the complexity of the state management.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000265","sortNo":55,"contentFormatId":"1","contentTxt":"APPLICATION AND VIEW BOUNDARY","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000266","sortNo":56,"contentFormatId":"1","contentTxt":"At this point we have not written any Angular-specific code yet, we have not written a single component. This is one of the benefits of this architecture – the application and the view logic are separated. But how do they communicate?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000267","sortNo":57,"contentFormatId":"1","contentTxt":"They communicate via the dispatcher and state objects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000268","sortNo":58,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000269","sortNo":59,"contentFormatId":"1","contentTxt":"We can create them as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000270","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000271","sortNo":61,"contentFormatId":"1","contentTxt":"1. dispatcher is a RxJS subject, which means that it is both an observable and an observer. So we can pass it into stateFn, and use it to emit actions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000272","sortNo":62,"contentFormatId":"1","contentTxt":"2. state is an observable returned by the stateFn function.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000273","sortNo":63,"contentFormatId":"1","contentTxt":"We can register the providers like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000274","sortNo":64,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000275","sortNo":65,"contentFormatId":"1","contentTxt":"And then inject them into components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000276","sortNo":66,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000277","sortNo":67,"contentFormatId":"1","contentTxt":"No Store","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000278","sortNo":68,"contentFormatId":"1","contentTxt":"Note, that in opposite to Redux or Flux, there is no store. The dispatcher is just an RxJS observer, and state is just an observable. This means that we can use the built-in RxJS combinators to change the behavior of these objects, provide mocks, etc.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000279","sortNo":69,"contentFormatId":"1","contentTxt":"No Global Objects","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000280","sortNo":70,"contentFormatId":"1","contentTxt":"Because we use dependency injection to inject the state and the dispatcher, and those are two separate objects, we can easily decorate them. For instance, we can override the dispatcher provider in a component subtree to log all the emitted actions from that subtree only. Or we can wrap the dispatcher to automatically scope all actions, which can be very handy when multiple teams are working on the same application. We can also decorate the state provider to, for instance, enable debouncing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000281","sortNo":71,"contentFormatId":"1","contentTxt":"VIEW","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000282","sortNo":72,"contentFormatId":"1","contentTxt":"Finally, we got to the most interesting part – implementing the view layer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000283","sortNo":73,"contentFormatId":"1","contentTxt":"Displaying Todos","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000284","sortNo":74,"contentFormatId":"1","contentTxt":"Let’s start with a component rendering a single todo.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000285","sortNo":75,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000286","sortNo":76,"contentFormatId":"1","contentTxt":"This is what Dan Abramov calls a dumb or presentational component. This component is not aware of the application side of things. It only knows how to render a todo.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000287","sortNo":77,"contentFormatId":"1","contentTxt":"Next, the todo list component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000288","sortNo":78,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000289","sortNo":79,"contentFormatId":"1","contentTxt":"The first thing we do here is we create an observable of filtered todos using the injected state. Since observables are push-based, they can be awkward to work with. We in the Angular team recognize this, and, that is why, provide a few things to make it easier. For instance, the async pipe “extracts” the last value of an observable. This allows us to use an observable of an object in any place where that object is required.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000290","sortNo":80,"contentFormatId":"1","contentTxt":"Second, we use the injected dispatcher to a emit new action in the emitToggle event handler.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000291","sortNo":81,"contentFormatId":"1","contentTxt":"This component is aware of the application because it injects the dispatcher and the state. Some can say this component mixes presentational and non-presentational concerns. So if you feel strong about it, you can separate this component into two. But I am not sure if it will buy you that much. Angular components already separate presentational aspects into a template. Splitting every such component into two might be an overkill.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000292","sortNo":82,"contentFormatId":"1","contentTxt":"Adding Todos","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000293","sortNo":83,"contentFormatId":"1","contentTxt":"Next, let’s create a component adding todos.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000294","sortNo":84,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000295","sortNo":85,"contentFormatId":"1","contentTxt":"Filtering Todos","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000296","sortNo":86,"contentFormatId":"1","contentTxt":"Now, let’s add an ability to filter todos:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000297","sortNo":87,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000298","sortNo":88,"contentFormatId":"1","contentTxt":"Root Component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000299","sortNo":89,"contentFormatId":"1","contentTxt":"Finally, we add a root component combining different parts into our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000300","sortNo":90,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000301","sortNo":91,"contentFormatId":"1","contentTxt":"IT IS FAST!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000302","sortNo":92,"contentFormatId":"1","contentTxt":"The pattern described does not just make Angular applications easier to organize and refactor. It also makes it more performant. This is because when the application state is stored as an immutable data structure, and the changes in the state are represented as an observable, we can set the OnPush strategy for all the Angular components. To learn more about it, read Angular, Immutability, and Ecapsulation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000303","sortNo":93,"contentFormatId":"1","contentTxt":"OTHER WAYS TO MANAGE STATE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000304","sortNo":94,"contentFormatId":"1","contentTxt":"Of course, this is not the only way to manage application state in Angular apps. For instance, you can use @ngrx/store. You can also write applications that do not use immutable data or observables, and instead use use-case services or DCI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000305","sortNo":95,"contentFormatId":"1","contentTxt":"SUMMARY","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602010000000306","sortNo":96,"contentFormatId":"1","contentTxt":"Coordinating between multiple backends, web workers, and UI components is what makes managing application state such a challenging task. Patterns like Redux and Flux help address this. In this article, I showed how easy it is to implement a similar pattern in just a few lines of code using RxJS. Then I showed how we can use it to implement a simple Angular 2 application.","contentBinary":"","contentPoster":"","contentUrl":null}]
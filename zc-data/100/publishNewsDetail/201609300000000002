[{"id":"201609300000000072","sortNo":1,"contentFormatId":"1","contentTxt":"Angular 2.0 final was made official just a few days ago and there’s never been a better time to dive in. In the last few weeks, we saw some pretty radical changes to the framework with the addition of the Ahead-of-Time (AoT) compiler, introduction of the @NgModule decorator and a new Forms Module. In this tutorial we are going to look at what’s changed with forms and more importantly how to handle form validation the right way with Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000073","sortNo":2,"contentFormatId":"1","contentTxt":"Forms bring life to our applications. It’s how we capture user input and make our applications useful. For a long time, forms have been difficult to get right. Angular 1.x made it a little easier, but came with its own set of issues and challenges, and some features like sane validation didn’t come until the framework was well into it’s 5th year.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000074","sortNo":3,"contentFormatId":"1","contentTxt":"Angular 2.x aims to make the creation and validation of forms simple, intuitive, and manageable. Pretty ambitious goals, but with the breadth of knowledge the team has from building Angular 1.x, I think Angular 2 forms can live up to these expectations. Before we dive into writing code, let’s learn a bit about Angular 2 Forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000075","sortNo":4,"contentFormatId":"1","contentTxt":"<strong>Angular 2 Forms - What’s New, What’s Changed</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000076","sortNo":5,"contentFormatId":"1","contentTxt":"Angular 2.x forms can be written in two ways. Template driven forms, as the name suggests, are forms built entirely in your UI. This is the typical way we built forms in the past and is useful for building very simple forms in Angular 2. Model driven or reactive forms, while similar to template driven forms, add an additional layer of complexity and functionality by having you to declare the model of the form in your component class. This additional functionality allows for greater control over your forms as well as making it easier to unit test your application. We’ll take a look at some of these features in this tutorial.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000077","sortNo":6,"contentFormatId":"1","contentTxt":"<strong>SETTING UP OUR APPLICATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000078","sortNo":7,"contentFormatId":"1","contentTxt":"We will write multiple different forms in this tutorial, with varying levels of complexity. To get started let’s setup our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000079","sortNo":8,"contentFormatId":"1","contentTxt":"We will setup our application with the Angular CLI. If you don’t already have the CLI installed, run npm install -g angular-cli. Make sure you have the latest version of the CLI, which at the time of this post is beta-15. With the CLI installed, create a new directory called ng2forms and in this directory run ng init. The ng init command will bootstrap our application, download all the external dependencies we’ll need, configure webpack, and basically do all of the setup work for us. Once the ng init has completed the setup process, navigate to localhost:4200 and you will see a message saying “app works!”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000080","sortNo":9,"contentFormatId":"1","contentTxt":"Next, let’s scaffold out the different forms we’ll be writing. We’ll start off by writing a very simple form to familiarize ourselves with the syntax. In your src/app directory, create a new component called app.simpleform.ts. In this file, we’ll scaffold out the most basic component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000081","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000082","sortNo":11,"contentFormatId":"1","contentTxt":"For our next component, we will build a reactive or model driven form. Create a new component titled app.complexform.ts. We’ll just scaffold it out for now with:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000083","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000084","sortNo":13,"contentFormatId":"1","contentTxt":"This form uses an external template for the UI, so we’ll also need to create an app.complexform.html file. Go ahead and create this file. Inside this file, just add a placeholder message for now.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000085","sortNo":14,"contentFormatId":"1","contentTxt":"Finally, for our third form, we’ll do some fun stuff with validation. It’s only fitting to call this component app.formvalidations.ts, so do that, and again we’ll just scaffold the component with:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000086","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000087","sortNo":16,"contentFormatId":"1","contentTxt":"Now that we have our components in place, let’s include them in our root @NgModule so that we can use them in our application. Open the app.module.ts file and make the following edits.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000088","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000089","sortNo":18,"contentFormatId":"1","contentTxt":"Finally, let’s go ahead and open the app.component.html file. This is our root component view and since we’ve declared our form components in the root module, we can use these components here without having to import them in the app.component.ts file. Let’s open up the file and include our three form components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000090","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000091","sortNo":20,"contentFormatId":"1","contentTxt":"You’ve probably noticed the Bootstrap classes, so to conclude our setup let’s just include the Bootstrap 3 library in our application. In your index.html file simply include the following in the <head> of the document:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000092","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000093","sortNo":22,"contentFormatId":"1","contentTxt":"Our setup is complete. Navigate to localhost:4200 and you should see the three components displayed. For now you’re only going to see the scaffolded message you added. Now we’re ready for the fun to begin.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000094","sortNo":23,"contentFormatId":"1","contentTxt":"<strong>SIMPLE FORM</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000095","sortNo":24,"contentFormatId":"1","contentTxt":"We are ready to write our first Angular 2 form. If you’ve done any development with Angular 2 prior to RC5, you may remember how tedious it was to deal with all of the imports. Luckily, the NgModule we worked with earlier has, for the most part, taken care of this. In the imports key, we imported the FormsModule which gave us access to the majority of the forms APIs so we can just dive in and write our code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000096","sortNo":25,"contentFormatId":"1","contentTxt":"For our simple form, we are going to create a components that captures the users first and last name, their gender, and finally a list of activities they would like to do. This data will be for an upcoming company trip and will help the event organizers plan the right activities.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000097","sortNo":26,"contentFormatId":"1","contentTxt":"Let’s go ahead and build our simple form. We’ll explain everything line by line. Open the app.simpleform.ts file and add the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000098","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000099","sortNo":28,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000100","sortNo":29,"contentFormatId":"1","contentTxt":"We’ve just written our first Angular 2 form. Head over to localhost:4200 to see the results. If all went well, you should be able to fill out the fields and hit the submit field. Notice that we set a required flag on the first name and last name attributes. You will need to enter values here to be able to submit the form. Pretty easy right? If you are writing simple Angular 2 forms, this approach may be suitable. For advanced functionality though, you will want to leverage Angular 2’s reactive forms. Let’s take a look at how those work next.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000101","sortNo":30,"contentFormatId":"1","contentTxt":"<strong>MODEL DRIVEN (REACTIVE) FORMS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000102","sortNo":31,"contentFormatId":"1","contentTxt":"Reactive forms in Angular 2 allow for much greater control over form inputs, errors, and validations. With reactive forms, we can define our form model programmatically and ensure that inputs adhere to the constraints we place on the form. Reactive forms let us dynamically create a form inside our Angular class. The best way to explain how this works, is to write some code, so let’s do that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000103","sortNo":32,"contentFormatId":"1","contentTxt":"We will recreate the form we made with the template driven approach, but this time we’ll make use of Angular 2’s reactive forms. Let’s first open up the app.complexform.ts file and add the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000104","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000105","sortNo":34,"contentFormatId":"1","contentTxt":"Our complexForm object now knows its boundaries and constraints. The complexForm object has six different fields. We haven’t added validation to these fields in this example. When we go to build the UI for this form, we’ll only be able to add the six fields that we declared or else Angular will complain. Let’s build the UI next and see how it differs from the template driven approach. Open the app.complexform.html file and add the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000106","sortNo":35,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000107","sortNo":36,"contentFormatId":"1","contentTxt":"As you can see the reactive forms approach requires a bit more work. The syntax is slightly different, but I would argue that it’s a lot more expressive and easier to understand where and how everything fits in. To see this form in action, head over to localhost:4200 and refresh the page. The form will behave the same as the template driven example above.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000108","sortNo":37,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000109","sortNo":38,"contentFormatId":"1","contentTxt":"Now that we understand a bit about the different ways to build Angular 2 forms, let’s take a look at form validation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000110","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>ANGULAR 2 FORM VALIDATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000111","sortNo":40,"contentFormatId":"1","contentTxt":"Form validation has traditionally been very challenging to get right. It’s still a wild west when it comes to form validation with certain browsers supporting native HTML5 validators, different frameworks and libraries handling validation different ways, and finally getting the user experience right can often be a challenging act.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000112","sortNo":41,"contentFormatId":"1","contentTxt":"Angular 2 supports validation for both it’s template driven and model driven approaches to forms. The model driven approach gives much greater control when it comes to validation, so we’ll use that approach. You can learn how to do template driven validation from the official Angular 2 docs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000113","sortNo":42,"contentFormatId":"1","contentTxt":"Let’s add validation to the form we’ve been using so far. Open the app.formvalidation.ts file. We’ll combine our logic and template and do everything in the .ts file so that it’s easier to follow along. Our initial app.formvalidation.ts file will look like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000114","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000115","sortNo":44,"contentFormatId":"1","contentTxt":"Next, we are going to programmatically add validators to our form. To do this we’ll need to import the Angular validators from the forms package. Our imports will then look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000116","sortNo":45,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000117","sortNo":46,"contentFormatId":"1","contentTxt":"Now we can use the prebuilt Angular validators in our form. Let’s see how we can add validations to our form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000118","sortNo":47,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000119","sortNo":48,"contentFormatId":"1","contentTxt":"If we look at our form now, we won’t notice a difference. We can still hit the submit button and the form will submit. We’ll have to add some additional markup in our template to make the validator do what we want. An easy win is to disable the submit button if the form is not valid.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000120","sortNo":49,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000121","sortNo":50,"contentFormatId":"1","contentTxt":"If we look at the form now, we’ll see the form is disabled. Notice how we are able to use the disabled API and aren’t required to use any specific Angular 2 conventions. We can make the from valid by adding a first name, a last name that is between 5 and 10 characters, and selecting a gender. If we do this, the submit button will no longer be disabled and we will be able to submit the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000122","sortNo":51,"contentFormatId":"1","contentTxt":"This works, but is not a great user experience. The user has no indication which form field is invalid or what to do to make it valid. Let’s add some additional markup in our view to tell the user which field is invalid. We’ll start by marking an invalid field a different color.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000123","sortNo":52,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000124","sortNo":53,"contentFormatId":"1","contentTxt":"This is a little bit better. The user now has some context to let them know what is wrong. As soon as they meet the criteria for making the input field valid, the error goes away. The problem we are having now is that the error messages are displayed all the time. This is not ideal. We don’t want the user seeing a bunch of error messages before they’ve even had a chance to start completing the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000125","sortNo":54,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000126","sortNo":55,"contentFormatId":"1","contentTxt":"If you’ve worked with Angular 1.x, you may remember the various attributes that each form element gets such as pristine, touched, etc. based on the state of the form. We get those same exact attributes for our Angular 2 forms. We can defer the error handling from displaying until the user has at least had some interaction with the form. Let’s see how we can do this. As we won’t need to make any TypeScript changes, we’ll just show the UI template portion of the component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000127","sortNo":56,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000128","sortNo":57,"contentFormatId":"1","contentTxt":"Finally, let’s add some more context to our errors. We will display a message for each error. This will let the user know exactly what the problem is. Angular 2 gives us an easy way to know which validation has failed. Let’s see how this works. We’ll just show the UI template code here as we won’t be needed any additional TypeScript changes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000129","sortNo":58,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000130","sortNo":59,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000131","sortNo":60,"contentFormatId":"1","contentTxt":"Our form is looking good now. We have pretty sophisticated validation in place. The user will always have context for what is causing the error and know the steps to take to correct it. This was just one way to handle validation. There are many others, but I think we covered the main methods of how validation in Angular 2 works so now you can explore and see what works best for your use cases.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000132","sortNo":61,"contentFormatId":"1","contentTxt":"Angular 2 also has a pretty great infrastructure in place for creating your own validators. We won’t do that in this tutorial, but we will cover it in a future post. Angular 2 comes with a pretty good list of validators including: required, minimum length, maximum length, null and pattern validator which allows you to define any regular expression to match the input against.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000133","sortNo":62,"contentFormatId":"1","contentTxt":"<strong>Building An Angular 2 Form To Interact With The Auth0 Api</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000134","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000135","sortNo":64,"contentFormatId":"1","contentTxt":"So far the forms we’ve written have been fairly static. We didn’t do anything with the input other than log it to the console. To close out this tutorial, let’s write a dynamic login form. Rather than building a backend server to handle the authentication, we’ll use the Auth0 API to authenticate a user. Sign up for a free Auth0 account to get started.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000136","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000137","sortNo":66,"contentFormatId":"1","contentTxt":"Once you have your Auth0 account created, login to the management dashboard and get your Client Id. This is all we’ll need for now. Let’s go ahead and create a new component called app.login.ts. We’ll scaffold this component as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000138","sortNo":67,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000139","sortNo":68,"contentFormatId":"1","contentTxt":"Next, let’s include our newly created component in our root module so that we can use this component throughout our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000140","sortNo":69,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000141","sortNo":70,"contentFormatId":"1","contentTxt":"Finally, we’ll add our login component to our root component view. Open the app.component.html file and make the following edits:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000142","sortNo":71,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000143","sortNo":72,"contentFormatId":"1","contentTxt":"Now we’re ready to implement our login form. Let’s open the app.login.ts file. We’ll inline our template again. Let’s examine the code line by line and explain how we are going to do this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000144","sortNo":73,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000145","sortNo":74,"contentFormatId":"1","contentTxt":"Our login form is ready to be tested. Navigate to localhost:4200 and you should see the newly created login form. You’ll need to have an Auth0 user account created before you can login. You can create an account from your Auth0 Dashboard in the Users section and then test this functionality.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000146","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000147","sortNo":76,"contentFormatId":"1","contentTxt":"Writing your own authentication mechanism is no easy task. We only added the ability to login, and even that was pretty incomplete. The Auth0 Lock widget can handle all things auth for us including sign in, sign up, social connections, enterprise federation, multifactor authentication and much more. We can integrate Lock with our Angular 2 applications using the angular2-jwt library.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000148","sortNo":77,"contentFormatId":"1","contentTxt":"<strong>Putting It All Together</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000149","sortNo":78,"contentFormatId":"1","contentTxt":"Today we looked at how Angular 2 helps us create and validate forms. We looked at the different ways users can create forms and the benefits of each. Validation can be a daunting task, but Angular 2 comes with a lot of helpers right out of the gate which help a great deal. Finally, we added some actual functionality to our forms, by calling the Auth0 API and showing how you can make HTTP requests with Angular 2 forms. If you would like to see the completed demo, you can get it from Github, and if you want to implement it yourself, be sure to sign up for a free Auth0 account.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000150","sortNo":79,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000151","sortNo":80,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/scotch-io/angular-2-form-validation\">https://github.com/scotch-io/angular-2-form-validation</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201603040000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In this post I will explain the purpose of the new @Input and @Output annotations in Angular 2.0.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000002","sortNo":2,"contentFormatId":"1","contentTxt":"@Input","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000003","sortNo":3,"contentFormatId":"1","contentTxt":"The purpose of @Input is to configure data bound input properties with support for change tracking. Basically it is the Angular 2.0 way to inject values directly into a component via property bindings in the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000004","sortNo":4,"contentFormatId":"1","contentTxt":"In my example I have defined a simple component with three @Input properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000005","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Next I have created a new component where I instantiate the sample component in order to demonstrate how to pass data via the @Input properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000007","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000008","sortNo":8,"contentFormatId":"1","contentTxt":"Let's address the three different @Input properties one by one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000009","sortNo":9,"contentFormatId":"1","contentTxt":"The most basic one is @Input counter since the name of the property matches the property binding in the DOM - [counter]=”count”. As I mentioned earlier @Input bindings are subject to change detection, so every time “count” changes, the counter value is updated with the new value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000010","sortNo":10,"contentFormatId":"1","contentTxt":"In the next one - @Input('mySum') - I have defined an alias which let's me override the property name to be the alias instead of the original property name: [mySum]=”runningTotal”. Other than that everything is like before though.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000011","sortNo":11,"contentFormatId":"1","contentTxt":"It gets more interesting when we look at “growingString” since it allows for processing of the raw bound value via the setter function. This is added flexibility since we can use the setter to transform the value rather than using it directly. Nothing is changed when it comes to referencing the property in the DOM though.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000012","sortNo":12,"contentFormatId":"1","contentTxt":"In all cases so far we have been looking at bound property values using the new [] property syntax. Properties are ideal in cases where we want change tracking on our values, but what if we just want to hard code a value and assign it to our component? It turns out we can do this using regular DOM attributes. The attribute 'plain' is an example of this. Notice how I access the DOM attribute in the constructor by wrapping it in @Attribute('plain').","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000013","sortNo":13,"contentFormatId":"1","contentTxt":"It turns out we actually have a second option for getting simple hard coded attributes from the markup. In my sample I have declared 'fixedValue' as an @Input. If I assign 'fixedValue' a value in the markup, without using [], it will still capture the value from the markup and assign it to the class property 'fixedValue'. In some cases this might be more convenient than @Attribute for fixed values where you don't need change tracking.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000014","sortNo":14,"contentFormatId":"1","contentTxt":"@Output","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000015","sortNo":15,"contentFormatId":"1","contentTxt":"The purpose of @Output is to trigger custom events in components and create a channel for inter component communication. In my example I have defined stringChanged as an @Output, and every time the bound string changes, I emit a custom event. Notice how I am subscribing to the event in the markup using the (stringChanged)=\"myStringChanged($event)\" syntax. Passing $event is important since it gives access to any data passed via the custom event.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000016","sortNo":16,"contentFormatId":"1","contentTxt":"demo","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000017","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000018","sortNo":18,"contentFormatId":"1","contentTxt":"sourcecode","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603040000000019","sortNo":19,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/thelgevold/angular-2-samples\">https://github.com/thelgevold/angular-2-samples</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
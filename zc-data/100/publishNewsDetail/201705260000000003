[{"id":"201705260000000261","sortNo":1,"contentFormatId":"1","contentTxt":"<strong>Reactive Programming in the Core Framework</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000262","sortNo":2,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000263","sortNo":3,"contentFormatId":"1","contentTxt":"An Angular application is a reactive system. The user clicks on a button, the application reacts to this event and updates the model. The model gets updated, the application propagates the changes through the component tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000264","sortNo":4,"contentFormatId":"1","contentTxt":"Angular implements these two arrows very differently. Let’s explore why.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000265","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000266","sortNo":6,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000267","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000268","sortNo":8,"contentFormatId":"1","contentTxt":"<strong>Events and State</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000269","sortNo":9,"contentFormatId":"1","contentTxt":"To understand why Angular uses two very different ways of reactive programming, we need to look at the differences between events and the state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000270","sortNo":10,"contentFormatId":"1","contentTxt":"We often talk about events or event streams when discussing reactivity. Event streams are an important category of reactive objects, but so is state. So let’s compare their properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000271","sortNo":11,"contentFormatId":"1","contentTxt":"Events are discrete and cannot be skipped. Every single event matters, including the order in which the events are emitted. The “most recent event” is not a special thing we care about. Finally, very rarely are events directly displayed to the user.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000272","sortNo":12,"contentFormatId":"1","contentTxt":"The state, on the other hand, is continuous, i.e., it is defined at any point in time. We usually do not care about how many times it gets updated — only the most recent value matters. The state is often displayed or has a meaningful serialization form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000273","sortNo":13,"contentFormatId":"1","contentTxt":"Say the conference application we use in this series has a “Load More” button, clicking on which loads more items and adds them to the list. Using this button and mouse click events we can change the content of the list. Clicking on the button increases the number of items. The number of clicks matters. And we cannot skip any of them, as it would change the content of the list. Finally, we will never have to examine the last click event or display it to the user.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000274","sortNo":14,"contentFormatId":"1","contentTxt":"The list itself, on the other hand, is the state. We only care about its latest value, not about how many times it was updated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000275","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>Definition</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000276","sortNo":16,"contentFormatId":"1","contentTxt":"Event streams are sequences of values produced over a period of time. And the state is a single value that varies over time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000277","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000278","sortNo":18,"contentFormatId":"1","contentTxt":"In this example, the talk input of TalkCmp is the state, which is derived from the talks property of the app object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000279","sortNo":19,"contentFormatId":"1","contentTxt":"Note that we only care about the most recent value of talk, i.e., skipping an intermediate value of talk won’t affect anything. Contrast it with the selected event sequence, where every single emitted value matters, including the order in which they are emitted.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000280","sortNo":20,"contentFormatId":"1","contentTxt":"<strong>Time</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000281","sortNo":21,"contentFormatId":"1","contentTxt":"Another thing that is different in regards to the state and events is their relation to time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000282","sortNo":22,"contentFormatId":"1","contentTxt":"Using time when deriving the state is rarely practical, i.e., time is always implicit. Using time when dealing with events is common (e.g., debouncing), i.e., time is often explicit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000283","sortNo":23,"contentFormatId":"1","contentTxt":"To make dealing with time easier, Angular has support for reified reactive programming.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000284","sortNo":24,"contentFormatId":"1","contentTxt":"What is it?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000285","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Reified and Transparent</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000286","sortNo":26,"contentFormatId":"1","contentTxt":"Let’s look at this example one more time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000287","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000288","sortNo":28,"contentFormatId":"1","contentTxt":"Or to be more specific, let’s look at the {{talk.title}} binding. Angular does not provide any object representing it — we only get the current value. We can call this type of reactive programming transparent because the developer only interacts with the most recent value, and the act of observation is hidden in the framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000289","sortNo":29,"contentFormatId":"1","contentTxt":"When propagating state we only care about the latest value, and we don’t usually need to worry about time. And that’s why Angular uses this type of reactive programming here. It is simpler and a lot more performant. Plus we can use ‘plain’ JavaScript to composes different values changing over time, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000290","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000291","sortNo":31,"contentFormatId":"1","contentTxt":"Now, let’s look at the selected event. Angular gives us a EventEmitter object to represent it. We can call this type of reactive programming reified because we have access to a concrete object representing the act of observation. And having these concrete objects is powerful because we can manipulate them, pass them around, and compose them. In particular, we can use them to explicitly handle time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000292","sortNo":32,"contentFormatId":"1","contentTxt":"This type of reactive programming is more powerful, but it is also more complicated: we have to use special operators to do composition. For instance, the example above will have to be rewritten like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000293","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000294","sortNo":34,"contentFormatId":"1","contentTxt":"When handling events we often care about the time aspect, and that’s why Angular uses this type of reactive programming for managing events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000295","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>Observables</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000296","sortNo":36,"contentFormatId":"1","contentTxt":"There are many ways to implement event streams or reified reactive programming. Angular embraced RxJS, and the EventEmitter class is just an implementation of RxJS/Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000297","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>RxJS and Reactive Programming</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000298","sortNo":38,"contentFormatId":"1","contentTxt":"When saying “reactive programming”, many are referring to programming using RxJS. Most of what you do in Angular is reactive even if you don’t use RxJS. Reified reactive programming is a better way to refer to programming using observable-based APIs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000299","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>What About Event Callbacks?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000300","sortNo":40,"contentFormatId":"1","contentTxt":"Since reified reactive programming is more complicated than transparent reactive programming, Angular supports handling events in a more traditional way by supplying callbacks (e.g., the click handler in the example above). In other words, we can use both transparent and reified programming to handle events. We will see the same being true in other parts of the framework and the ecosystem: we can use transparent reactive programming for simple use cases, and the reified one for advanced ones.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000301","sortNo":41,"contentFormatId":"1","contentTxt":"Reactive Programming in the Angular Ecosystem","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000302","sortNo":42,"contentFormatId":"1","contentTxt":"We have looked at how the Angular core framework itself supports reactive programming. Now let’s look at the Angular ecosystem.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000303","sortNo":43,"contentFormatId":"1","contentTxt":"<strong>@angular/forms</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000304","sortNo":44,"contentFormatId":"1","contentTxt":"Angular has always had strong support for building dynamic forms. It’s one of the main reasons the framework got so successful.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000305","sortNo":45,"contentFormatId":"1","contentTxt":"Now the framework comes with a module that adds support for handling input using reified reactive programming.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000306","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000307","sortNo":47,"contentFormatId":"1","contentTxt":"Look at how elegant this solution is. We simply define a form with two controls, which we bind to the two input elements in the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000308","sortNo":48,"contentFormatId":"1","contentTxt":"Then we use the valueChanges observable to wait for the form to get stable before firing a request. We use the switchMap operator to ignore all the requests but the last one, so the filters form and the data will never get out of sync. We then bind the created observable using the async pipe to display the list of talks.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000309","sortNo":49,"contentFormatId":"1","contentTxt":"Implementing this without ReactiveFormsModule requires a lot of manual state management, correlation IDs, and is not easy to get right.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000310","sortNo":50,"contentFormatId":"1","contentTxt":"That’s why ReactiveFormsModule is one of the most useful additions to the framework. It enables us to solve many input-handling problems in an elegant way, with just a few lines of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000311","sortNo":51,"contentFormatId":"1","contentTxt":"For simple cases, however, we can still grab the current value, which is transparently kept in sync with the UI, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000312","sortNo":52,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000313","sortNo":53,"contentFormatId":"1","contentTxt":"<strong>@angular/router</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000314","sortNo":54,"contentFormatId":"1","contentTxt":"The Angular router is built around the same ideas. It gives us a simple API to get the current value of params to use in simple use cases, and an observable-based API for more interesting situations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000315","sortNo":55,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000316","sortNo":56,"contentFormatId":"1","contentTxt":"It also exposes all router events via an observable that can be used as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000317","sortNo":57,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000318","sortNo":58,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000319","sortNo":59,"contentFormatId":"1","contentTxt":"An Angular application is a reactive system. And that’s why we need to understand reactive programming to be productive with Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000320","sortNo":60,"contentFormatId":"1","contentTxt":"Reactive programming works with event streams and the state. And it can be divided into transparent and reified.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000321","sortNo":61,"contentFormatId":"1","contentTxt":"Since the very beginning the framework has had excellent support for transparent reactive programming. It was used both to propagate the state and to handle events. It is simple and fast. And the new versions of the framework still support it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000322","sortNo":62,"contentFormatId":"1","contentTxt":"But it can also be limiting at times and make solving certain problems difficult. That’s why Angular now comes with support for reified reactive programming, using observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000323","sortNo":63,"contentFormatId":"1","contentTxt":"The Angular ecosystem embraced these ideas as well. The reactive forms module, the router, and other libraries like NgRx, all provide observable-based APIs.","contentBinary":"","contentPoster":"","contentUrl":null}]
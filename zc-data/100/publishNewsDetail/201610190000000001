[{"id":"201610190000000001","sortNo":1,"contentFormatId":"1","contentTxt":"If there was one feature in Angular that made us go “Wow”, then it was probably its two-way data binding system. Changes in the application state have been automagically reflected into the view and vise-versa. In fact, we could build our own directives with two-way data bound scope properties, by setting a configuration value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Angular 2 doesn’t come with such a (built-in) two-way data binding anymore. However, this doesn’t mean we can’t create directives that support two-way data binding. In this article we’re going to explore how two-way data binding in Angular 2 is implemented and how we can implement it in our own directives.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Two-way data binding in a nutshell</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000004","sortNo":4,"contentFormatId":"1","contentTxt":"There’s one directive in Angular 2 that implements two-way data binding: ngModel. On the surface, it looks and behaves as magical as we’re used to (from Angular 1). But how does it really work? It’s not that hard really. In fact, it turns out that two-way data binding really just boils down to event binding and property binding.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000005","sortNo":5,"contentFormatId":"1","contentTxt":"In order to understand what that means, let’s take a look at this code snippet here:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000006","sortNo":6,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000007","sortNo":7,"contentFormatId":"1","contentTxt":"Right, this is that one demo that blew our minds back in 2009, implemented in Angular 2. When typing into the input, the input’s value is written into the username model and then reflected back into the view, resulting in a nice greeting.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000008","sortNo":8,"contentFormatId":"1","contentTxt":"How does this all work? Well, as mentioned earlier, two-way data binding in Angular 2 really just boils down to property binding and event binding. There is no such thing as two-way data binding. Without the ngModel directive, we could easily implement two-way data binding just like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000009","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Let’s take a closer look at what’s going on here:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000011","sortNo":11,"contentFormatId":"1","contentTxt":"1. [value]=”username” - Binds the expression username to the input element’s value property","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000012","sortNo":12,"contentFormatId":"1","contentTxt":"2. (input)=”expression” - Is a declarative way of binding an expression to the input element’s input event (yes there’s such event)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000013","sortNo":13,"contentFormatId":"1","contentTxt":"3. username = $event.target.value - The expression that gets executed when the input event is fired","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000014","sortNo":14,"contentFormatId":"1","contentTxt":"4. $event - Is an expression exposed in event bindings by Angular, which has the value of the event’s payload","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Considering these observations, it becomes very clear what’s happening. We’re binding the value of the username expression to the input’s value property (data goes into the component).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000016","sortNo":16,"contentFormatId":"1","contentTxt":"We also bind an expression to the element’s input event. This expression assigns the value of $event.target.value to the username model. But what is $event.target.value? As mentioned, $event is the payload that’s emitted by the event. Now, what is the payload of the input event? It’s an InputEventObject, which comes with a target property, which is a reference to the DOM object that fired the event (our input element). So all we do is, we’re reading from the input’s value property when a user enters a value (data comes out of the component).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000017","sortNo":17,"contentFormatId":"1","contentTxt":"That’s it. That’s two-way data binding in a nutshell. Wasn’t that hard right?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000018","sortNo":18,"contentFormatId":"1","contentTxt":"Okay cool, but when does ngModel come into play then? Since a scenario like the one shown above is very common, it just makes sense to have a directive that abstracts things away and safes us some keystrokes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000019","sortNo":19,"contentFormatId":"1","contentTxt":"<strong>Understanding ngModel</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000020","sortNo":20,"contentFormatId":"1","contentTxt":"If we take a look at the source code, we’ll notice that ngModel actually comes with a property and event binding as well. Here’s what our example looks like using ngModel, but without using the shorthand syntax:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000021","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000022","sortNo":22,"contentFormatId":"1","contentTxt":"Same rules apply. The property binding [ngModel] takes care of updating the underlying input DOM element. The event binding (ngModelChange) notifies the outside world when there was a change in the DOM. We also notice that the handler expression uses only $event and no longer $event.target.value. Why is that? As we’ve mentioned earlier, $event is the payload of the emitted event. In other words, ngModelChange takes care of extracting target.value from the inner $event payload, and simply emits that (to be technically correct, it’s actually the DefaultValueAccessor that takes of the extracting that value and also writing to the underlying DOM object).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000023","sortNo":23,"contentFormatId":"1","contentTxt":"Last but not least, since writing username and ngModel twice is still too much, Angular allows the shorthand syntax using [()], also called “Banana in a box”. So after all, it’s really an implementation detail of ngModel that enables two-way data binding.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000024","sortNo":24,"contentFormatId":"1","contentTxt":"<strong>Creating custom two-way data bindings</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Using this knowledge, we can now build our own custom two-way data bindings. All we have to do is to follow the same rules that ngModel follows, which are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000026","sortNo":26,"contentFormatId":"1","contentTxt":"1. Introduce a property binding (e.g. [foo])","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000027","sortNo":27,"contentFormatId":"1","contentTxt":"2. Introduce a event binding with the same name, plus a Change suffix (e.g. (fooChange))","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000028","sortNo":28,"contentFormatId":"1","contentTxt":"3. Make sure the event binding takes care of property extraction (if needed)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000029","sortNo":29,"contentFormatId":"1","contentTxt":"As you can see, there’s a bit more work involved to make two-way data binding work compared to Angular 1. However, we should also always consider if a custom two-way data binding implementation is really needed, or if we can just take advantage of ngModel. This, for example is the case when building custom form controls.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000030","sortNo":30,"contentFormatId":"1","contentTxt":"Let’s say we create a custom counter component and ignore of a second that this would rather be a custom form control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000031","sortNo":31,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000032","sortNo":32,"contentFormatId":"1","contentTxt":"It has an internal counter property that is used to display the current counter value. In order to make this property two-way data bound, the first thing we have to do is to make it an Input property. Let’s add the @Input() decorator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000033","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000034","sortNo":34,"contentFormatId":"1","contentTxt":"This already enables us to bind expression to that property as a consumer of that component like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000035","sortNo":35,"contentFormatId":"1","contentTxt":"The next thing we need to do, is to introduce an @Output() event with the same name, plus the Change suffix. We want to emit that event, whenever the value of the counter property changes. Let’s add an @Output() property and emit the latest value in the setter interceptor:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000036","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000037","sortNo":37,"contentFormatId":"1","contentTxt":"That’s it! We can now bind an expression to that property using the two-way data binding syntax:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000038","sortNo":38,"contentFormatId":"1","contentTxt":"Check out the demo and try it out!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000039","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000040","sortNo":40,"contentFormatId":"1","contentTxt":"Again, please keep in mind that a component like a custom counter, would better serve as a custom form control and takes advantage of ngModel to implement two-way data binding as explained in this article.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000041","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>Conclusion</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000042","sortNo":42,"contentFormatId":"1","contentTxt":"Angular 2 doesn’t come with built-in two-way data binding anymore, but with APIs that allow to implement this type of binding using property and event bindings. ngModel comes as a built-in directive as part of the FormsModule to implement two-way data binding and should be preferred when building components that serve as custom form controls.","contentBinary":"","contentPoster":"","contentUrl":null}]
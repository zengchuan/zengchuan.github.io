[{"id":"201604080000000001","sortNo":1,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Angular 2 has finally hit beta which was the mental milestone for me to start writing Angular 2 content. Hooray! To kick things off, I wanted to port a project that I covered in my Building a Website with AngularJS Pt 2 – Now With State! post to Angular 2. We are going to get acquainted with the brave new world of Angular 2 by building out a simple website so we can see how the Angular 2 pieces come together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Compile and Serve","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000004","sortNo":4,"contentFormatId":"1","contentTxt":"There are two main ways to compile and serve an Angular 2 application and that is via webpack or systemjs. For the sake of simplicity, we are going to go with systemjs and borrow from the Tour of Heroes repository which is covered in the official Angular 2 Tutorial.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000005","sortNo":5,"contentFormatId":"1","contentTxt":"You can write your Angular 2 application in ES5, EcmaScript 2015 or TypeScript, but the framework lends itself best to TypeScript. Writing in TypeScript requires a bit more setup but the return on investment is tenfold in terms of productivity and clarity in our code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000006","sortNo":6,"contentFormatId":"1","contentTxt":"When you download the repository, the first thing you need to do is run npm i to install the package dependencies.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000007","sortNo":7,"contentFormatId":"1","contentTxt":"tsconfig.json","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000008","sortNo":8,"contentFormatId":"1","contentTxt":"One of the package dependencies that we are going to install is typescript, which we will use to compile our TypeScript into the Type O negative version of JavaScript: the universal donor, ES5. We need to tell our compiler how we want to compile our TypeScript files, so we need to create a tsconfig.json file. The file below reads pretty well, but I will call out the two most important properties and those are “target”: “ES5” and “module”: “system”. We are setting our ECMAScript version to ES5 and indicating that we want to generate our modules in the system format.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000009","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000010","sortNo":10,"contentFormatId":"1","contentTxt":"packages.json","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000011","sortNo":11,"contentFormatId":"1","contentTxt":"We have defined how we want our TypeScript to be compiled, now we need to create a hook for the work to be done. In our packages.json file, we have defined a few tasks to watch our project, compile our source files and serve them up via a liteweight HTTP server. The task tsc:w calls our TypeScript compiler with the -w flag (which is shorthand for –watch) and the start task kicks off our compiler while spinning up our web server via npm run lite.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000012","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000013","sortNo":13,"contentFormatId":"1","contentTxt":"We then call npm start when we are ready to compile and serve our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000014","sortNo":14,"contentFormatId":"1","contentTxt":"Bootstrapping","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000015","sortNo":15,"contentFormatId":"1","contentTxt":"The first mystery of Angular 2 for me was “How in the world do I even run the app!?”. The second mystery was “Okay, so how do I bootstrap the application?!”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000016","sortNo":16,"contentFormatId":"1","contentTxt":"The first thing we need to do to bootstrap our application is to include the necessary resources into our index.html file. Outside of the obvious Angular resources, the most important file at this stage of the game is system.src.js which is going to serve as our module loader.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000017","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000018","sortNo":18,"contentFormatId":"1","contentTxt":"We are going to use systemjs via System to import our boot module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000019","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000020","sortNo":20,"contentFormatId":"1","contentTxt":"Inside the boot.ts file, we are importing three components; bootstrap, ROUTER_PROVIDERS and AppComponent. We then instantiate our application and specify our root level component, AppComponent and inject ROUTER_PROVIDERS as a submodule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000021","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000022","sortNo":22,"contentFormatId":"1","contentTxt":"Back in our index.html file, our entry point in the markup happens at this line: <app>Loading…</app>. Angular has instantiated AppComponent and loaded its template into the app element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000023","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000024","sortNo":24,"contentFormatId":"1","contentTxt":"We have just covered how to compile, serve and bootstrap an Angular 2 application. Let us unpack what a component consists of so that we can make the connection between how AppComponent becomes app on our page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000025","sortNo":25,"contentFormatId":"1","contentTxt":"The App Component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000026","sortNo":26,"contentFormatId":"1","contentTxt":"Angular components are really just JavaScript classes wrapped with love in Angular 2 metadata.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000027","sortNo":27,"contentFormatId":"1","contentTxt":"The first thing I do when creating a component is to create the class. I will usually just stub it out because I will enhance it later.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000028","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000029","sortNo":29,"contentFormatId":"1","contentTxt":"The next thing we are going to do is to import our dependencies. In this case, we just need to import Component from angular2/core.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000030","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000031","sortNo":31,"contentFormatId":"1","contentTxt":"And from here, we are going to decorate our class by adding @component metadata to tell our application how we want the AppComponent to behave. We are defining the HTML element we want this class to target in the selector property as well as setting our template and styles via templateUrl and styleUrls, respectively. We are also injecting ROUTER_DIRECTIVES into our component at the directives property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000032","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000033","sortNo":33,"contentFormatId":"1","contentTxt":"This is where things get a bit fluid in the CIDER process. I will often spend n iterations enhancing my components and this could go on indefinitely. In our case, we want to add in routing to our application and so we are going to import the appropriate modules and decorate our component with @RouteConfig. To enable routing, we are going to import RouteConfig and ROUTER_DIRECTIVES as well as AboutComponent, ExperimentsComponent and HomeComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000034","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000035","sortNo":35,"contentFormatId":"1","contentTxt":"We need the routing modules to enable routing and the additional components for our routing table. We are passing in an array of route definitions into @RouteConfig, which tell us the path of the route, the name of the route and what component is going to be mapped to that route. We want our home route to be our default route and so we will set that with useAsDefault: true. We will circle back around and talk about how the templates deal with routes in a moment but the basic gist of the new component router in Angular 2 is that each route maps to a component. Not really sure why they called it ComponentRouter though… JK!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000036","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000037","sortNo":37,"contentFormatId":"1","contentTxt":"We are also going to import StateService and ExperimentsService into our component and then decorate our component on the providers property which we will cover later. And I now present the #drumRoll AppComponent in its entirety!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000038","sortNo":38,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000039","sortNo":39,"contentFormatId":"1","contentTxt":"To complete the CIDER process, we are going to repeat the process on a sub-component. All three of our components defined in our router are pretty much the same and so we are going to focus on the HomeComponent. There is some additional functionality in the ExperimentComponent that we will cover in a later post.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000040","sortNo":40,"contentFormatId":"1","contentTxt":"The Home Component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000041","sortNo":41,"contentFormatId":"1","contentTxt":"We are going to break ground on our HomeComponent by defining the HomeComponent class. We are also defining and initializing two properties on our class for the component’s title and body. This is a website after all!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000042","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000043","sortNo":43,"contentFormatId":"1","contentTxt":"We will import the appropriate dependencies.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000044","sortNo":44,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000045","sortNo":45,"contentFormatId":"1","contentTxt":"We will then decorate our class and set the selector and templateUrl properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000046","sortNo":46,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000047","sortNo":47,"contentFormatId":"1","contentTxt":"We are going to use the StateService to store state between our routes and so we will add that to our component. Dependency injection within Angular 2 happens at the constructor and so we are going to add one to our class and inject the StateService. Components also have lifecycle hooks that we can use to sequence units of work. In our case, we want to retrieve and set our message from StateService when our component is initialized. We will use the ngOnInit hook to make that call for us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000048","sortNo":48,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000049","sortNo":49,"contentFormatId":"1","contentTxt":"Again, incredibly self-documenting and easy to read.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000050","sortNo":50,"contentFormatId":"1","contentTxt":"The State Service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000051","sortNo":51,"contentFormatId":"1","contentTxt":"We are going to create the StateService class and then expose it as a provider to our application. I am not going to offer too much commentary on the code below because it is so rudimentary in nature. It is essentially a service that has a getter and a setter for a message property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000052","sortNo":52,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000053","sortNo":53,"contentFormatId":"1","contentTxt":"Things get interesting when we want to make StateService available for injection into other components. The first step is to import Injectable into our class.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000054","sortNo":54,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000055","sortNo":55,"contentFormatId":"1","contentTxt":"And then we decorate it with @Injectable().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000056","sortNo":56,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000057","sortNo":57,"contentFormatId":"1","contentTxt":"We have spent most of our time working through building our components, so let us complete the loop by locking down our templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000058","sortNo":58,"contentFormatId":"1","contentTxt":"The Views","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000059","sortNo":59,"contentFormatId":"1","contentTxt":"Using home.component.html as our reference point, let us take an abbreviated tour of the updated template syntax in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000060","sortNo":60,"contentFormatId":"1","contentTxt":"One-way data binding is defined exactly like it was in Angular 1.x through string interpolation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000061","sortNo":61,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000062","sortNo":62,"contentFormatId":"1","contentTxt":"User input events are no longer captured by adding custom Angular directives to our markup but rather through capturing native DOM events and wrapping them in parenthesis. We can see this in the code below as we capture the click event with (click)=”updateMessage(message)” and call updateMessage.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000063","sortNo":63,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000064","sortNo":64,"contentFormatId":"1","contentTxt":"Two-way data binding in Angular 2 is basically one-way data binding applied twice. We talked about binding using string interpolation but we can also bind to properties using brackets syntax. We combine property binding (component to view) and event binding (view to component) to accomplish two-way data binding. The solution is surprisingly simple as we wrap our ngModel in both brackets and parenthesis to make [(ngModel)]=”message”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000065","sortNo":65,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000066","sortNo":66,"contentFormatId":"1","contentTxt":"For context, here is the entire home template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000067","sortNo":67,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000068","sortNo":68,"contentFormatId":"1","contentTxt":"Routing Markup","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000069","sortNo":69,"contentFormatId":"1","contentTxt":"We are back to where we started as we wrap up this lesson with a discussion on the template syntax for routing in app.component.html. When we define a route, where does the component’s template actually get inserted? We set that insert point with router-outlet. It is the new ngView.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000070","sortNo":70,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000071","sortNo":71,"contentFormatId":"1","contentTxt":"Great! So how do we navigate from one route to another? We do that with routerLink in the form of [routerLink]=”[‘/Home’]” as we can see in the code below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000072","sortNo":72,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000073","sortNo":73,"contentFormatId":"1","contentTxt":"And the entire app.component.html.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000074","sortNo":74,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000075","sortNo":75,"contentFormatId":"1","contentTxt":"Review","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000076","sortNo":76,"contentFormatId":"1","contentTxt":"Before you raise your billable rates by 15% and start selling this sweet Angular 2 website, let us do a quick review of what we covered.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000077","sortNo":77,"contentFormatId":"1","contentTxt":"1. We define how we want to compile TypeScript in our tsconfig.json file.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000078","sortNo":78,"contentFormatId":"1","contentTxt":"2. We use tsc -w and lite-server to compile and serve our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000079","sortNo":79,"contentFormatId":"1","contentTxt":"3. We learned how to use systemjs to handle module loading and bootstrapping our application","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000080","sortNo":80,"contentFormatId":"1","contentTxt":"4. We saw how to use CIDER to build out our AppComponent and HomeComponent","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000081","sortNo":81,"contentFormatId":"1","contentTxt":"5. We learned how to created an injectable service using @Injectable() metadata.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000082","sortNo":82,"contentFormatId":"1","contentTxt":"6. We did an abbreviated tour of the Angular 2 binding syntax.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000083","sortNo":83,"contentFormatId":"1","contentTxt":"7. We learned how routes are added to our view with router-outlet and the syntax for navigating to a route using routerLink","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000084","sortNo":84,"contentFormatId":"1","contentTxt":"Let me know what you else you would like to learn in the comments below and in the meantime… #highFive!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000085","sortNo":85,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000086","sortNo":86,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/simpulton/angular2-website-routes\">https://github.com/simpulton/angular2-website-routes</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201604080000000153","sortNo":1,"contentFormatId":"1","contentTxt":"The Evolution of Angular State Management","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000154","sortNo":2,"contentFormatId":"1","contentTxt":"State management within Angular started out as a single celled organism if you will in the form of a single controller managing all the state for the application. If this is a single page application, one controller makes sense right? We emerged out of the ice age by starting to group our views and controllers into smaller, self-contained units either within a directive or a route. This was a vast improvement, but there was still the problem of managing complex state within our applications. It was not uncommon for us to have bits and pieces of state strewn across our application tucked inside of controllers, services, routes, directives, and occasionally, in our templates. Mutable state in itself is not inherently evil but shared mutable state is a recipe for disaster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000155","sortNo":3,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000156","sortNo":4,"contentFormatId":"1","contentTxt":"Just as modern web frameworks like Angular permanently altered our jQuery-centric approach to app development, React has fundamentally changed the way that we approach state-management while using modern web frameworks. Redux is front and center of this shift as it introduced an elegant, yet profoundly simple way to manage application state. It is worth mentioning, Redux (big R) is a library but more importantly it is a design pattern (little r) that is completely framework agnostic and coincidentally works really well with Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000157","sortNo":5,"contentFormatId":"1","contentTxt":"The beauty of redux is that it can be articulated in just a few sentences. In fact, my “ah ha!” moment could be summarized in three main points.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000158","sortNo":6,"contentFormatId":"1","contentTxt":"Single State Tree","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000159","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000160","sortNo":8,"contentFormatId":"1","contentTxt":"The fundamental premise of redux is that the entire state of the application is represented in a single JavaScript object called a store, or application store, that can be acted upon using special functions called reducers. Equally important is that state is immutable and reducers are the only part of the application that can change them. As you can see in the graphic above, the store is the center of the appliation universe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000161","sortNo":9,"contentFormatId":"1","contentTxt":"The consolidation and immutability of state makes understanding and predicting how an application will behave exponentially easier.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000162","sortNo":10,"contentFormatId":"1","contentTxt":"Events Flow Up","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000163","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000164","sortNo":12,"contentFormatId":"1","contentTxt":"In redux, user events are captured and emitted up to a reducer for processing. In Angular 1.x, it was a very common anti-pattern to see bloated controllers with large chunks of logic dedicated to manage local state. By moving logic that can directly manipulate state to reducers, the burden placed upon our components become negligible. In Angular 2, you will often see dumb controllers who do nothing more than capture an event and emit it via output to its parent controller.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000165","sortNo":13,"contentFormatId":"1","contentTxt":"In the graphic above, you will see two events flows. One is an event being emitted from a child component to its parent component and then onto the reducer. The second flow is an event being emitted to a service to perform an asynchronous operation and then the result of that being emitted into the reducer. All roads lead to the reducer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000166","sortNo":14,"contentFormatId":"1","contentTxt":"State Flows Down","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000167","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000168","sortNo":16,"contentFormatId":"1","contentTxt":"While events flow up, state flows down from the parent component to its children components. Angular 2 makes this really easy by declaring input on a child component for the parent component to pass state to it. This has some serious implications in terms of change detection which we will get into in a bit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000169","sortNo":17,"contentFormatId":"1","contentTxt":"@ngrx/store","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000170","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000171","sortNo":19,"contentFormatId":"1","contentTxt":"The icing on the cake is that state moving through an Angular 2 application is exponentially easier with the introduction of observables and the async pipe. My buddy Rob Wormald created an awesome Redux implementation using RxJS called @ngrx/store. This gives us all the power of Redux combined with the power of observables which makes for a very, very powerful stack.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000172","sortNo":20,"contentFormatId":"1","contentTxt":"The Sample Application","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000173","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000174","sortNo":22,"contentFormatId":"1","contentTxt":"We are going to be building out a simple master-detail REST application that lists a collection of items and then we can select an item and edit it or create a new item. To illustrate how @ngrx/store works with asynchronous operations, we are going to use json-server to provide use a REST API for use to consume with the Angular 2 http service. If you want to see a simplified version of the application, you can check out the simple-data-flow branch to skip the HTTP calls.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000175","sortNo":23,"contentFormatId":"1","contentTxt":"Laying the Foundation","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000176","sortNo":24,"contentFormatId":"1","contentTxt":"We are going to cover a lot of ground over the course of this lesson, and so we will do our best to take baby steps along the way. There is always the initial phase of a new concept where you have to lay some groundwork before you can start to expound on specific components. In this section, we are going to build out just enough Angular to give us the space to start talking about redux and ngrx in the context of a working application. Don’t get too hung up on the particulars just yet as we will revisit everything more than once to fortify the ideas we are covering.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000177","sortNo":25,"contentFormatId":"1","contentTxt":"Reducers Take One","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000178","sortNo":26,"contentFormatId":"1","contentTxt":"To facilitate our master-detail interface, we need to manage an array of items as well as the currently selected item. We will use @ngrx/store to provide use with a store for us to well… store our state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000179","sortNo":27,"contentFormatId":"1","contentTxt":"To manage our application state, we need to kick things off by creating our items and selectedItem reducers. A traditional reducer is nothing more than a function that takes a state object and an action to perform. Our ngrx reducer is slightly different in that the second parameter is an object with the type of action to perform and the payload for that action. We can also set the default value for the state to ensure that everything initializes smoothly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000180","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000181","sortNo":29,"contentFormatId":"1","contentTxt":"We will build our reducers out to handle specific actions but for now, we are going to set the default state of the switch statement to just return state. The code snippet above and below are almost identical except that one is the items reducer and the other is the selectedItem reducer. Seeing them side by side makes it easier to identify the underlying pattern when creating reducers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000182","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000183","sortNo":31,"contentFormatId":"1","contentTxt":"Making an interface for the application store really helped me to understand how reducers fit into the application. In our AppStore interface, you can see that we are dealing with a single object that has an items collection and a selectedItem property which holds a single Item object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000184","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000185","sortNo":33,"contentFormatId":"1","contentTxt":"If we needed to add additional functionality, the store would just expand with new key value pairs to accommodate the updated model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000186","sortNo":34,"contentFormatId":"1","contentTxt":"Inject the Store","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000187","sortNo":35,"contentFormatId":"1","contentTxt":"Now that our reducers have been defined, we need to make them available by adding them to our application store and then injecting that into our application. The first step is to import items, selectedItem and provideStore into our application. The provideStore is appropriately named in that it provides us with an application store to use for the life-cycle of the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000188","sortNo":36,"contentFormatId":"1","contentTxt":"We initialize our store by calling provideStore and passing in an object that contains our items and selectedItem reducers. Notice that we are passing in an object that matches our AppStore interface.\nWe then make the store available to our entire application by defining it as an application dependency when we call bootstrap to initialize our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000189","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000190","sortNo":38,"contentFormatId":"1","contentTxt":"You may have noticed that we are also importing and injecting ItemsService; we will define it next as it will be the primary consumer of our newly minted store.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000191","sortNo":39,"contentFormatId":"1","contentTxt":"Create the Items Service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000192","sortNo":40,"contentFormatId":"1","contentTxt":"The first and simplest iteration of our ItemsService will expose the items collection by pulling it from the store. Notice that we have typed our items collection as an Observable that contains an Array of Item objects. The benefits of having our array wrapped in an observable will become clearer once we start to consume the collection in our components. We are also injecting our store into our constructor and typing it to the AppStore interface that we declared earlier.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000193","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000194","sortNo":42,"contentFormatId":"1","contentTxt":"Because we are basically dealing with a key-value store, we can set this.items by calling store.select(items’). The select method returns an observable with our collection in it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000195","sortNo":43,"contentFormatId":"1","contentTxt":"Important! The reason that I have created a service to pull the items collection from the store is because we are going to introduce asynchronous operations when we start to wire everything up to talk to our remote API. This abstraction allows us to accommodate some potentially complex async operations before handing everything off to the reducer for processing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000196","sortNo":44,"contentFormatId":"1","contentTxt":"Consume the Items","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000197","sortNo":45,"contentFormatId":"1","contentTxt":"Now that we have created the ItemsService that has an items collection available, we will consume it in our App component. Just like in the ItemsService, we will declare our items collection as items: Observable<Array<Item>>. While we are at it, we will also define our selectedItem as an observable that contains a single Item object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000198","sortNo":46,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000199","sortNo":47,"contentFormatId":"1","contentTxt":"To set this.items, we will assign it the items collection from the ItemsService and to set this.selectedItem, we will fetch it directly from our store by calling store.select(‘selectedItem’). If you recall, I created the ItemsService to abstract our asynchronous operations when dealing with the items collection. Managing selectedItem is completely synchronous in nature and so I could not justify creating a SelectedItemService for it. This is why I am using ItemsService when dealing with items but deal with the store directly when getting selectedItem state. You could create a service to handle this for the sake of symmetry and that would be completely justified.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000200","sortNo":48,"contentFormatId":"1","contentTxt":"Display the Items","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000201","sortNo":49,"contentFormatId":"1","contentTxt":"Angular 2 is designed for the creation and composition of small specific components. Our application has two sub-components called ItemsList and ItemDetail which are responsible for listing all items and displaying the details of the selected item, respectively.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000202","sortNo":50,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000203","sortNo":51,"contentFormatId":"1","contentTxt":"In the my-app template, we are initializing the items-list component with a property binding to items that is bound to our local items collection. This is similar to isolated scope in Angular 1.x in that we are creating a defined input on the child component with [items] and then binding it to the value of whatever the items collection happens to be on the parent component. Because we are dealing with observables, we can bypass a lot of boilerplate by using the async pipe to pass the updated values directly to our inputs without having to extract them. By “boilerplate”, I am referring to a common Angular 1.x scenario where we could call a service in our controller and when the promise resolved, we would take the results and assign it to a property we were binding to. In Angular 2, we skip this step entirely by allowing the pipe to assign the asynchronous to our template for us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000204","sortNo":52,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000205","sortNo":53,"contentFormatId":"1","contentTxt":"We will follow the same pattern for the selectedItem by passing it to the item-detail component as item. We have now laid the foundation for our application, and now the stage is set for us to dig into the three main features of data flow in a redux application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000206","sortNo":54,"contentFormatId":"1","contentTxt":"Centralized State","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000207","sortNo":55,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000208","sortNo":56,"contentFormatId":"1","contentTxt":"To reiterate, the single most important concept within redux is that the entire state of your application is centralized into a single JavaScript object tree. This is, in my opinion, the largest shift from how we used to write Angular applications to where we are now. We manage our application state through a reducer function which takes the original state and an action, performs a unit of logic based on the particular action and returns a new state object. We will build out our children components to display items and selectedItem and keep an eye out for the fact that they are being populated by this master, single state tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000209","sortNo":57,"contentFormatId":"1","contentTxt":"Our reducers are the only thing that can modify application state and so we will start out with the selectedItem reducer since it is by far the simplest of the two we have in our application. When an event is dispatched from the store with an action type of SELECT_ITEM, it will hit the first condition in the switch statement and return the payload as the new state. In plain English, we are telling our reducer to “take this new item and assign it as the currently selected item.” Also, actions are customarily strings that are all in caps and often times defined as application constants.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000210","sortNo":58,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000211","sortNo":59,"contentFormatId":"1","contentTxt":"Because our object state tree is read-only, our response for every action must return a new state object without mutating the previous state object. Enforcing immutability in our reducers is critical when implementing redux and so will step through each action below and discuss how we can accomplish this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000212","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000213","sortNo":61,"contentFormatId":"1","contentTxt":"ADD_ITEMS: returns whatever collection we send in as the new array.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000214","sortNo":62,"contentFormatId":"1","contentTxt":"CREATE_ITEM: returns a new array by concatenating the existing items array with our new item.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000215","sortNo":63,"contentFormatId":"1","contentTxt":"UPDATE_ITEM: returns a new array by mapping through the current array, finding the item we want to update and cloning a new object using Object.assign.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000216","sortNo":64,"contentFormatId":"1","contentTxt":"DELETE_ITEM: returns a new array by filtering out the item that we want to delete.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000217","sortNo":65,"contentFormatId":"1","contentTxt":"By centralizing our state into a single state tree and then grouping the code that operates on our tree into reducers makes our application so much easier to reason about. Another benefit is that by having our logic segmented into pure units within our reducer, this makes testing our application very easy.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000218","sortNo":66,"contentFormatId":"1","contentTxt":"State Down Interlude","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000219","sortNo":67,"contentFormatId":"1","contentTxt":"Just to give a preview of how this data flow is connected, let us take a look at our ItemsService and see how we can initiate an action on our items reducer. We will eventually replace the loadItems method with an HTTP call but for now, we will just assume that we are hard coding some sample items and assigning it to the initialItems array. To execute an action, we will call this.store.dispatch and pass in our actions object with a type of ADD_ITEMS and a payload of initialItems.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000220","sortNo":68,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000221","sortNo":69,"contentFormatId":"1","contentTxt":"The interesting thing is that every time we dispatch the ADD_ITEMS event, our local items collection is automatically updated because it is being via an observable. Because we are consuming items in our App component, it is automatically updated there as well. And if we were (and we are) passing that collection to the ItemsList component, it would automatically update at the subcomponent level as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000222","sortNo":70,"contentFormatId":"1","contentTxt":"Redux is a great pattern for centralizing state management with immutable data structures. Add in observables and you now have an ultra-convenient way to move that state down through the application by binding directly to the stream of values provided by the observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000223","sortNo":71,"contentFormatId":"1","contentTxt":"State Down","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000224","sortNo":72,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000225","sortNo":73,"contentFormatId":"1","contentTxt":"Another cornerstone of redux is that state always flows down. To illustrate this point, we will start with the App component and follow our items and selectedItem data down to the child components. We are populating items from the ItemsService (because it will eventually be an asynchronous operation) and pulling in selectedItem directly from the store.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000226","sortNo":74,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000227","sortNo":75,"contentFormatId":"1","contentTxt":"This is the only place in the entire application where those two properties are set. We will learn in a moment how to do some sleight of hand when we get to the ItemDetails component to localize state mutation but we never directly manipulate these values again. Conceptually, this is a huge shift from how we have approached Angular applications, and the implications are huge. We no longer need change detection if we are not directly mutating data within our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000228","sortNo":76,"contentFormatId":"1","contentTxt":"The App component takes items and selectedItem and hands them off via property bindings to its child components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000229","sortNo":77,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000230","sortNo":78,"contentFormatId":"1","contentTxt":"In our ItemsList component, we pick up the items collection by annotating our local items property with @Input().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000231","sortNo":79,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000232","sortNo":80,"contentFormatId":"1","contentTxt":"And in the HTML template, we display it in the view using ngFor to loop over items and create a template for each one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000233","sortNo":81,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000234","sortNo":82,"contentFormatId":"1","contentTxt":"The pattern is slightly more complicated in our ItemDetail component because we need to allow a user to create a new item or edit an existing item. You are going to ask the same question I did as I was learning redux. How can you edit an existing item without mutating it? Behold the sleight of hand! We will create a local copy of our item to work with so that we are not directly mutating our selected item. This has the added benefit of allowing us to cancel the operation without any side-effects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000235","sortNo":83,"contentFormatId":"1","contentTxt":"To accomplish this, we will modify our annotation slightly to assign our item input to a locally scoped _item property using @Input(‘item’) _item: Item;. We can then leverage the power of ES6 and create a setter for _item and perform addtional logic everytime the object is updated. In our case, we are going to create a copy of _item using Object.assign and assign it to this.selectedItem which we will use to bind our form to. We are also going to create a property and store the name of the original item so that user is aware of what item they are currently working with. This is strictly motivated by the user experience but these little things make a big difference.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000236","sortNo":84,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000237","sortNo":85,"contentFormatId":"1","contentTxt":"In our template, we are toggling the title that we show the user based on whether or not we are dealing with an existing component or new component by using ngIf to detect if selectedItem.id exists. We then have two inputs bound to selectedItem.name and selectedItem.description using ngModel and the two-way binding syntax.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000238","sortNo":86,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000239","sortNo":87,"contentFormatId":"1","contentTxt":"And that is it! This has essentially been an exercise in taking data and passing it to the children components to display.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000240","sortNo":88,"contentFormatId":"1","contentTxt":"Events Up","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000241","sortNo":89,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000242","sortNo":90,"contentFormatId":"1","contentTxt":"The flip side to the “state down” maxim is that events always flow up. User interactions will trigger events that ultimately make its way to a reducer to be handled. The interesting thing about this approach is that your components suddenly become very lightweight and in most cases “dumb” in the sense that they perform zero logic. We could technically dispatch a reducer event within our children components but instead we are delegating that to the parent component to minimize dependencies in our components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000243","sortNo":91,"contentFormatId":"1","contentTxt":"Let’s check out the ItemsList component without the template to see what I mean by this. We have a single input for our items array and then we have two event outputs we are emitting when an item is selected or deleted. That is the entire sum of the ItemsList class.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000244","sortNo":92,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000245","sortNo":93,"contentFormatId":"1","contentTxt":"In our template, we are calling selected.emit(item) when an item is clicked and calling deleted.emit(item) when the delete button is clicked. We are also calling $event.stopPropagation() when the delete button is clicked so that it doesn’t trigger the selected event handler.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000246","sortNo":94,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000247","sortNo":95,"contentFormatId":"1","contentTxt":"By defining selected and deleted as component outputs, we can capture them in our parent component in the same way that we capture native DOM events like click. We see this in the code below as (selected)=”selectItem($event)” and (deleted)=”deleteItem($event)”. The $event parameter does not contain mouse information but rather the data that was sent with the event.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000248","sortNo":96,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000249","sortNo":97,"contentFormatId":"1","contentTxt":"When those events are emitted, we then capture them and handle them in our parent component. In the case of selecting an item, we are going to dispatch a new event with the action type of SELECT_ITEM and set the payload to the item selected. When an item is deleted, we will just delegate that to the ItemsService to be handled.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000250","sortNo":98,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000251","sortNo":99,"contentFormatId":"1","contentTxt":"For now, we are just going to dispatch a new event on store within our service to pass the DELETE_ITEM action to the reducer with our deleted item in tow. We will replace this with HTTP calls in a moment.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000252","sortNo":100,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000253","sortNo":101,"contentFormatId":"1","contentTxt":"To reinforce what we have just learned, we will go through the ItemDetails component and follow the event flow up. We want to allow the user to save an item or cancel the operation and so we will define two outputs called saved and cancelled.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000254","sortNo":102,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000255","sortNo":103,"contentFormatId":"1","contentTxt":"In the bottom of our form, we have a cancel button that calls cancelled.emit(selectedItem) on click and a save button that calls (click)=”saved.emit(selectedItem).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000256","sortNo":104,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000257","sortNo":105,"contentFormatId":"1","contentTxt":"In our main component, we then bind to the saved and cancelled outputs to call the event handlers in our class.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000258","sortNo":106,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000259","sortNo":107,"contentFormatId":"1","contentTxt":"When a user clicks the cancel button, we create an empty item and emit a SELECT_ITEM action. When an item is saved, we call saveItem on ItemsService and then reset the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000260","sortNo":108,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000261","sortNo":109,"contentFormatId":"1","contentTxt":"Originally, I wrestled with having a form for creating an item and then a separate form for editing an item. This seemed a bit heavy and so I opted to share the same form since both exist to save an item. I then approximate upsert functionality in the itemSave method by detecting the presence of item.id and calling either createItem or updateItem. Both methods take the item we send and dispatch it with the proper event. By now, I hope that the pattern of how we deliver objects to a reducer for processing is starting to emerge.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000262","sortNo":110,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000263","sortNo":111,"contentFormatId":"1","contentTxt":"We have just completed the “state down, events up” circuit but our example still lives in a vacuum. How hard would it be to modify our application to communicate with a real server? The answer is “not hard at all!”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000264","sortNo":112,"contentFormatId":"1","contentTxt":"Calling All Servers","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000265","sortNo":113,"contentFormatId":"1","contentTxt":"First, a bit of setup to prepare our application to make HTTP calls. We will import Http and Headers from angular2/http.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000266","sortNo":114,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000267","sortNo":115,"contentFormatId":"1","contentTxt":"We will then define a BASE_URL constant so we only have to type it once and we will also create a HEADER constant to tell our server how we are communicating with it. This may not be necessary depending on what backend you are using but to get json-server working, I had to add it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000268","sortNo":116,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000269","sortNo":117,"contentFormatId":"1","contentTxt":"We will modify our ItemsService constructor to include Http and assign it to a private local instance called http.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000270","sortNo":118,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000271","sortNo":119,"contentFormatId":"1","contentTxt":"From here, let us modify our CRUD methods to handle remote server calls, starting with loadItems. We are calling this.http.get(BASE_URL) to get our remote items and because Http returns an observable, we can pipe our results through additional operators. We will call map to parse our results and then call map again to create the object we want to dispatch to our reducer. The combinations of map method calls is an observable sequence in that every result gets passed through those sequence of operations. To “tie off” a sequence, we will subscribe to it and then hand off control to our reducer by dispatching our transformed results.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000272","sortNo":120,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000273","sortNo":121,"contentFormatId":"1","contentTxt":"We will follow a similar pattern when we update createItem. The only difference is that we are calling http.post with a formatted item as the payload and our HEADER constant. Once we have our results, we map everything to an object that we can dispatch in our subscribe method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000274","sortNo":122,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000275","sortNo":123,"contentFormatId":"1","contentTxt":"Updating and deleting are a bit simpler in that we are not dependent on an object being returned from the server. We only care that the operation was successful. Because of that, we will use the http.put and http.delete and skip mapping the response entirely. We can dispatch an action to our reducer from the subscribe block as you can see below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000276","sortNo":124,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000277","sortNo":125,"contentFormatId":"1","contentTxt":"BONUS: Testing","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000278","sortNo":126,"contentFormatId":"1","contentTxt":"One of the most important aspects of redux is that it is very easy to test reducers because they are pure functions with a clear contract. In regards to our application, the surface area that contains testable logic has been vastly reduced. I wasn’t trying to be funny when I wrote that but in hindsight, it kind of is!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000279","sortNo":127,"contentFormatId":"1","contentTxt":"Setting Up","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000280","sortNo":128,"contentFormatId":"1","contentTxt":"I am not going to get into the entire testing harness but let’s a take a quick tour of our test spec. The first thing we need to do is to import items and selectedItems as well as it, describe and expect from angular2/testing. Wait a second! Aren’t those Jasmine methods!? Yes they are and Angular 2 now uses Jasmine by default.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000281","sortNo":129,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000282","sortNo":130,"contentFormatId":"1","contentTxt":"For reference, the skeleton of our spec looks like this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000283","sortNo":131,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000284","sortNo":132,"contentFormatId":"1","contentTxt":"The tests were really easy to write because we start with an initial state and when we send an action to our reducer, we know exactly what we should get back. We know that if we dispatch an action of ADD_ITEMS, we will get back whatever we put in the payload, which we see in the assertion below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000285","sortNo":133,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000286","sortNo":134,"contentFormatId":"1","contentTxt":"If we call the items reducer with an action type of CREATE_ITEM, we would expect that the result would be the initial array plus the new item.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000287","sortNo":135,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000288","sortNo":136,"contentFormatId":"1","contentTxt":"We can easily articulate the expected result for the remaining two reducer’s methods and then write assertions for them as I have below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000289","sortNo":137,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000290","sortNo":138,"contentFormatId":"1","contentTxt":"Review","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000291","sortNo":139,"contentFormatId":"1","contentTxt":"We have covered a lot of ground in this lesson and #higFive if you have made it this far! Let’s do a quick recap of what we did while it is fresh in our minds.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000292","sortNo":140,"contentFormatId":"1","contentTxt":"1. The primary characteristics of redux is that state is centralized, events flow up and state flows down.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000293","sortNo":141,"contentFormatId":"1","contentTxt":"2. The @ngrx/store implementation uses observables allows us to populate our templates using the async pipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000294","sortNo":142,"contentFormatId":"1","contentTxt":"3. We created our reducers which are simple functions that take an action and state object and returns a new state object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000295","sortNo":143,"contentFormatId":"1","contentTxt":"4. Our reducer functions must be pure and so we saw how we could create them without mutating our collections.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000296","sortNo":144,"contentFormatId":"1","contentTxt":"5. A store is basically a key value value map with some mechanisms to handle events and emit state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000297","sortNo":145,"contentFormatId":"1","contentTxt":"6. We broadcast our events using store.emit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000298","sortNo":146,"contentFormatId":"1","contentTxt":"7. We subscribe to data using store.select.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000299","sortNo":147,"contentFormatId":"1","contentTxt":"8. Create a local copy when working with a form to avoid higher level mutations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000300","sortNo":148,"contentFormatId":"1","contentTxt":"9. With asynchronous calls, we pass our results through an observable sequence and then emit the event to the reducer on completion.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000301","sortNo":149,"contentFormatId":"1","contentTxt":"10. Reducers are really easy to test because the methods are pure and the contract is crystal clear.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000302","sortNo":150,"contentFormatId":"1","contentTxt":"Learning redux via @ngrx/store has been the closest thing to that “new programmer” feeling that I have felt in awhile. It is been so much fun! Take the example and play around with it and think about how you can use this approach in your day to day projects. If you create something awesome then by all means, share it in the comments for everyone to check out!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000303","sortNo":151,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604080000000304","sortNo":152,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/simpulton/ngrx-rest-app\">https://github.com/simpulton/ngrx-rest-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201701220000000044","sortNo":1,"contentFormatId":"1","contentTxt":"When your form start to grow, you can end up with something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000045","sortNo":2,"contentFormatId":"1","contentTxt":"If you are coding all your forms like that, you are probably Psychopath  (just kidding)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000046","sortNo":3,"contentFormatId":"1","contentTxt":"The template is verbose; it’s hard to understand what’s going on and you are not DRY.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000047","sortNo":4,"contentFormatId":"1","contentTxt":"What if we could write something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000048","sortNo":5,"contentFormatId":"1","contentTxt":"I think that looks a lot better ( later you will see how we can be even cleaner than that ). So let’s create the control-errors component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000049","sortNo":6,"contentFormatId":"1","contentTxt":"We need two Inputs:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000050","sortNo":7,"contentFormatId":"1","contentTxt":"1. The control name.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000051","sortNo":8,"contentFormatId":"1","contentTxt":"2. The errors Object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000052","sortNo":9,"contentFormatId":"1","contentTxt":"Next, we can ask Angular to give us the ngForm instance in our component via dependency injection with the Host decorator. ( we are using also the Optional decorator to protect our code )","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000053","sortNo":10,"contentFormatId":"1","contentTxt":"That’s the equivalent of doing this in our template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000054","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000055","sortNo":12,"contentFormatId":"1","contentTxt":"If you are still confused from where this NgForm is coming, In a nutshell, it’s just a built-in directive with a selector that points to almost any form tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000056","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000057","sortNo":14,"contentFormatId":"1","contentTxt":"Ok, now we have the form instance let’s get the errors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000058","sortNo":15,"contentFormatId":"1","contentTxt":"Our getter functionality is straight forward:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000059","sortNo":16,"contentFormatId":"1","contentTxt":"1. Find the current control in our form instance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000060","sortNo":17,"contentFormatId":"1","contentTxt":"2. Loop over the Input errors keys.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000061","sortNo":18,"contentFormatId":"1","contentTxt":"3. Check with the hasError() method if we have an error with the same key.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000062","sortNo":19,"contentFormatId":"1","contentTxt":"4. Show the error.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000063","sortNo":20,"contentFormatId":"1","contentTxt":"If you are happy with this implementation, you are done here. I’m still not happy. I think we can make it even cleaner, maybe something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000064","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000065","sortNo":22,"contentFormatId":"1","contentTxt":"I’m not going to implement this fully, but I can give you a hint.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000066","sortNo":23,"contentFormatId":"1","contentTxt":"First, we need to centralize our errors object, so let’s do that with DI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000067","sortNo":24,"contentFormatId":"1","contentTxt":"Now we can inject the CONTROL_ERRORS object and implement more complex logic. It will take more time, but the benefits are obvious.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000068","sortNo":25,"contentFormatId":"1","contentTxt":"Currently, the control-errors directive works only with template driven forms. You need to add just a little bit of code to make it also work with reactive forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000069","sortNo":26,"contentFormatId":"1","contentTxt":"ControlErrors","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000070","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000071","sortNo":28,"contentFormatId":"1","contentTxt":"App","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000072","sortNo":29,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201611030000000084","sortNo":1,"contentFormatId":"1","contentTxt":"Validation in Angular 2, various approaches, various APIs to use. We’re going to use AbstractControl to learn how to validate a particular FormGroup. I covered FormGroup, FormControl and FormBuilder in my previous reactives form fundamentals article - which I’d recommend checking out before this one if you’re new to Angular 2 forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000085","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>What is a FormGroup?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000086","sortNo":3,"contentFormatId":"1","contentTxt":"Covered in the previous article, but we’ll whip up a quick sample real quick to use for the rest of this post:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000087","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000088","sortNo":5,"contentFormatId":"1","contentTxt":"If the above makes no sense, go here then drop back! When our FormBuilder, i.e. the fb injected FormBuilder instantiates new groups through this.fb.group(), each of those is technically a new FormGroup(). So when we refer to “FormGroups”, this is what we’re talking about from here on out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000089","sortNo":6,"contentFormatId":"1","contentTxt":"<strong>FormBuilder/FormGroup source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000090","sortNo":7,"contentFormatId":"1","contentTxt":"Before we can learn “how to do custom validation”, we must dive into the workings of the APIs first to see what’s happening and actually have some idea what’s going on, so let’s do that real quick. Here’s the syntax for the FormBuilder class:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000091","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000092","sortNo":9,"contentFormatId":"1","contentTxt":"First, let’s look at this line:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000093","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000094","sortNo":11,"contentFormatId":"1","contentTxt":"This means we can pass a controlsConfig Object down into the FormBuilder. This is what happens when we call this.fb.group(). We also have an optional extra? property, and finally : FormGroup, which is the return value. So essentially, FormBuilder is just an abstraction/wrapper at this point.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000095","sortNo":12,"contentFormatId":"1","contentTxt":"So, what do the internals look like?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000096","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000097","sortNo":14,"contentFormatId":"1","contentTxt":"The first line of code we completely know already, it’s just the syntax from above. Now, what is this extra argument that’s being passed in? Here’s where it’s used:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000098","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000099","sortNo":16,"contentFormatId":"1","contentTxt":"Interesting, it checks the presence of the extra “thing”, and providing it’s there and is in fact an Object, it’ll grab the validator property from it. Which means that the extra thing which is the optional second function argument, in fact looks like this when creating a group() with FormBuilder:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000100","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000101","sortNo":18,"contentFormatId":"1","contentTxt":"Which is equivalent to:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000102","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000103","sortNo":20,"contentFormatId":"1","contentTxt":"We can pass a second argument (or third, for asyncValidator) that gets passed to new FormGroup() instance. One more thing before we implement validation, we’ll see how FormGroup handles this internally:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000104","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000105","sortNo":22,"contentFormatId":"1","contentTxt":"FormGroup actually extends AbstractControl and then passes validator and asyncValidator to the AbstractControl through the super() call, which calls the constructor of the parent abstract class.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000106","sortNo":23,"contentFormatId":"1","contentTxt":"We won’t dive into the specifics of AbstractControl, but we know that it’s essentially the mothership of our form that sets, controls, and powers all things such as dirty, pristine, touched and other funky abstract methods we can touch when we ask the AbstractControl.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000107","sortNo":24,"contentFormatId":"1","contentTxt":"<strong>AbstractControl</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000108","sortNo":25,"contentFormatId":"1","contentTxt":"This next section will give you an insight on AbstractControl, however using AbstractControl is not essential in this case to implementing our custom FormGroup validation, as we can also inject FormGroup to talk to our form controls also - but this means the “control” that’s injected needs to be a FormGroup instance, so we can use AbstractControl instead for consistency.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000109","sortNo":26,"contentFormatId":"1","contentTxt":"Let’s circle back around and take a look at our original piece of code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000110","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000111","sortNo":28,"contentFormatId":"1","contentTxt":"What we’re going to add is a custom validator that ensures when our lovely fake users sign up to our fake form, that their email and confirm email fields both match up. Using AbstractControl we can do this, but first, we need to actually compose the validation function:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000112","sortNo":29,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000113","sortNo":30,"contentFormatId":"1","contentTxt":"We’ll add this inside email-matcher.ts for the sake of breaking code up into different files. This will allow us to then inject it into our emailMatcher validator into our FormGroup or FormBuilder wrapper.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000114","sortNo":31,"contentFormatId":"1","contentTxt":"Next step, we’ll inject AbstractControl:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000115","sortNo":32,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000116","sortNo":33,"contentFormatId":"1","contentTxt":"So, we know now that AbstractControl is the mothership of our form that other form controls simply extend/inherit from, which means we can actually talk to any form control in the group. If you recall from the previous article, we can fetch information about our form controls via .get(<control>) to implement client-side validation errors, for example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000117","sortNo":34,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000118","sortNo":35,"contentFormatId":"1","contentTxt":"Incidentally, we can also use this same API when implementing custom validators, so referencing our previous form group code, in which we have nested FormGroup props email and confirm, let’s go grab them:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000119","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000120","sortNo":37,"contentFormatId":"1","contentTxt":"At this point, control is FormGroup. Our email and confirm are both FormControl, if we logged them out in the console we’d see this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000121","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000122","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>Custom validation properties</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000123","sortNo":40,"contentFormatId":"1","contentTxt":"Now we’re ready to do some fun stuff! All we actually want to do is compare that both the email and confirm fields have the same value, which will in turn display errors if they are invalid. Let’s check the .value property (the actual FormControl value, i.e. the <input>) and if they match we’ll return null (which internally sets the validation state for the entire group, and entire form where applicable):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000124","sortNo":41,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000125","sortNo":42,"contentFormatId":"1","contentTxt":"So until now, this means that if everything is working perfectly, we’ll return no errors. Now we need to add that custom validation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000126","sortNo":43,"contentFormatId":"1","contentTxt":"<strong>Custom validation Object hook</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000127","sortNo":44,"contentFormatId":"1","contentTxt":"What we want to implement is the validation that matches this HTML:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000128","sortNo":45,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000129","sortNo":46,"contentFormatId":"1","contentTxt":"Ignoring the HTML, we’re interested specifically in this piece:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000130","sortNo":47,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000131","sortNo":48,"contentFormatId":"1","contentTxt":"This means that we want to be able to query the account level FormGroup, and check if it has an error called “nomatch”. To implement this we require a custom Object to be returned from our validator should the values not match:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000132","sortNo":49,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000133","sortNo":50,"contentFormatId":"1","contentTxt":"We can condense this nicely onto a one line ternary, final code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000134","sortNo":51,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000135","sortNo":52,"contentFormatId":"1","contentTxt":"Now, we import our validator, and add it to the second argument of the account level FormGroup:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000136","sortNo":53,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611030000000137","sortNo":54,"contentFormatId":"1","contentTxt":"Note: Angular 2 doesn’t have built-in type=email validation anymore, however you’ve just learned how to implement your own with AbstractControl, swap it out for FormControl when validating on a single FormControl :)","contentBinary":"","contentPoster":"","contentUrl":null}]
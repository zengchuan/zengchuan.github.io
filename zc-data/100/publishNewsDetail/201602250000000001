[{"id":"201602250000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In Understanding Zones, we explored the power of Zones by building a profiling zone that profiles asynchronous operations in our code. We learned that Zones are a sort of execution context that allows us to hook into our asynchronous tasks. If you haven’t read that article, we highly recommend checking it out as this one is based on it. In this article we’re going to take a closer look at what role Zones play in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Zones are a perfect fit for Angular","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000003","sortNo":3,"contentFormatId":"1","contentTxt":"It turns out that, the problem that Zones solve, plays very nicely with what Angular needs in order to perform change detection in our applications. Did you ever ask yourself when and why Angular performs change detection? What is it that tells Angular “Dude, a change probably occurred in my application. Can you please check?”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Before we dive into these questions, let’s first think about what actually causes this change in our applications. Or rather, what can change state in our applications. Application state change is caused by three things:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000005","sortNo":5,"contentFormatId":"1","contentTxt":"1. Events - User events like click, change, input, submit, …","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000006","sortNo":6,"contentFormatId":"1","contentTxt":"2. XMLHttpRequests - E.g. when fetching data from a remote service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000007","sortNo":7,"contentFormatId":"1","contentTxt":"3. Timers - setTimeout(), setInterval(), because JavaScript","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000008","sortNo":8,"contentFormatId":"1","contentTxt":"It turns out that these three things have something in common. Can you name it? … Correct! They are all asynchronous.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Why do you think is this important? Well … because it turns out that these are the only cases when Angular is actually interested in updating the view. Let’s say we have an Angular 2 component that executes a handler when a button is clicked:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000010","sortNo":10,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000011","sortNo":11,"contentFormatId":"1","contentTxt":"If you’re not familiar with the (click) syntax, you might want to read our article on Angular 2’s Template Syntax Demystified. The short version is, that this sets up an event handler for the click event on the <button> element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000027","sortNo":12,"contentFormatId":"1","contentTxt":"When the component’s button is clicked, changeName() is executed, which in turn will change the name property of the component. Since we want this change to be reflected in the DOM as well, Angular is going to update the view binding {{name}} accordingly. Nice, that seems to magically work.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000028","sortNo":13,"contentFormatId":"1","contentTxt":"Another example would be to update the name property using setTimeout(). Note that we removed the button.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000029","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000030","sortNo":15,"contentFormatId":"1","contentTxt":"If you’ve read our article on understanding Zones, you know that this works obviously because Angular takes advantage of Zones. Zones monkey-patches global asynchronous operations such as setTimeout() and addEventListener(), which is why Angular can easily find out, when to update the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000031","sortNo":16,"contentFormatId":"1","contentTxt":"In fact, the code that tells Angular to perform change detection whenever the VM turn is done, is as simple as this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000032","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000033","sortNo":18,"contentFormatId":"1","contentTxt":"Whenever Angular’s zone emits an onTurnDone event, it runs a task that performs change detection for the entire application. If you’re interested in how change detection in Angular 2 works, watch out, we’re going to publish another article on that soon.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000034","sortNo":19,"contentFormatId":"1","contentTxt":"But wait, where does the onTurnDone event emitter come from? This is not part of the default Zone API, right? It turns out that Angular introduces its own zone called NgZone.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000035","sortNo":20,"contentFormatId":"1","contentTxt":"NgZone in Angular 2","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000036","sortNo":21,"contentFormatId":"1","contentTxt":"NgZone is basically a forked zone that extends its API and adds some additional functionality to its execution context. One of the things it adds to the API is the following set of custom events we can subscribe to, as they are observable streams:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000037","sortNo":22,"contentFormatId":"1","contentTxt":"1. onTurnStart() - Notifies subscribers just before Angular’s event turn starts. Emits an event once per browser task that is handled by Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000038","sortNo":23,"contentFormatId":"1","contentTxt":"2. onTurnDone() - Notifies subscribers immediately after Angular’s zone is done processing the current turn and any micro tasks scheduled from that turn.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000039","sortNo":24,"contentFormatId":"1","contentTxt":"3. onEventDone() - Notifies subscribers immediately after the final onTurnDone() callback before ending VM event. Useful for testing to validate application state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000040","sortNo":25,"contentFormatId":"1","contentTxt":"If “Observables” and “Streams” are super new to you, you might want to read our article on Taking advantage of Observables in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000041","sortNo":26,"contentFormatId":"1","contentTxt":"The main reason Angular adds its own event emitters instead of relying on beforeTask and afterTask callbacks, is that it has to keep track of timers and other micro tasks. It’s also nice that Observables are used as an API to handle these events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000042","sortNo":27,"contentFormatId":"1","contentTxt":"Running code outside Angular’s zone","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000043","sortNo":28,"contentFormatId":"1","contentTxt":"Since NgZone is really just a fork of the global zone, Angular has full control over when to run something inside its zone to perform change detection and when not. Why is that useful? Well, it turns out that we don’t always want Angular to magically perform change detection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000044","sortNo":29,"contentFormatId":"1","contentTxt":"As mentioned a couple of times, Zones monkey-patches pretty much any global asynchronous operations by the browser. And since NgZone is just a fork of that zone which notifies the framework to perform change detection when an asynchronous operation has happened, it would also trigger change detection when things like mousemove events fire.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000045","sortNo":30,"contentFormatId":"1","contentTxt":"We probably don’t want to perform change detection every time mousemove is fired as it would slow down our application and results in very bad user experience.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000046","sortNo":31,"contentFormatId":"1","contentTxt":"That’s why NgZone comes with an API runOutsideAngular() which performs a given task in NgZone’s parent zone, which does not emit an onTurnDone event, hence no change detection is performed. To demonstrate this useful feature, let’s take look at the following code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000047","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000048","sortNo":33,"contentFormatId":"1","contentTxt":"Nothing special going on here. We have component that calls processWithinAngularZone() when the button in the template is clicked. However, that method calls increaseProgress(). Let’s take a closer look at this one:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000049","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000050","sortNo":35,"contentFormatId":"1","contentTxt":"increaseProgress() calls itself every 10 milliseconds until progress equals 100. Once it’s done, the given doneCallback will execute. Notice how we use setTimeout() to increase the progress.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000051","sortNo":36,"contentFormatId":"1","contentTxt":"Running this code in the browser, basically demonstrates what we already know. After each setTimeout() call, Angular performs change detection and updates the view, which allows us to see how progress is increased every 10 milliseconds. It gets more interesting when we run this code outside Angular’s zone. Let’s add a method that does exactly that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000052","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000053","sortNo":38,"contentFormatId":"1","contentTxt":"processOutsideAngularZone() also calls increaseProgress() but this time using runOutsideAngularZone() which causes Angular not to be notified after each timeout. We access Angular’s zone by injecting it into our component using the NgZone token.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000054","sortNo":39,"contentFormatId":"1","contentTxt":"The UI is not updated as progress increases. However, once increaseProgress() is done, we run another task inside Angular’s zone again using zone.run() which in turn causes Angular to perform change detection which will update the view. In other words, instead of seeing progress increasing, all we see is the final value once it’s done.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000055","sortNo":40,"contentFormatId":"1","contentTxt":"Zones have now also been proposed as a standard at TC39, maybe another reason to take a closer look at them.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201703220000000051","sortNo":1,"contentFormatId":"1","contentTxt":"A couple of months ago, I happened to see Will Boyd on Twitter mention that JavaScript-based Clipboard support was fairly strong in modern browsers. This piqued my interest because, here at InVision, for the longest time, we had to use a Flash movie (remember those) to power our \"copy to clipboard\" functionality. Now that JavaScript access to the Clipboard is well supported, I wanted to see how easy it would be to create a Copy-to-Clipboard directive in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000052","sortNo":2,"contentFormatId":"1","contentTxt":"In the Browser, access to the clipboard can be partially granted using the Document.execCommand(), which I have almost no experience with. I think I vaguely remember messing with it back in the day when Rich Text Editors in the browser where more popular. But, I haven't used it since. Regardless, you can copy text to the clipboard using:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000053","sortNo":3,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000054","sortNo":4,"contentFormatId":"1","contentTxt":"Notice that we're not passing any target text to the .execCommand() method. This is because the \"copy\" command copies the current Selection on the page - ie, the text you have highlighted. This could be static text within the Document Object Model (DOM); or, it could be text you have selected within an input field. This means that if we want to copy arbitrary text to the clipboard, we have to programmatically create a Selection on the page before we call the .execCommand() method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000055","sortNo":5,"contentFormatId":"1","contentTxt":"If you look around at the various \"copy to clipboard\" snippets, they all use the same approach. They either call .select() on an existing form input element; or, they inject a transient input element, populate it, call .select(), and then remove it from the DOM. Since I want to try to create a more general solution, I'm going with the latter approach.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000056","sortNo":6,"contentFormatId":"1","contentTxt":"First, I wanted to create a ClipboardService that would completely isolate the mechanism through which we accessed the system clipboard. This way, the rest of my Angular 2 application only ever has to interact with the ClipboardService interface and never directly with the DOM or the document.execCommand() method. And, I wanted to be able to return a Promise:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000057","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000058","sortNo":8,"contentFormatId":"1","contentTxt":"As you can see, when you call the .copy() method on the ClipboardService, we inject a transient Textarea element into the rendered document, render it off-screen, populate it, highlight it - creating an active Selection - call document.execCommand(), and then remove the Textarea element from the DOM. If this completes successfully, we resolve the promise with the given text.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000059","sortNo":9,"contentFormatId":"1","contentTxt":"Clearly, this service is tightly coupled to the Browser runtime; but, instead of just pulling the \"document\" out of the global context, I'm trying to be a good citizen by injecting the \"DOCUMENT\" dependency into the service. This way, should we ever feel the masochistic need to, we could mock out the DOM and unit-test this service outside of the Browser runtime.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000060","sortNo":10,"contentFormatId":"1","contentTxt":"Now that we have a service that provides a clean, programmatic interface to the system clipboard, we could certainly use this service directly. But, I know that the vast majority of the use-cases will be to have the user click a button and have some text copied to the clipboard. As such, I wanted to create a small Attribute Directive that would glue a click event to the ClipboardService. Something like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000061","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000062","sortNo":12,"contentFormatId":"1","contentTxt":"Here, the [clipboard] input is the selector for the Attribute Directive which, upon a (click) event, will copy the [clipboard] input to the system clipboard using the ClipboardService:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000063","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000064","sortNo":14,"contentFormatId":"1","contentTxt":"As you can see, this attribute directive takes the clipboard text as an input property and then emits two output events, one for success and one for error. And, since the ClipboardService completely abstracts access to the clipboard, this glue layer becomes as easy as a method call and some Promise handlers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000065","sortNo":15,"contentFormatId":"1","contentTxt":"Now, in the root component, we can use this glue directive to setup a few buttons that will copy various text values to the clipboard:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000066","sortNo":16,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000067","sortNo":17,"contentFormatId":"1","contentTxt":"For this demo, I'm just using simple Angular 2 DOM references to provide text (as innerHTML) to the [clipboard] input property of the glue directive; but, of course, you can use any public property of the root component's view-model to provide the text. You could even use static text. This just seemed like the easiest thing to demo.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000068","sortNo":18,"contentFormatId":"1","contentTxt":"And, when we run the above code, you can see that clicking the various buttons copies the text and makes it available for pasting:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000069","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000070","sortNo":20,"contentFormatId":"1","contentTxt":"Pretty cool stuff! What I especially like about this approach is that we're really isolating access to the clipboard so that if it the access requirements ever change, neither the root component nor the \"glue\" Attribute Directive need to care; only the internal implementation of the ClipboardService will need to change. We've kept it clean, isolating the things that change for different reasons.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201512280000000066","sortNo":1,"contentFormatId":"1","contentTxt":"orrified! That seemed to be the collective reaction when the Angular team announced two-way data binding would not be directly present in Angular2. Since then, the team have worked hard to reassure the community.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000067","sortNo":2,"contentFormatId":"1","contentTxt":"What would a one-way, single state pattern look like in Angular2?  I don't know whether this is the one-way pattern envisaged by the Angular team, so this may be more charicature than model code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000068","sortNo":3,"contentFormatId":"1","contentTxt":"The basic pattern","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000069","sortNo":4,"contentFormatId":"1","contentTxt":"Throughout these examples, we will keep state in a parent component. The parent will inform the children of the state they need to render, and the children will send action events back to the parent to cause state updates. After each update, the parent will cause the children to re-render with new values.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000070","sortNo":5,"contentFormatId":"1","contentTxt":"Example 1: A counter","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000071","sortNo":6,"contentFormatId":"1","contentTxt":"To start we will implement a single, simple counting component that shows its currently value and which can be increased or decreased, as shown in the image.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000072","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000073","sortNo":8,"contentFormatId":"1","contentTxt":"Let's start with the 'View' template, which simply attaches a click listener to each button using the new Angular syntax.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000074","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000130","sortNo":10,"contentFormatId":"1","contentTxt":"Now let's look at the component's Javascript.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000131","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000132","sortNo":12,"contentFormatId":"1","contentTxt":"There are several things to note here:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000133","sortNo":13,"contentFormatId":"1","contentTxt":"1. the CounterComponent class has no local state!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000134","sortNo":14,"contentFormatId":"1","contentTxt":"2. The component receives, as an @Input, its count value, which is rendered directly by the view;","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000135","sortNo":15,"contentFormatId":"1","contentTxt":"3. data leaves the component via the @Output function in the form of an event. In this case we emit (via the next method) what the state should be updated to.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000136","sortNo":16,"contentFormatId":"1","contentTxt":"The CounterComponent is instantiated by the parent App component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000137","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000138","sortNo":18,"contentFormatId":"1","contentTxt":"Here we see:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000139","sortNo":19,"contentFormatId":"1","contentTxt":"1. the model, which is a single number for the time being;","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000140","sortNo":20,"contentFormatId":"1","contentTxt":"2. the template that passes 'downward' the value in the model, and which providers the updater function to receive 'events' back from the child.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000141","sortNo":21,"contentFormatId":"1","contentTxt":"3. Received events are handled by the parent update function, pudate which updates state to the new value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000142","sortNo":22,"contentFormatId":"1","contentTxt":"Example 2 : Two Counters","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000143","sortNo":23,"contentFormatId":"1","contentTxt":"How can we extend the pattern above to handle two counters? Let's introduce a Counters component that will simply be instantiated by App.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000144","sortNo":24,"contentFormatId":"1","contentTxt":"Counters provides this View:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000145","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000146","sortNo":26,"contentFormatId":"1","contentTxt":"And uses this controller:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000147","sortNo":27,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000148","sortNo":28,"contentFormatId":"1","contentTxt":"And that's it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000149","sortNo":29,"contentFormatId":"1","contentTxt":"1. Nothing needs to happen to the Counter component - it is entirely reusable as is;","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000150","sortNo":30,"contentFormatId":"1","contentTxt":"2. We have a model with two parts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000151","sortNo":31,"contentFormatId":"1","contentTxt":"3. we pass different updater functions to each Counter by creating closures ('partially applying') of pupdate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000152","sortNo":32,"contentFormatId":"1","contentTxt":"Example 3 : Many Counters","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000153","sortNo":33,"contentFormatId":"1","contentTxt":"OK, two was good but what about a flexible number? Again, we won't need to touch Counter, but we will need some additional tools for its parent, Counters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000154","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000155","sortNo":35,"contentFormatId":"1","contentTxt":"This time our model has become an array, and we need a method to add elements to the model. pupdate does not need changing but note that it's modelName parameter now will be the index in the model Array. (We also bring in the NgFor Directive, which we need in the rewritten View.)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000156","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000157","sortNo":37,"contentFormatId":"1","contentTxt":"Example 4: Adding an extra action","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000158","sortNo":38,"contentFormatId":"1","contentTxt":"In example 3 we could only add a Counter. What if we want to remove them too? This time we will need to change Counter a little to add <button (click)=\"remove()\">X</button> to the View and implement the remove method to emit a second type of Event up to the parent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000159","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000160","sortNo":40,"contentFormatId":"1","contentTxt":"Counters needs to provide for this extra event when it instantiates new counter elements:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000161","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000162","sortNo":42,"contentFormatId":"1","contentTxt":"And premove works equivalently to addCounter to update the global state:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000163","sortNo":43,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000164","sortNo":44,"contentFormatId":"1","contentTxt":"Conclusions","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000165","sortNo":45,"contentFormatId":"1","contentTxt":"We have seen a succession of examples that added functionality while retaining a single source of state truth. Rendering was effectively 'pure' and actions were transmitted to the parent to maintain the state. The Angular loop is still quite different from Elm's but we have achieved some of the core elements on the one-way data binding pattern.","contentBinary":"","contentPoster":"","contentUrl":null}]
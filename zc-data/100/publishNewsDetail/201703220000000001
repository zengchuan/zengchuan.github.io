[{"id":"201703220000000001","sortNo":1,"contentFormatId":"1","contentTxt":"The goal of this article is to describe the inner workings of an environment for WebVR components that’s based on A-Frame & Angular 2. As the design and maintenance of components like these are complex and repetitive tasks it’d be of much help to have a mechanism to offload the boilerplate like base structures, build-scripts, polyfills and other ‘usual suspects’ found in almost every web-oriented project. This is the main reason why this project exists. I wanted to have a tool-set that could not only help me create nice WebVR components but also deliver them easily by following best practices and accepted Web Standards.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000002","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Project Setup</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000003","sortNo":3,"contentFormatId":"1","contentTxt":"This project follows the more or less ‘standard’ approach by semantically splitting the sources within the src/app-directory:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000005","sortNo":5,"contentFormatId":"1","contentTxt":"The initial logic is located in src/init-directory and contains main, vendor and polyfill scripts. As a build tool I’m using WebPack together with a few configuration files.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000006","sortNo":6,"contentFormatId":"1","contentTxt":"<strong>Booting the App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000007","sortNo":7,"contentFormatId":"1","contentTxt":"The main script loads the AppModule to boot the app.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000008","sortNo":8,"contentFormatId":"1","contentTxt":"But shortly before this happens the browser activates the A-Frame script by putting it before Angular’s Zone.js module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000009","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000010","sortNo":10,"contentFormatId":"1","contentTxt":"This is mandatory as Zone.js takes over the document.registerElement function and expects all properties, like detachedCallback, to be set. More info on this issue can be found here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000011","sortNo":11,"contentFormatId":"1","contentTxt":"<strong>Module Registration</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000012","sortNo":12,"contentFormatId":"1","contentTxt":"The next step is registering predefined A-Frame modules that are located in app.loader. We define modules as objects that implement the IVrModule interface.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000013","sortNo":13,"contentFormatId":"1","contentTxt":"They carry information about their type, like ‘AFrame’, the markup that describes their structure and optional scripts. In fact, one could easily add new frameworks by creating further module enums.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000014","sortNo":14,"contentFormatId":"1","contentTxt":"This is an example of  a simple module of type ‘AFrame’:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000015","sortNo":15,"contentFormatId":"1","contentTxt":"In a more realistic scenario such modules would be located in a separate storage. One could, for example, query them via REST-services and register on-the-fly. The module registration happens in vr-module.service that can also de-register existing ones. This service also dispatches messages to vr-module reducer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000016","sortNo":16,"contentFormatId":"1","contentTxt":"This is how its registration method looks like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000017","sortNo":17,"contentFormatId":"1","contentTxt":"<strong>State Management</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000018","sortNo":18,"contentFormatId":"1","contentTxt":"The aforementioned reducer is based on @ngrx that will help us manage our application state more easily.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000019","sortNo":19,"contentFormatId":"1","contentTxt":"In its current state the reducer isn’t much used within the application because of a simple fact that in its original version the app functions only as a ‘show room’ for a few VR modules. Currently, its sole purpose is to keep the availableModules-property up to date which is bound to the modules-property of VrListComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000020","sortNo":20,"contentFormatId":"1","contentTxt":"The store from above is being created here by using provideStore function from @ngrx.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000021","sortNo":21,"contentFormatId":"1","contentTxt":"I’m also not completely following the best practices because I don’t use any Action Creators. Instead, I’m dispatching raw messages. Please, forgive me.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000022","sortNo":22,"contentFormatId":"1","contentTxt":"<strong>Module Sidebar</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000023","sortNo":23,"contentFormatId":"1","contentTxt":"In parallel to module registration the AppComponent builds up a proper view that’ll show us the modules in a sidebar. This part of the task is offloaded to another component, vr-list, that creates a list of module names. Notice that the surrounding bootstrap-structure could be safely replaced by any other styling library. Also take into account that data for [modules]-binding goes through an AsyncPipe that’s one of Angular’s default pipes. Previously we’ve selected an Observable from the vrModule–Store and therefore we have to properly consume those asynchronous data streams. That’s why AsyncPipe is made for. As our modules-property in VrListComponent knows nothing about Observables our data must go through this pipe first.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000024","sortNo":24,"contentFormatId":"1","contentTxt":"As shown in the above HTML we simply forward the contents of AppComponent’s availableModules property to VrListComponent’s modules property. If you don’t know the mechanics making this possible simply jump to this article of mine.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Additionally, we combine the EventEmitter from VrListComponent to AppComponent’s handler method onVrModuleSelected. We’re interested in user selections done on the Sidebar because we want to load the appropriate A-Frame module. Again, if you have problems understanding the mechanism you could read one of my previous articles first before going any further.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000026","sortNo":26,"contentFormatId":"1","contentTxt":"<strong>Module Selection</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000027","sortNo":27,"contentFormatId":"1","contentTxt":"Now the most interesting part happens when user selections reach the event handler in AppComponent. Here, we’re not only creating a message object that describes the module but also utilizing Angular’s routing mechanism that’ll kick off VR-module instantiation itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000028","sortNo":28,"contentFormatId":"1","contentTxt":"By itself, our routing paths look very simple, because there’s only one possible target: VrWrapperModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000029","sortNo":29,"contentFormatId":"1","contentTxt":"But, there’s more as VrWrapperModule owns a separate routing definition that helps the framework load appropriate VR modules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000030","sortNo":30,"contentFormatId":"1","contentTxt":"<strong>Routing Mechanism</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000031","sortNo":31,"contentFormatId":"1","contentTxt":"The routing target, VrWrapperComponent, subscribes to route-params Observable and reacts to changes by creating another carrier object called dynamicComponent. In case you need more info regarding Observables and functional/reactive coding in Angular, there’s an older article of mine that might be of some value to you.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000032","sortNo":32,"contentFormatId":"1","contentTxt":"<strong>Module Instantiation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000033","sortNo":33,"contentFormatId":"1","contentTxt":"Now, the question is, where does dynamicComponent go? Let’s see the HTML structure of VrWrapperComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000034","sortNo":34,"contentFormatId":"1","contentTxt":"Well, we now understand why it’s being called a ‘wrapper’. It’s because it is a wrapper for some other component, VrElement, that depends on our dynamicComponent. But this time the dependent component is not yet another Angular component. It’s a Directive. This directive’s main task is dynamic creation and instantiation of Angular components plus optional injection of external JavaScripts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000035","sortNo":35,"contentFormatId":"1","contentTxt":"First, it takes care of removing any previous VR-related scripts from the document body. Then, it injects optional scripts that could be provided by the module. Finally, it creates future component’s metadata by copying dynamicComponent’s html-property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000036","sortNo":36,"contentFormatId":"1","contentTxt":"<strong>Dynamic Modules</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000037","sortNo":37,"contentFormatId":"1","contentTxt":"Ultimately, we pass the metadata to a helper function called createComponentFactory that’ll complete our task by injecting a fully functional component into the DOM. The structure of this helper function is as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000038","sortNo":38,"contentFormatId":"1","contentTxt":"First, we create a brand new @NgModule and feed it with CUSTOM_ELEMENTS_SCHEMA from Angular’s core library. This constant is very important because A-Frame uses it’s own components whose names begin with an “a-” prefix. Any HTML elements whose tags contain a dash in their name must either be “Angular-known” elements or there has to be a CUSTOM_ELEMENTS_SCHEMA loaded into containing @NgModule. Without this schema constant you’ll receive a ton of error messages complaining that there’s an “unknown element with name XYZ“.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000039","sortNo":39,"contentFormatId":"1","contentTxt":"Armored with this knowledge we go a step further an put the component declaration that contains our incoming metadata into @NgModule. As you can see above we’re just using an empty component class type, DnamicComponent, that served us as a wrapper to be combined with our previous metadata. With this new component we complete our @NgModule’s definition and hand it over to Angular Compiler’s method compileModuleAndAllComponentsAsync. As a result we get back a component factory (not a component!) that we’ll soon use to create a new component to be inserted into our view container.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000040","sortNo":40,"contentFormatId":"1","contentTxt":"As you can imagine, a Directive can’t have a template, so we have to find some ‘free space’ in the DOM where we can put our new component in. To prepare ourselves for this task we’ve already instantiated our Directive by feeding it a proper ViewContainer Reference via Angular’s Dependency Injection mechanism. Now, I hope, it’s easy to understand why we’re calling ViewContainerRef’s createComponent method and pass it our component factory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000041","sortNo":41,"contentFormatId":"1","contentTxt":"The ViewContainer Reference should have no knowledge on how we create our components. It’s only duty is to provide us ‘some room’ for our new component. The rest is done in the factory itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000042","sortNo":42,"contentFormatId":"1","contentTxt":"<strong>Optional Scripts Injection</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000043","sortNo":43,"contentFormatId":"1","contentTxt":"And just to make the journey complete, let’s examine the simple mechanism that helps insert optional scripts into the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000044","sortNo":44,"contentFormatId":"1","contentTxt":"We call NgZone’s runOutsideAngular to do some extra stuff in the DOM that should bypass Angular’s mechanism. In this case we’re directly manipulating DOM’s structure and because we don’t want to mess with Angular’s own DOM manipulation logic we do the job ‘outside’ of it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000045","sortNo":45,"contentFormatId":"1","contentTxt":"We create a new <script> Tag and feed it with values that’ll help us recognize it later. This will be of great importance when we have to load another module. We don’t want old scripts lying around so we take care of giving them unique names. Ultimately, we insert them into the DOM and memorize in our internal activeScripts variable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000046","sortNo":46,"contentFormatId":"1","contentTxt":"<strong>Conclusion</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000047","sortNo":47,"contentFormatId":"1","contentTxt":"I hope this article could help you understand my motives to build such an environment. WebVR and related technologies are still brand new and there are many moving parts but all learning starts with a single step. However, I didn’t want my journey to begin with a single learning step and end as a configuration death march. Nothing drains one’s own enthusiasm faster than configuration obstacles. You know it, JavaScript fatigue and JS-fatigue-fatigue. I think we can do it better, because there are many excellent tools, de-facto standards and best-practices.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000048","sortNo":48,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000049","sortNo":49,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/brakmic/Angular2_VR_Starter\">https://github.com/brakmic/Angular2_VR_Starter</a>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703220000000050","sortNo":50,"contentFormatId":"1","contentTxt":"<a href=\"http://brakmic.com/demos/vrdemo\">demo</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
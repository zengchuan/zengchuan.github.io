[{"id":"201609220000000039","sortNo":1,"contentFormatId":"1","contentTxt":"The @NgModule is a new decorator that has recently been added in Angular 2. NgModule defines an Angular Module, which (from the official docs) are defined as \"Angular Modules help organize an application into cohesive blocks of functionality.\"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000040","sortNo":2,"contentFormatId":"1","contentTxt":"This post is the second in a series that introduce @NgModule and its role in creating Angular 2 apps. In this post I'll discuss some motivations for creating multiple modules, some decisions we have to make regarding them, and how routing fits into modules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000041","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>One Root Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000042","sortNo":4,"contentFormatId":"1","contentTxt":"When we create an Angular 2 app, we define a root module. We learned about this in the previous post. This root module is defined with @NgModule and works quite well for small apps.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000043","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000044","sortNo":6,"contentFormatId":"1","contentTxt":"Our root module declares our components, pipes and directives so Angular can recognize them in our templates. Our root module imports common features from the Angular 2 BrowserModule, FormsModule, and HttpModule. This allows us to use common features like ngIf and ngFor, ngModel for forms, and the Http service in our app. We're pretty set right now on basic functionality.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000045","sortNo":7,"contentFormatId":"1","contentTxt":"Our root module also provides a few custom services. Because we do this in the root module, anyone in our current app can use these.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000046","sortNo":8,"contentFormatId":"1","contentTxt":"We could continue to add more components and features to this root module, and it would work. But at some point we may want to organize our app by related features. Perhaps we have a vehicles feature, an characters feature, a login feature, and a reusable widgets feature. Each of these feature areas may have multiple components and it might make sense to keep them together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000047","sortNo":9,"contentFormatId":"1","contentTxt":"<strong>Why Create More Modules?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000048","sortNo":10,"contentFormatId":"1","contentTxt":"But Why? Why keep the features together? Why encapsulate the features? One reason is organization and readability.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000049","sortNo":11,"contentFormatId":"1","contentTxt":"A more technical reason is that we may want to make a feature promotable. For example a we could make a feature that has custom widgets such as a CalendarComponent and ButtonComponent. We may want to use these across the entire app and intend to use them in other apps. Making a feature area for these widgets makes a lot of sense in this case.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000050","sortNo":12,"contentFormatId":"1","contentTxt":"Another reason for encapsulating feature areas is to help keep the starting app lean and fast. When the app starts we may want to only send the parts of the app that are needed to crank it up and are the most commonly used pieces. That may not include all feature areas. The ones we want to load up front could be eagerly loaded while the others could be lazily loaded as needed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000051","sortNo":13,"contentFormatId":"1","contentTxt":"All of these are made easier by @NgModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000052","sortNo":14,"contentFormatId":"1","contentTxt":"<strong>Expanding Our App with Features</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000053","sortNo":15,"contentFormatId":"1","contentTxt":"Let's warp speed forward a bit and our app now has some of these features. We would likely start by putting all of these in the root module, and it might end up looking something like the following.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000054","sortNo":16,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000055","sortNo":17,"contentFormatId":"1","contentTxt":"Notice our declarables got quite a bit larger. That's ok ... now let's step aside and look at another requirement of most apps: routing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000056","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Routing in a Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000057","sortNo":19,"contentFormatId":"1","contentTxt":"Our app has many features and we want to use routing to navigate between our components. We also have a NavComponent that the allows the user to navigate. We're going to need to add routing logic to our app.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000058","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000059","sortNo":21,"contentFormatId":"1","contentTxt":"Here we created an app.routing.ts file that exports AppRoutingModule which is ... wait for it ... an Angular module!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000060","sortNo":22,"contentFormatId":"1","contentTxt":"Notice how we are explicitly referencing the components in the routes? These are currently set up for eager loading. We can make them load on demand (aka lazy loading) ... we'll learn more about that in a future post.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000061","sortNo":23,"contentFormatId":"1","contentTxt":"We just discovered another reason to create modules. We can now import this module into our root module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000062","sortNo":24,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000063","sortNo":25,"contentFormatId":"1","contentTxt":"Importing the routing module we created also gives us the routing features we need. That forRoot() function returned a module, which is imported by AppRoutingModule, which in turn is imported in the root module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000064","sortNo":26,"contentFormatId":"1","contentTxt":"Here is a simple example of an app with a root module and a routing module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000065","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000066","sortNo":28,"contentFormatId":"1","contentTxt":"<strong>More Modules?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000067","sortNo":29,"contentFormatId":"1","contentTxt":"We just took the first steps to creating more modules, for our features. Along the way we created a routing module and imported it. If we want to organize our app by feature, promote our widgets, and load features as we use them it may benefit us to encapsulate the features. We'll do this by creating more modules in the next post.","contentBinary":"","contentPoster":"","contentUrl":null}]
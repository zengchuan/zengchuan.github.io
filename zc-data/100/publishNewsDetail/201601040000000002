[{"id":"201601040000000002","sortNo":1,"contentFormatId":"1","contentTxt":"Pipes are the modernized version of filters in Angular 1.X. Something like using function in your templates; or something like helpers to modify, choose, format your value within the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000003","sortNo":2,"contentFormatId":"1","contentTxt":"Usage of pipes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000004","sortNo":3,"contentFormatId":"1","contentTxt":"1. You can display only some filtered elements from an array.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000005","sortNo":4,"contentFormatId":"1","contentTxt":"2. You can modify or format the value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000006","sortNo":5,"contentFormatId":"1","contentTxt":"3. You can use them as a function.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000007","sortNo":6,"contentFormatId":"1","contentTxt":"4. You can do all of the above combined.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000008","sortNo":7,"contentFormatId":"1","contentTxt":"Why pipes?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000009","sortNo":8,"contentFormatId":"1","contentTxt":"Pipes don’t give you any new feature. In angular 2 you can use logics in templates too. You also can execute a function in the template to get its returned value. But pipes is a handsome way to handle these things in templates. It makes your code more clean and structured.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000010","sortNo":9,"contentFormatId":"1","contentTxt":"General syntax","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000011","sortNo":10,"contentFormatId":"1","contentTxt":"myValue | myPipe:param1:param2 | mySecondPipe:param1","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000107","sortNo":11,"contentFormatId":"1","contentTxt":"The pipe expression starts with the value followed by the symbol pipe (|), than the pipe name. The params for that particular pipe can be sent separated by colon (:) symbol. However the pipe operator only works in your templates and not in JavaScript code. In JavaScript the pipe symbol works as bitwise operator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000108","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000109","sortNo":13,"contentFormatId":"1","contentTxt":"DatePipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000110","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000111","sortNo":15,"contentFormatId":"1","contentTxt":"We pointed our @View decorator to a templateUrl in which we make use of the date pipe:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000112","sortNo":16,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000113","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000114","sortNo":18,"contentFormatId":"1","contentTxt":"DecimalPipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000115","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000116","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000117","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000118","sortNo":22,"contentFormatId":"1","contentTxt":"Async Pipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000119","sortNo":23,"contentFormatId":"1","contentTxt":"Angular 2 provides a special pipe known as async, which allows us to bind our templates directly to values that arrive asynchronously. This ability is great for working with promises and observables. To see how this works, we'll create a simple promise and have it resolve with a string.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000120","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000121","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000122","sortNo":26,"contentFormatId":"1","contentTxt":"After a 2 second delay, the value from the resolved promise will be displayed on the screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000123","sortNo":27,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000124","sortNo":28,"contentFormatId":"1","contentTxt":"CurrencyPipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000125","sortNo":29,"contentFormatId":"1","contentTxt":"This pipe helps you to format and using the symbols as ISO 4217 currency code, such as “USD” for the US dollar and “EUR” for the euro. The second parameter it takes is symbolDisplay whose default value is false. The third parameter is digitInfo which works as DecimalPipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000126","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000127","sortNo":31,"contentFormatId":"1","contentTxt":"LowerCasePipe & UpperCasePipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000128","sortNo":32,"contentFormatId":"1","contentTxt":"The name says it all. These two pipes just changes the cases of the characters. They don’t accept any parameters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000129","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000130","sortNo":34,"contentFormatId":"1","contentTxt":"JSONPipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000131","sortNo":35,"contentFormatId":"1","contentTxt":"Normally with the help of double curly brace operator ({{}}) you can print a value but not an entire object. You end up printing [object object]. To print the JSON object properly you can use JSONPipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000132","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000133","sortNo":37,"contentFormatId":"1","contentTxt":"SlicePipe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000134","sortNo":38,"contentFormatId":"1","contentTxt":"Slice pipe is a pipe which works just like JavaScript’s Array.prototype.slice().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000135","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000136","sortNo":40,"contentFormatId":"1","contentTxt":"Custom Pipes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000137","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000138","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000139","sortNo":43,"contentFormatId":"1","contentTxt":"We use the transform method to do any logic necessary to convert the value that is being passed in. We can get ahold of the arguments array as the second parameter and pass in as many as we like from the template. As you can see here, we check the type of conversion that we want (e.g., Fahrenheit to Celsius), convert the value passed in, and then return the converted value to the number of decimal places specified in the second argument of the pipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000140","sortNo":44,"contentFormatId":"1","contentTxt":"As mentioned above, we need to provide an array to the pipes property in the @View decorator to use the new pipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000141","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000142","sortNo":46,"contentFormatId":"1","contentTxt":"Pure and Impure pipes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000143","sortNo":47,"contentFormatId":"1","contentTxt":"Pipe also accepts a metadata called pure. The listed predefined pipes above are all pure pipes (the pure property is set to true). If a pipe is pure, it will re-execute only the value of the input or the passed parameter are changed. But if you want to re-run a pipe independently of the scenario I just said, you can make your pipe impure by setting the property pure to false.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000144","sortNo":48,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000145","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000146","sortNo":50,"contentFormatId":"1","contentTxt":"This code is another use of custom pipes. A custom pipe countdown is created, setting the pure property to false. It has a timer inside it which runs in every 50 milliseconds and changes the value of a certain property of the pipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000147","sortNo":51,"contentFormatId":"1","contentTxt":"Pipe vs filter","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000148","sortNo":52,"contentFormatId":"1","contentTxt":"Angular 1.X had a concept of filters. Pipes are very much similar to that but it has some significant advantages, the pipes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000149","sortNo":53,"contentFormatId":"1","contentTxt":"Filters used to act like helpers, very similar to functions where you pass the input and other parameters and it returns you the value; but pipe works as a operator. The concept is, you have an input and you can modify the input applying multiple pipes in it. This not only simplifies the nested pipe logic, but also gave you a beautiful and clean syntax for your templates. Secondly, in case of async operations, you need to set things manually in case of angular 1.X filters. But pipes are smart enough to handle async operations.","contentBinary":"","contentPoster":"","contentUrl":null}]
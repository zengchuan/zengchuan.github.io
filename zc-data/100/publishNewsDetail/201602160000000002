[{"id":"201602160000000038","sortNo":1,"contentFormatId":"1","contentTxt":"This is a follow-up article of thoughtram’s excellent article on developing a tabs component with Angular 2, where we’re going to explore an alternative way of creating a tab component by learning about @ContentChildren and AfterContentInit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000039","sortNo":2,"contentFormatId":"1","contentTxt":"That said, definitely read thoughtram’s article on how to develop a tabs component in Angular 2 first. Then come back and continue here .","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000040","sortNo":3,"contentFormatId":"1","contentTxt":"Ok, to recap, the API of the tabs component looks as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000041","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000042","sortNo":5,"contentFormatId":"1","contentTxt":"Whenever a user clicks on the tab header, the <tabs> component takes care of setting that specific tab to be visible and to hide all others. That’s why we need to establish a communication between the parent <tabs> and its children <tab>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000043","sortNo":6,"contentFormatId":"1","contentTxt":"For establishing a communication between the two components, the thoughtram article uses Angular 2’s powerful dependency injection which allows us to simply ask for an instance of a parent component. In the <tab> child component it simply asked for its parent <tabs> and registered itself on that parent component, using the addTab function:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000044","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000045","sortNo":8,"contentFormatId":"1","contentTxt":"The alternative approach","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000046","sortNo":9,"contentFormatId":"1","contentTxt":"This article is just about continuing thoughtram’s example, but without using the dependency injection approach. So basically, rather than getting a reference to our parent component Tabs in the child component Tab (child => parent), we’re doing it the other way round: we’ll get a reference to all of the Tab child components from the parent Tabs (parent => child).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000047","sortNo":10,"contentFormatId":"1","contentTxt":"If you open the Tabs component, you can see that the child <tab> components are projected into it’s template via the content projection mechanism using <ng-content>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000048","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000049","sortNo":12,"contentFormatId":"1","contentTxt":"What we want, is to get a reference to all of the <tab> children that get projected into that section, so that we can act on their corresponding API (i.e. hiding/showing them).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000050","sortNo":13,"contentFormatId":"1","contentTxt":"@ContentChildren and QueryList","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000051","sortNo":14,"contentFormatId":"1","contentTxt":"We can do exactly this using the @ContentChildren decorator. You have to pass the decorator the type you want to get a reference to. In our example it would look like @ContentChildren(Tab). As a result we will get a list of instances in the form of a QueryList<Tab>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000052","sortNo":15,"contentFormatId":"1","contentTxt":"A QueryList<T> is simply “an unmodifiable list of items that Angular keeps up to date when the state of the application changes”","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000053","sortNo":16,"contentFormatId":"1","contentTxt":"Hence, as a first step, we’re going to import the new constructs in our Tabs component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000054","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000055","sortNo":18,"contentFormatId":"1","contentTxt":"Then, inside our class we can use it like","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000056","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000057","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000058","sortNo":21,"contentFormatId":"1","contentTxt":"ngAfterContentInit lifecycle hook","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000059","sortNo":22,"contentFormatId":"1","contentTxt":"To access the list of Tab instances, we need to wait for them to be projected into our Tabs component. There’s a dedicated component lifecycle hook for that: ngAfterContentInit. This hook is called after the component content is initialized.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000060","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000061","sortNo":24,"contentFormatId":"1","contentTxt":"Also note the AfterContentInit interface we’re importing. This is really just for better type checking with TypeScript. It doesn’t have any other effect, as TypeScript interfaces do not alter the transpiled JavaScript code, they disappear once you transpile.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000062","sortNo":25,"contentFormatId":"1","contentTxt":"Within the ngAfterContentInit function we can now fetch all of our tabs and activate the first one if none is already set to be the active one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000063","sortNo":26,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000064","sortNo":27,"contentFormatId":"1","contentTxt":"Similarly, whenever someone clicks on a tab header, we call the selectTab(tab: Tab) function which gets all of the tabs and deactivates all of them to finally set the clicked tab to active and thus visible.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000065","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000066","sortNo":29,"contentFormatId":"1","contentTxt":"source code","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000067","sortNo":30,"contentFormatId":"1","contentTxt":"tabs.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000068","sortNo":31,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000069","sortNo":32,"contentFormatId":"1","contentTxt":"tab.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000070","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000071","sortNo":34,"contentFormatId":"1","contentTxt":"app.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602160000000072","sortNo":35,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201609300000000216","sortNo":1,"contentFormatId":"1","contentTxt":"In an earlier post on creating a pre-bootstrap loading screen in Angular 2 RC 1, Moataz asked me about closing the loading screen based on an application event rather than the SystemJS-loaded event. And to be honest, I'm not really sure how to accomplish this in the prototypical \"Angular way.\" Ultimately, we need the Angular app to communicate with the world outside the Angular app. Which means, in one or another, a bridge has to be created. For this demo, I'm using the underlying DOM (Document Object Model) tree as that bridge, emitting a DOM-event from within the application when the application is ready to receive user interaction.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000217","sortNo":2,"contentFormatId":"1","contentTxt":"I am sure that there is some way for the parent page to reach into the Angular Injector and read some application state. But, this feels ultra-janky and would likely create an unnecessarily complex mental model for the developer. By using the DOM tree as the cross-boundary bridge, it uses a mental model and a communications-flow that developers are familiar with. And, hopefully we can still do it in a way that is cross-platform compatible.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000218","sortNo":3,"contentFormatId":"1","contentTxt":"First, let's look at our index page - where the root of our Angular 2 application is loaded. In the following code, you'll notice that the pre-bootstrap loading page is outside of the root component. We need to do this because Angular will immediately replace the root component's content with the root component's template when the app is initialized. And, sine we can't project static content into the root component, we can only maintain control by keeping the root component and our pre-bootstrap loading page as sibling elements:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000219","sortNo":4,"contentFormatId":"1","contentTxt":"In the following code, notice that the pre-bootstrap loading logic is binding to an \"appready\" DOM-event on the document node. It's using this as the initiator of the loading screen teardown process. This is the event that we will need to emit from within the Angular application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000220","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000221","sortNo":6,"contentFormatId":"1","contentTxt":"Now, imagine that in order to render the root of the component, we need to load some data over the network. For example, we might have to load the account data for the current user. And, in order to prevent the pre-bootstrap screen from revealing to an empty white page (while the Account request is running), we can keep the pre-bootstrap page in place until that first Account request comes back.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000222","sortNo":7,"contentFormatId":"1","contentTxt":"I refactored the service to be called \"AppReadyEvent\" which only exposes a single method (at this time): .trigger():","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000223","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000224","sortNo":9,"contentFormatId":"1","contentTxt":"As you can see, the implementation on the Browser platform is still tied to the Document Object Model. However, at this point, there's nothing in the naming of the service or its methods that indicate a platform relationship, creating a much cleaner abstraction.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000225","sortNo":10,"contentFormatId":"1","contentTxt":"And, with a cleaner abstraction at the event-service level, our root component also becomes much cleaner:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000226","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000227","sortNo":12,"contentFormatId":"1","contentTxt":"Now, when the root component has its data loaded, it just triggers the AppReadyEvent. It doesn't know anything about the DOM - it doesn't know that this event is actually being triggered on the \"document\". It only knows that there's a service it should call.","contentBinary":"","contentPoster":"","contentUrl":null}]
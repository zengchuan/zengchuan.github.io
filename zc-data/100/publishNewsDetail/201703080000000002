[{"id":"201703080000000050","sortNo":1,"contentFormatId":"1","contentTxt":"<strong>Introduction</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000051","sortNo":2,"contentFormatId":"1","contentTxt":"Routes provide benefits to the users of our applications. While routes are not necessary in all applications, they make applications shine a little brighter. Having routes in your application gives users the ability to return to a specific point in your application just by typing in a URL.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000052","sortNo":3,"contentFormatId":"1","contentTxt":"Testing routes comes with some interesting challenges. Keep reading to find out how to tackle them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000053","sortNo":4,"contentFormatId":"1","contentTxt":"<strong>Prerequisites</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000054","sortNo":5,"contentFormatId":"1","contentTxt":"Before starting this article, it is assumed that you have:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000055","sortNo":6,"contentFormatId":"1","contentTxt":"1. An understanding of Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000056","sortNo":7,"contentFormatId":"1","contentTxt":"2. Knowledge of TypeScript and how it relates to JavaScript.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000057","sortNo":8,"contentFormatId":"1","contentTxt":"3. An understanding of ES6/ES2015 concepts such as arrow functions, modules, classes, and block-scoped variables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000058","sortNo":9,"contentFormatId":"1","contentTxt":"4. Comprehension of using a command line or terminal such as Git Bash, iTerm, or your operating system's built-in terminal.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000059","sortNo":10,"contentFormatId":"1","contentTxt":"5. Node >= v4 and NPM >= v3 installed while knowing how to run NPM scripts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000060","sortNo":11,"contentFormatId":"1","contentTxt":"6. A setup capable of unit testing Angular 2 applications. If you could use some help with this, see our tutorials on Setting Up Angular 2 with Webpack, Testing Components in Angular 2 with Jasmine, and Testing Services in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000061","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>The Sample Project</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000062","sortNo":13,"contentFormatId":"1","contentTxt":"In previous tutorials, we began developing an application which dynamically generates and displays forms. The application can handle forms passed from a server, display them as a list, and let users display a selected form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000063","sortNo":14,"contentFormatId":"1","contentTxt":"The list of forms and the selected form are both displayed on a single page, making for a cluttered user experience. In this tutorial, we'll use routes to remove that clutter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000064","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>Cloning the Repository</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000065","sortNo":16,"contentFormatId":"1","contentTxt":"If you'd like to view the final code for this article, it's available in this GitHub repository. It can be downloaded by going to your terminal/shell and entering:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000066","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000067","sortNo":18,"contentFormatId":"1","contentTxt":"Once cloned, switch to this article's final code by typing:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000068","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000069","sortNo":20,"contentFormatId":"1","contentTxt":"To see the code from the previous article on services, enter:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000070","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000071","sortNo":22,"contentFormatId":"1","contentTxt":"To see the code from our previous article on components, enter:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000072","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000073","sortNo":24,"contentFormatId":"1","contentTxt":"Once you have the code checked out, make sure to run:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000074","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000075","sortNo":26,"contentFormatId":"1","contentTxt":"This will install all of the dependencies.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000076","sortNo":27,"contentFormatId":"1","contentTxt":"<strong>Continuing from Existing Code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000077","sortNo":28,"contentFormatId":"1","contentTxt":"If you have existing code, it's a good idea to update your dependencies before diving in. Between the previous tutorial and this one, the following dependency upgrades were made:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000078","sortNo":29,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000079","sortNo":30,"contentFormatId":"1","contentTxt":"Make those changes in package.json and, from the root of your code, run:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000080","sortNo":31,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000081","sortNo":32,"contentFormatId":"1","contentTxt":"Depending on your version of Node and NPM you may receive warnings, but all the dependencies should be working.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000082","sortNo":33,"contentFormatId":"1","contentTxt":"<strong>Traveling Along a Route</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000083","sortNo":34,"contentFormatId":"1","contentTxt":"As mentioned in the introduction, routes can give an application an added level of quality by giving users URL-access to specific points in an application. The routes in our application will be relatively simple, but the Angular router can handle very complex routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000084","sortNo":35,"contentFormatId":"1","contentTxt":"Our application will have two routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000085","sortNo":36,"contentFormatId":"1","contentTxt":"1. Viewing the list of available forms (/forms).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000086","sortNo":37,"contentFormatId":"1","contentTxt":"2. Viewing a single form (/form/:id).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000087","sortNo":38,"contentFormatId":"1","contentTxt":"<strong>Colon-Prefixes in Routes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000088","sortNo":39,"contentFormatId":"1","contentTxt":"You'll notice the second URL (/form/:id) has the :id notation on it. When a route contains a colon-prefixed substring, the values following that colon are considered a parameter of the route.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000089","sortNo":40,"contentFormatId":"1","contentTxt":"This means that this route will activate for any URL that starts /form/ and ends with any value. This means /form/123 and /form/foo will be recognized. The values 123 and foo would be made available through use of the ActivatedRoute class, which we will look at later.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000090","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>How to Test Routing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000091","sortNo":42,"contentFormatId":"1","contentTxt":"Routing is an interesting topic because the bulk of the work is handled by the routing library. Angular's routing library provides a lot functionality out of the box, taking a lot of the work off of application developers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000092","sortNo":43,"contentFormatId":"1","contentTxt":"For instance, having a default route requires no extra coding. Since this is handled by Angular, it goes outside the responsibility of testing for the application developer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000093","sortNo":44,"contentFormatId":"1","contentTxt":"So, what's left to test?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000094","sortNo":45,"contentFormatId":"1","contentTxt":"<strong>What We Will Be Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000095","sortNo":46,"contentFormatId":"1","contentTxt":"Since our application will need to leverage two features of the Angular routing library, we'll need to test that we're accessing those features at the correct time. The first feature we'll be using is the router's navigateByUrl method, which should be called when the user tries to open a form from the list.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000096","sortNo":47,"contentFormatId":"1","contentTxt":"We'll utilize the router's params to get the ID of the form that we want to view. This means that we'll need to test if the form-displaying component understands and utilizes the router's params object properly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000097","sortNo":48,"contentFormatId":"1","contentTxt":"<strong>First Things First</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000098","sortNo":49,"contentFormatId":"1","contentTxt":"To use the router in our application we'll need to install it via NPM. To do so, from the root of the project, run the following command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000099","sortNo":50,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000100","sortNo":51,"contentFormatId":"1","contentTxt":"<strong>New Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000101","sortNo":52,"contentFormatId":"1","contentTxt":"The Angular routing library is a component router, meaning that when a specific route hits, one or more specified components are displayed. In the router-enabled version of our application, we'll have two new components:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000102","sortNo":53,"contentFormatId":"1","contentTxt":"1. FormListComponent: displays the list of forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000103","sortNo":54,"contentFormatId":"1","contentTxt":"2. FormViewerComponent: displays a single form, specified by ID.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000104","sortNo":55,"contentFormatId":"1","contentTxt":"For now, we will create two bare-bones components, which we will expand on later. For each component we need .component.ts, .component.spec.ts, and .component.html files, as we've done for other components in the previous articles. Additionally, you can checkout the routing-components tag from the GitHub project to see the components' starting setup.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000105","sortNo":56,"contentFormatId":"1","contentTxt":"<strong>The Routing Setup</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000106","sortNo":57,"contentFormatId":"1","contentTxt":"Next, we'll need to set up our router. Thanks to the power of Angular's NgModule decorator, we can add routes to our project easily. Add a file to the src directory named app-routing.module.ts, this module will hold all of our routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000107","sortNo":58,"contentFormatId":"1","contentTxt":"We name the file app-routing because, in more complex applications, we can have specific routing for child modules. Giving it the app- prefix is a good practice for understanding to which level the routing applies.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000108","sortNo":59,"contentFormatId":"1","contentTxt":"In app-routing.module.ts, we'll need to pull in our Angular dependencies:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000109","sortNo":60,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000110","sortNo":61,"contentFormatId":"1","contentTxt":"Here, we're simply pulling in NgModule and the necessary routing dependencies. The first is the RouterModule, which is used to establish the routes we'll be using. The second is the Routes interface which defines the data shape of a route.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000111","sortNo":62,"contentFormatId":"1","contentTxt":"We'll also need to import the components that we'll be routing to when a certain route is hit. These are the components we have just created.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000112","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000113","sortNo":64,"contentFormatId":"1","contentTxt":"Then, we will define our routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000114","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000115","sortNo":66,"contentFormatId":"1","contentTxt":"There's quite a bit of new information here, so let's break it down. We're creating an Array of route objects. The order of these paths matters and will be read from the first route to the last. If a path is matched, it will be used as the route to display.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000116","sortNo":67,"contentFormatId":"1","contentTxt":"Each object has a path, which is a string. We're describing two types of routes — a component route and a redirect route. The component routes are routes that display an actual component, while the redirect route will redirect to another route — in our case, if the user navigates to http://mysite/ it will redirect to http://mysite/#/forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000117","sortNo":68,"contentFormatId":"1","contentTxt":"One thing of note is the pathMatch attribute on the redirect route. This attribute is a way of telling Angular how to evaluate the paths to find a match. On redirect routes, this attribute is required, but it can be used on other routes as well. We've set it to full, which tells the router to match the entire route. The other possible value is prefix, which matches any route that begins with a certain value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000118","sortNo":69,"contentFormatId":"1","contentTxt":"Finally, we'll define our routing module:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000119","sortNo":70,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000120","sortNo":71,"contentFormatId":"1","contentTxt":"This is pretty simple. We use the Angular RouterModule to establish our routes using forRoot. We use the static RouterModule.forRoot method at the application-level only. If we were to set up routing at lower-levels, we would use the static RouterModule.forChild method, but we will not delve into that in this application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000121","sortNo":72,"contentFormatId":"1","contentTxt":"Note the useHash option we pass in to the forRoot method. This tells the router that the URLs will use a # prefix, which would look similar to http://mysite.com/#/forms instead of http://mysite.com/forms. We do this because the default, non-hash strategy (known as the PathLocationStrategy) requires the server to understand the routes we're using in our application and that is outside the scope of this article.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000122","sortNo":73,"contentFormatId":"1","contentTxt":"As the last part of our setup, we incorporate our AppRoutingModule into the main AppModule of app.module.ts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000123","sortNo":74,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000124","sortNo":75,"contentFormatId":"1","contentTxt":"<strong>Getting Started with Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000125","sortNo":76,"contentFormatId":"1","contentTxt":"We're now ready to develop our new components for routing with a test-first approach. We can start with the simpler FormListComponent. What we'll be testing with the FormListComponent is that when the user clicks a Display button from the list, it calls the Router method navigateByUrl with the expect URL.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000126","sortNo":77,"contentFormatId":"1","contentTxt":"The navigateByUrl method does exactly what it says: it attempts to navigate to the specified URL string using the router. To do this, we'll need to mock out a version of the router that spies on the navigateByUrl method. We've done this before in the article on testing services, so it may seem familiar. In components/form-list/form-list.component.spec.ts, we'll first need to provide a mock Router:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000127","sortNo":78,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000128","sortNo":79,"contentFormatId":"1","contentTxt":"We've leveraged Angular's testing framework to substitute the regular Router class with our MockRouter. The regular Router has many more methods and features, but our mock router just needs stubs for the methods we care about — in this case that just means navigateByUrl. This allows us to avoid loading the real Router and all its setup for our tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000129","sortNo":80,"contentFormatId":"1","contentTxt":"Note that we're utilizing the async test method here. This allows us to create our components for testing, which is an asynchronous operation, in a way that executes our tests only after the asynchronous operations have completed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000130","sortNo":81,"contentFormatId":"1","contentTxt":"With our component we also need a method, displayForm, that handles a user clicking a display button within the list. When a button is clicked, we just need to navigate to form display URL with the ID of the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000131","sortNo":82,"contentFormatId":"1","contentTxt":"First, we'll add a test for that behavior:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000132","sortNo":83,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000133","sortNo":84,"contentFormatId":"1","contentTxt":"In this test, we spy on the navigateByUrl method of the MockRouter instance so that when it is called, we can see what it was called with. Next, we call the new displayForm method with an arbitrary ID. Finally we grab the URL from the spy we created and verify that is the expected URL we wanted.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000134","sortNo":85,"contentFormatId":"1","contentTxt":"This test makes use of the inject testing method because it allows us to gain access to the instance of Router being used by the FormListComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000135","sortNo":86,"contentFormatId":"1","contentTxt":"As per usual, at this point, if we run our tests, we'll see failures because there is no displayForm method in the FormListComponent. Let's create one and satisfy the test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000136","sortNo":87,"contentFormatId":"1","contentTxt":"In form-list.component.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000137","sortNo":88,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000138","sortNo":89,"contentFormatId":"1","contentTxt":"The application code here is very simple. First we import the Router, then create a constructor that adds a private class attribute, router, that we then use in our displayForm method to call navigateByUrl.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000139","sortNo":90,"contentFormatId":"1","contentTxt":"<strong>Updating Our Templates</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000140","sortNo":91,"contentFormatId":"1","contentTxt":"For now, we want to use this new component to display our list of forms. So, take the <table> from app.component.html and move it into the template form-list.component.html, which should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000141","sortNo":92,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000142","sortNo":93,"contentFormatId":"1","contentTxt":"And, in app.component.html, replace the table with:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000143","sortNo":94,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000144","sortNo":95,"contentFormatId":"1","contentTxt":"Here, we've added the router-outlet component. This component is provided by the router module. It is the location at which the component associated with the current route will be displayed; in actuality, it places our component right after router-outlet. So, when we navigate to /forms the FormListComponent will be added to the DOM between the router-outlet and the span tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000145","sortNo":96,"contentFormatId":"1","contentTxt":"<strong>Updating the Application Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000146","sortNo":97,"contentFormatId":"1","contentTxt":"We'll also need to pull our new component into the AppModule so that it can be used in our application. In app.module.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000147","sortNo":98,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000148","sortNo":99,"contentFormatId":"1","contentTxt":"<strong>Where's the Data?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000149","sortNo":100,"contentFormatId":"1","contentTxt":"Load up the application with:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000150","sortNo":101,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000151","sortNo":102,"contentFormatId":"1","contentTxt":"And see what the application gives you. You should see the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000152","sortNo":103,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000153","sortNo":104,"contentFormatId":"1","contentTxt":"There are no forms, which is not what we want. This is because we didn't provide FormListComponent with access to the forms from FormService.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000154","sortNo":105,"contentFormatId":"1","contentTxt":"We have been pulling the forms in at the AppComponent level, which is the right way since we want the whole application to have access to the list. However, because getting the lists is an asynchronous operation. If we call the getAllForms method of the FormService from FormListComponent during ngOnInit, we'll get no data because the data loading hasn't completed yet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000155","sortNo":106,"contentFormatId":"1","contentTxt":"So, what can we do? This where the power of RxJS comes into play. RxJS is the JavaScript implementation of the Reactive Extensions library which is used heavily in Angular. Even the HTTP library uses RxJS's Observables to perform server calls.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000156","sortNo":107,"contentFormatId":"1","contentTxt":"If Observables aren't familiar, the quick explanation is that we subscribe to Observables with a function. Whenever the data associated with that Observable updates, our function is called with the updated data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000157","sortNo":108,"contentFormatId":"1","contentTxt":"So, what we'll do is this: create an Observable attribute in the FormService which can be subscribed to for access to the list of forms FormService is keeping track of. Then, we'll subscribe to that Observable in FormListComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000158","sortNo":109,"contentFormatId":"1","contentTxt":"Update services/form.service.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000159","sortNo":110,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000160","sortNo":111,"contentFormatId":"1","contentTxt":"What's changed? We imported RxJS's BehaviorSubject. This allows us to store the forms and publish them to subscribers at the same time. We then change the forms variable to public and create it as a BehaviorSubject with an empty Array by default.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000161","sortNo":112,"contentFormatId":"1","contentTxt":"The setForms method updates forms using its next method, which will store the value and notify any subscribers. Finally, we update getForm so that it uses the value attribute of forms when searching for a form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000162","sortNo":113,"contentFormatId":"1","contentTxt":"This, of course, means we also need to update our unit tests. In the name of brevity, consult the code repository for the updated FormService tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000163","sortNo":114,"contentFormatId":"1","contentTxt":"Changing the behavior of FormService causes a chain reaction where we must also update FormListComponent which requires us to update the unit test for that as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000164","sortNo":115,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000165","sortNo":116,"contentFormatId":"1","contentTxt":"The MockFormService will just allow us to create a fake version of the FormService, similar to how MockRouter works. We stub out the forms attribute so that when FormListComponent is constructed, calling forms.subscribe() doesn't cause an error, but we also keep our unit test from crossing testing boundaries and into FormService.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000166","sortNo":117,"contentFormatId":"1","contentTxt":"Now, we'll need to subscribe to the forms attribute of the FormService in FormListComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000167","sortNo":118,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000168","sortNo":119,"contentFormatId":"1","contentTxt":"When the FormListComponent is constructed, we just subscribe to forms from the formService and when the subscription is updated, we set the component's forms variable to the subscription update.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000169","sortNo":120,"contentFormatId":"1","contentTxt":"Now, if we re-run our application, we should see our forms listed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000170","sortNo":121,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000171","sortNo":122,"contentFormatId":"1","contentTxt":"However, if you click a display button, you'll notice that although the URL updates, you're met with a blank page. This is because we haven't set up our FormViewerComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000172","sortNo":123,"contentFormatId":"1","contentTxt":"<strong>Viewing a Form</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000173","sortNo":124,"contentFormatId":"1","contentTxt":"Setting up the FormViewerComponent will be relatively simple. In the AppComponent we already have the markup for displaying a form. However, the tests for routing will introduce new concepts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000174","sortNo":125,"contentFormatId":"1","contentTxt":"As stated before, the FormViewerComponent is going to need to be able to read the params attribute from the route. What's important to know is that the params attribute is actually an Observable. The way we will grab the ID off of the route is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000175","sortNo":126,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000176","sortNo":127,"contentFormatId":"1","contentTxt":"You may notice that we're calling on this.route, not this.router. This is because the params is a member of the ActivatedRoute class. This class, as its name says, describes the currently active route.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000177","sortNo":128,"contentFormatId":"1","contentTxt":"The selectForm method currently resides in the AppComponent, so we'll move it to the FormViewerComponent. However, first we're going to need to set up the component to work with ActivatedRoute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000178","sortNo":129,"contentFormatId":"1","contentTxt":"In form-viewer.component.spec.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000179","sortNo":130,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000180","sortNo":131,"contentFormatId":"1","contentTxt":"First, note that we've pulled in the sub-components we'll be using, DynamicFormComponent and DynamicQuestionComponent. Since they rely on the ReactiveFormsModule, we also needed to pull that into our tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000181","sortNo":132,"contentFormatId":"1","contentTxt":"With this setup, we control see how ActivatedRoute's behavior. We are going to pull in ActivatedRoute and a mock version of it. An instance of the mock version will be created, which will replace the real ActivatedRoute for our tests. Let's create the mock version of ActivatedRoute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000182","sortNo":133,"contentFormatId":"1","contentTxt":"Create a folder under src called mocks and add a file named activated-route.ts and add the following code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000183","sortNo":134,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000184","sortNo":135,"contentFormatId":"1","contentTxt":"We've created a bare-bones version of the ActivatedRoute class. We're creating a BehaviorSubject, which allows us to update observers by calling its next method. A BehaviorSubject is a special type of RxJS Subject that keeps track of the last value next was called with. It requires an initialization value, so we pass in the public testParams value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000185","sortNo":136,"contentFormatId":"1","contentTxt":"testParams is set up as a getter/setter combo. The getter just returns the private _testParams while the setter sets _testParams and calls paramsSubject.next.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000186","sortNo":137,"contentFormatId":"1","contentTxt":"We also expose a public variable, params, which is just paramsSubject converted to an Observable. This Observable is needed to match the behavior of ActivatedRoute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000187","sortNo":138,"contentFormatId":"1","contentTxt":"Again, this is a pretty minimal mocking out of ActivatedRoute, you can add methods and behavior to this class to suit the needs of a project's testing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000188","sortNo":139,"contentFormatId":"1","contentTxt":"Back in form-viewer.component.spec.ts, we can now create tests to see if our component works with the params of ActivatedRoute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000189","sortNo":140,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000190","sortNo":141,"contentFormatId":"1","contentTxt":"We've now moved the component creation out of a beforeEach and into a function. We do this because we want to be able to do specific test steps before the component is created, such as setting the id parameter attribute of our activeRoute, as is being done in our test. Notice that we're calling fixture.detectChanges(). Doing this after we create our component is like calling ngOnInit, which we'll need to do to get our ID parameter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000191","sortNo":142,"contentFormatId":"1","contentTxt":"We also inject the FormService into our new test so we can get a hold of the instance. We then spy on its getForm method. Using the logic from before, when the route changes, it will call a private selectForm method on the FormViewerComponent which will, in turn call FormService.getForm.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000192","sortNo":143,"contentFormatId":"1","contentTxt":"Before the component is created, however, we call formService.forms.next. This may seem odd, but we do this so that, when a user navigates to a route directly (i.e., they type in the URL), the application waits for the forms of the FormService to be loaded before trying to call getForm.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000193","sortNo":144,"contentFormatId":"1","contentTxt":"Let's satisfy this test. In form-viewer.component.ts, add replace it with the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000194","sortNo":145,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000195","sortNo":146,"contentFormatId":"1","contentTxt":"We're now importing OnInit from Angular, as well as the ActivatedRoute. We also pull in our FormService. In the constructor of our component we pull in the instances of FormService and ActivatedRoute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000196","sortNo":147,"contentFormatId":"1","contentTxt":"Our FormViewerComponent now implements OnInit. Remember that OnInit means that we need a public ngOnInit method on our class, which will be called on the first change detection cycle. This is why we called on fixture.detectChanges() in our spec file.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000197","sortNo":148,"contentFormatId":"1","contentTxt":"In ngOnInit we first subscribe to the forms from FormService. Once we know the forms are loaded in FormService, we start checking for changes to params of the ActivatedRoute instance. If params does change (i.e. the ID value changes), we'll map the id value out of params and ensure it's an integer. That value is then sent to forEach where we call the private selectForm method with the id.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000198","sortNo":149,"contentFormatId":"1","contentTxt":"In turn, selectForm calls FormService.getForm with the id, satisfying our test. We also added a check to ensure that the component's form value only gets set when getForm returns a valid form. If not, our template would try to access attributes on a null form. When there is no returned form, we set form to a blank FormData object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000199","sortNo":150,"contentFormatId":"1","contentTxt":"We've successfully tested a routed component with parameters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000200","sortNo":151,"contentFormatId":"1","contentTxt":"Finally, to get it visibly working:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000201","sortNo":152,"contentFormatId":"1","contentTxt":"Copy the remaining non-router-outlet code from app.component.html and paste it into the file form-viewer.component.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000202","sortNo":153,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000203","sortNo":154,"contentFormatId":"1","contentTxt":"Note that selectedForm has been changed to just form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000204","sortNo":155,"contentFormatId":"1","contentTxt":"We've removed the span wrapper which AppComponent needed and added a link after the form to get us back to the list of forms. Notice that we do not use an href on our link. We use the Angular directive for binding to a route, routerLink. Using routerLink could be a post of its own, so for more information, see the Angular documentation on routing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000205","sortNo":156,"contentFormatId":"1","contentTxt":"<strong>Run the Application</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000206","sortNo":157,"contentFormatId":"1","contentTxt":"We are now ready to see the fruits of our labor. Open a shell/terminal and run:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000207","sortNo":158,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000208","sortNo":159,"contentFormatId":"1","contentTxt":"Navigate to http://localhost:9000 and your screen should look something like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000209","sortNo":160,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000210","sortNo":161,"contentFormatId":"1","contentTxt":"If you click a \"Display\" button, you should see something like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000211","sortNo":162,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201703080000000212","sortNo":163,"contentFormatId":"1","contentTxt":"This looks pretty much like our last application, but if you look at the URLs, you can see the router at work. In our previous application, the URL was always set to http://localhost:9000. However, now the default URL is http://localhost:9000/forms and, when a form is displayed, the URL is something like http://localhost:9000/form/1!","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201612120000000001","sortNo":1,"contentFormatId":"1","contentTxt":"When I first learned Promises, I thought they were hard to understand. Then, when I started looking into Angular 2, I had to learn about RxJS and Observable sequences of data. And, to be honest, RxJS kind of makes Promises look like child's play. Even after almost a year of Angular 2 research, I'm barely capable with RxJS streams. In fact, I've even been told on good authority that I'm downright wrong in some of my thinking. Just this morning, while showering, I realized that I didn't even know how to perform the RxJS equivalent of Promise.all(). So, this morning, I tried to sit down and figure it out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000002","sortNo":2,"contentFormatId":"1","contentTxt":"With Promises, there are only a few core concepts. With RxJS, there are many core concepts that power a vast number of core operators, which can be forever expanded upon by user land. So, while there's only one Promise.all(), there seems to be several RxJS operators that can achieve the same thing depending on the type of streams being used.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000003","sortNo":3,"contentFormatId":"1","contentTxt":"The RxJS operator that appears to be the most feature-compatible with Promise.all() is .forkJoin(). The .forkJoin() operator runs a collection of sequences of Promises in parallel, waits for them all to complete, and then emits a value composing the last emitted value from each stream.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000004","sortNo":4,"contentFormatId":"1","contentTxt":"But, depending on the number of values that you expect from a given set of streams, the .combineLatest() and .zip() operators may produce the same result. The .combineLatest() operator will emit a composite value of each stream's latest value; and, it will emit a new value any time each of the underlying streams emits a value. The .zip() operator is similar to the .combineLatest() operator; but, it appears to buffer the results of the underlying streams, only zipping-together values at the same emit-index.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000005","sortNo":5,"contentFormatId":"1","contentTxt":"To experiment with these RxJS operators, I tried to aggregate the results of four different asynchronous operations. Three of them are Promises and one of them is a range stream. I used a range stream to see how these various operators behaved when multiple values were emitted.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000006","sortNo":6,"contentFormatId":"1","contentTxt":"I also run the tests twice, once with a range-stream delay and once without. Unlike Promises, which are always asynchronous, RxJS streams are inconsistently asynchronous. As such, I wanted to see what happened when the range-stream completed both before and after the promises.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000007","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000008","sortNo":8,"contentFormatId":"1","contentTxt":"In each case, I use the same operator with both raw Promises and with proxied streams. This was done more for my own learning - to see which operators can work with either Promises or streams.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000009","sortNo":9,"contentFormatId":"1","contentTxt":"When we run the above code, we get the following output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000010","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000011","sortNo":11,"contentFormatId":"1","contentTxt":"As you can see, the .forkJoin() operator was the only operator that consistently produced the same value as the Promise.all() control group. That said, the .combineLatest() operator also produced the same result in some circumstances. And, in fact, if all streams in question only produce one value, even more of the operators produce the same result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Imagine that this is an aggregation of HTTP requests that will only produce one value - let's look at what happens when we replace:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Rx.Observable.range( 1, 4 )  ... with: Rx.Observable.of( 4 )","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000014","sortNo":14,"contentFormatId":"1","contentTxt":"In this case, each of the four streams will only emit a single value. And, when we run this version of the code, we get the following output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Now, things are very different. In this case, when each underlying stream only emits a single value, the .forkJoin(), .combineLatest(), and .zip() operators all produce the same result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000017","sortNo":17,"contentFormatId":"1","contentTxt":"So, which operator should you use if you want to perform the RxJS equivalent of Promise.all()? The answer isn't clear. You may look at these results and say that .forkJoin() is the \"right\" one because it is the most consistent. But, is it really? Meaning, in a Promise.all() aggregation, each Promise can only ever produce one value. So, if we're looking for an RxJS equivalent, it only makes sense that we deal with streams that will only ever produce one value (such as an Http stream). And, in that case, I don't see any real difference in intent between the three operators that all produce the same result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000018","sortNo":18,"contentFormatId":"1","contentTxt":"Promises are hard. RxJS is moar harder and then some. And, as it turns out, there's usually a number of seemingly \"right\" ways to accomplish the same thing. In the case of creating an RxJS equivalent to Promise.all(), it seems that there are three operators - .forkJoin(), .combineLatest(), and .zip() - that will all produce the desired result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612120000000019","sortNo":19,"contentFormatId":"1","contentTxt":"Of course, as I said above, I'm a total novice when it comes to RxJS, so I may be missing some fundamental difference between the intent of the various operators. Take caution!","contentBinary":"","contentPoster":"","contentUrl":null}]
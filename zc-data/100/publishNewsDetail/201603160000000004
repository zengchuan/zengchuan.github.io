[{"id":"201603160000000282","sortNo":1,"contentFormatId":"1","contentTxt":"When I first started digging into Angular 2's Http client, I felt that a lot of the great Angular 1.x features were sorely missing. Features like automatic JSON (JavaScript Object Notation) parsing, request / response interceptors, and XSRF (Cross-Site Request Forgery) protection, to name a few. In a recent GitHub issue, Jeff Cross talks about why the Angular team kept the Http client so generic. And, at first, I completed disagreed with the mindset. But, after I've had some time to reflect on the matter, I have to say, I really like the decision that they made. It does make setting up an Http client a little more challenging; but, it puts you, as the developer, in total control over the way data flows into and out of a remote API. And, you never have to worry about messing up some other module's configuration; or, having some other module mess up your requests. In the end, it feels like this approach makes every aspect of an HTTP call much safer and easier to reason about.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000283","sortNo":2,"contentFormatId":"1","contentTxt":"Every API has different constraints and expectations. Some use JSON, others use SOAP or XML. Some return their data in a response envelope, others return a naked response value. Some require basic authentication or an API key, others can be used anonymously. The point is, there's no \"one size fits all\" for API interactions. And, this is just as true for the consuming context. As such, it makes sense to create a specialized HTTP client to act as the HTTP gateway to a given API.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000284","sortNo":3,"contentFormatId":"1","contentTxt":"In the abstract, this sounds like a lot of work. It's easy to conjure up the image of creating dozens of specialized HTTP clients. But, in reality, this is not the case. In reality, you probably only talk to one or two APIs from a client-side application. And, in reality, the only API that has any real constraints is likely the one that you are providing to your own single-page application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000285","sortNo":4,"contentFormatId":"1","contentTxt":"So, let's take a look at what a non-trivial specialized HTTP client might look like. In this demo, I'm going to try and create an ApiGateway service which is an HTTP implementation used specifically to talk to my own application's API. As a feature set I would like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000286","sortNo":5,"contentFormatId":"1","contentTxt":"1. Encapsulation of the HTTP transportation mechanism (including Content-Type headers).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000287","sortNo":6,"contentFormatId":"1","contentTxt":"2. Param and Data driven URL interpolation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000288","sortNo":7,"contentFormatId":"1","contentTxt":"3. Automatic JSON serialization for outgoing requests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000289","sortNo":8,"contentFormatId":"1","contentTxt":"4. Automatic JSON parsing for incoming responses.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000290","sortNo":9,"contentFormatId":"1","contentTxt":"5. Normalized error responses.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000291","sortNo":10,"contentFormatId":"1","contentTxt":"6. XSRF (Cross-Site Request Forgery) protection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000292","sortNo":11,"contentFormatId":"1","contentTxt":"7. Pending request tracking.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000293","sortNo":12,"contentFormatId":"1","contentTxt":"8. Explicit handling of certain HTTP response codes (ex, 401 Unauthorized).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000294","sortNo":13,"contentFormatId":"1","contentTxt":"Most of these features feel like they are directly related to how HTTP requests are made. All except for the last one. Responding to a specific type of HTTP status code feels like it's overloading the ApiGateway a little too much. Such logic feels like it should be slightly more external. As such, in my approach, rather than having the ApiGateway react to HTTP status codes, it simply exposes an \"errors\" RxJS stream. Then, anything in the application can subscribe to this error stream and implement additional reactive logic.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000295","sortNo":14,"contentFormatId":"1","contentTxt":"In the end, my demo architecture looks a little bit like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000296","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000297","sortNo":16,"contentFormatId":"1","contentTxt":"My ApiGateway exposes the following public API:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000298","sortNo":17,"contentFormatId":"1","contentTxt":"1. errors - An RxJS observable emitting HTTP errors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000299","sortNo":18,"contentFormatId":"1","contentTxt":"2. pendingCommands - An RxJS observable emitting the number of pending \"command\" (ie, non-GET) requests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000300","sortNo":19,"contentFormatId":"1","contentTxt":"3. get() - A method for making GET requests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000301","sortNo":20,"contentFormatId":"1","contentTxt":"4. post() - A method for making POST requests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000302","sortNo":21,"contentFormatId":"1","contentTxt":"5. request() - A more generic request method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000303","sortNo":22,"contentFormatId":"1","contentTxt":"At the moment we have a very simple AppComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000304","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000305","sortNo":24,"contentFormatId":"1","contentTxt":"We'll be updating that as we go along. We also have a simple main.ts file that bootstraps everything:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000306","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000307","sortNo":26,"contentFormatId":"1","contentTxt":"Add ApiGateway class","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000308","sortNo":27,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000309","sortNo":28,"contentFormatId":"1","contentTxt":"A couple things to note include:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000310","sortNo":29,"contentFormatId":"1","contentTxt":"1. Always annotate your services with @Injectable() ... and don't forget the trailing parentheses!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000311","sortNo":30,"contentFormatId":"1","contentTxt":"2. To use rxjs operators (map, catch, finally, etc) you need to import them!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000312","sortNo":31,"contentFormatId":"1","contentTxt":"3. Some folks like to append $ to the name of observable streams to help identify the property as something you can subscribe to. I followed that convention here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000313","sortNo":32,"contentFormatId":"1","contentTxt":"4. With typescript you can easily mark class properties or methods as private to hide them","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000314","sortNo":33,"contentFormatId":"1","contentTxt":"5. I try to avoid it where I can, but the any type can be your friend when you don't know what type something is (even if it's when you're first writing some code)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000315","sortNo":34,"contentFormatId":"1","contentTxt":"Once we have this class in place we need to add it as a provider, and to do so we'll update the code to bootstrap the app in main.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000316","sortNo":35,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000317","sortNo":36,"contentFormatId":"1","contentTxt":"Note we also need to add in the HTTP_PROVIDERS so that the ApiGateway can have its constructor agruments injected.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000318","sortNo":37,"contentFormatId":"1","contentTxt":"Adding in the FriendService","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000319","sortNo":38,"contentFormatId":"1","contentTxt":"Now the FriendService uses the ApiGateway for the heavy lifting, so it's not quite as complex:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000320","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000321","sortNo":40,"contentFormatId":"1","contentTxt":"Here we define the Friend class, and basically have the same code as Ben's javascript version. Now we need to make a similar update again to main.ts to set up the provider for the this service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000322","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000323","sortNo":42,"contentFormatId":"1","contentTxt":"Update the main AppComponent","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000324","sortNo":43,"contentFormatId":"1","contentTxt":"Now we have the services we need to support the top-level app component. Here's what that component looks like after we convert it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000325","sortNo":44,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000326","sortNo":45,"contentFormatId":"1","contentTxt":"Since we have already set up the providers for the two services we're injecting here there's no updates to main.ts required to get this component working properly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000327","sortNo":46,"contentFormatId":"1","contentTxt":"Adding in the HTTP error handler","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000328","sortNo":47,"contentFormatId":"1","contentTxt":"The final bit of Ben's demo is his exploration of services that should be created, but are not explicitly used by any components within the application. Now even though this class isn't injected into any components, it is injected so we need to create it just like the other services:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000329","sortNo":48,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000330","sortNo":49,"contentFormatId":"1","contentTxt":"Once we have that service in place, we need to update the main.ts file one last time to pull in the following items:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000331","sortNo":50,"contentFormatId":"1","contentTxt":"1. The provide() function so we can set the actions associated with APP_INITIALIZER (here's a nice Throughtram article on DI)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000332","sortNo":51,"contentFormatId":"1","contentTxt":"2. The HttpErrorHandler class we just created","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000333","sortNo":52,"contentFormatId":"1","contentTxt":"With those changes here's the final version of main.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000334","sortNo":53,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000335","sortNo":54,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000336","sortNo":55,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/sstorie/experiments/tree/master/nadel-api-gateway-ts\">https://github.com/sstorie/experiments/tree/master/nadel-api-gateway-ts</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
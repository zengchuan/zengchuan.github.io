[{"id":"201512280000000011","sortNo":1,"contentFormatId":"1","contentTxt":"Using mutable objects for modeling application state makes tracking changes hard and incurs a sizable performance cost. Switching to immutable objects solves these problems, but brings new ones. This is because immutability and encapsulation are often at odds. Can we combine the benefits of immutability and local state? In this article I will explore how it can be done in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000012","sortNo":2,"contentFormatId":"1","contentTxt":"PROBLEMS WITH MUTABLE OBJECTS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000013","sortNo":3,"contentFormatId":"1","contentTxt":"TRACKING CHANGES","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000014","sortNo":4,"contentFormatId":"1","contentTxt":"Mutable objects make it hard to keep track of changes in an application. To see why this is true, let¡¯s look at this component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000015","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000016","sortNo":6,"contentFormatId":"1","contentTxt":"Let¡¯s say we want the component to look up and display the zip code of the address. And to make it more interesting, this lookup is expensive, so we want to do it only when the address changes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000017","sortNo":7,"contentFormatId":"1","contentTxt":"In Angular 2, components can subscribe to the onChanges lifecycle hook, which will be called when any of the inputs change. We can put the logic of calculating the zip code into this hook.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000018","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000019","sortNo":9,"contentFormatId":"1","contentTxt":"If the address object is mutable, some other component can update the street property without creating a new address object. If this happens, the onChanges hook won¡¯t be called, and a wrong zip code will be displayed. There are, of course, ways to work around it. But the problem remains ¨C we have to be deeply aware of how and when the address object can change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000020","sortNo":10,"contentFormatId":"1","contentTxt":"PERFORMANCE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000021","sortNo":11,"contentFormatId":"1","contentTxt":"Let¡¯s go back to this component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000022","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000023","sortNo":13,"contentFormatId":"1","contentTxt":"What does this component depend upon? Well, it depends on the person and address objects. But if these objects are mutable, this does not tell as much. Since they can be updated by any component or service at any time, the DisplayPerson component can be affected by any other component or service. That is why, by default, Angular does not make any assumptions about what a component depends upon. So it has be conservative and check DisplayPerson¡¯s template on every browser event. Since the framework has to do it for every component, it can become a performance problem.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000024","sortNo":14,"contentFormatId":"1","contentTxt":"TWO PROBLEMS WITH MUTABLE OBJECTS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000025","sortNo":15,"contentFormatId":"1","contentTxt":"To sum up, these are the problems with mutable domain objects:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000026","sortNo":16,"contentFormatId":"1","contentTxt":"1. They make tracking changes hard, both for the developer and the framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000027","sortNo":17,"contentFormatId":"1","contentTxt":"2. They force Angular to be conservative by default, which negatively affects performance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000028","sortNo":18,"contentFormatId":"1","contentTxt":"USING IMMUTABLE OBJECTS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000029","sortNo":19,"contentFormatId":"1","contentTxt":"Modeling application state using immutable objects solves these problems. If both person and address are immutable, we can tell a lot more about when the DisplayPerson component can change. The component can change if and only if any of its inputs changes. And we can communicate it to Angular by setting the change detection strategy to OnPush.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000030","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000031","sortNo":21,"contentFormatId":"1","contentTxt":"Using this change-detection strategy restricts when Angular has to check for updates from ¡°any time something might change¡± to ¡°only when this component¡¯s inputs have changed¡±. As a result, the framework can be a lot more efficient about detecting changes in DisplayPerson. If no inputs change, no need to check the component¡¯s template. Perfect! Immutable objects are awesome!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000032","sortNo":22,"contentFormatId":"1","contentTxt":"HOW TO USE IMMUTABLE OBJECTS IN JS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000033","sortNo":23,"contentFormatId":"1","contentTxt":"As usual, there are trade-offs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000034","sortNo":24,"contentFormatId":"1","contentTxt":"Modeling application state using exclusively immutable objects requires pushing the state management out of the component tree. Think about it. Since address is immutable, we cannot update its street property in place. Instead, we have to create a new address object. Say this address is stored in some PersonRecord object. Since that object is immutable too, we will have to create a new PersonRecord object. Therefore, the whole application state will have to be updated if we change the street property of the address.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000035","sortNo":25,"contentFormatId":"1","contentTxt":"There are many ways to organize the application state, but for simplicity let¡¯s assume it is stored in a single data structure. Although it may look scary at first, this setup actually provides a lot of benefits: we can serialize the state of the whole application, inspect it, etc.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000036","sortNo":26,"contentFormatId":"1","contentTxt":"So we decided to remove all local mutable state from our components. But since the state is there for a reason, we cannot just remove it ¨C we need to move it somewhere. The only place to move it to is the application state object. This means that some state that previously would have been encapsulated, becomes public. Let¡¯s look at an example illustrating this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000037","sortNo":27,"contentFormatId":"1","contentTxt":"Say we have a typeahead component that we can use like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000038","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000039","sortNo":29,"contentFormatId":"1","contentTxt":"And this is a sketch of the component¡¯s class:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000040","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000041","sortNo":31,"contentFormatId":"1","contentTxt":"This is just the public interface of this component. In practice, the typeahead component will have a lot more going on. For example, it might store some scrolling position, which can only be updated by events triggered in typeahead.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000042","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000043","sortNo":33,"contentFormatId":"1","contentTxt":"The scrolling position is internal to typeahead. No client of the component has to know the property is even there.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000044","sortNo":34,"contentFormatId":"1","contentTxt":"Completely disallowing local mutable state will mean that the scrolling position will have to be stored in the application state object. Suddenly, the client now has to know that the scrolling position is there. We need to pass it in and out. This isn¡¯t ideal from the dev ergonomics standpoint. But what is even more important, it makes the component less reusable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000045","sortNo":35,"contentFormatId":"1","contentTxt":"In summary, removing mutable state simplifies tracking changes in the application and makes the application more performant. But at the same time it breaks the encapsulation of components, and their implementation details start to leak out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000046","sortNo":36,"contentFormatId":"1","contentTxt":"GETTING THE BEST OF BOTH WORLDS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000047","sortNo":37,"contentFormatId":"1","contentTxt":"Instead of abolishing mutable state all together, let¡¯s just scope it to a component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000048","sortNo":38,"contentFormatId":"1","contentTxt":"1. Application state that is passed around is modeled using immutable objects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000049","sortNo":39,"contentFormatId":"1","contentTxt":"2. Components can have local state that can only be updated when their inputs change or an event is emitted in their templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000050","sortNo":40,"contentFormatId":"1","contentTxt":"So we allow mutable state, but in a very scoped form. Let¡¯s look at how this setup compare to the previous one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000051","sortNo":41,"contentFormatId":"1","contentTxt":"TRACKING CHANGES","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000052","sortNo":42,"contentFormatId":"1","contentTxt":"Since inputs are immutable, an input has to be replaced to affect a component. And we can track changes to local state properties just by looking at the component¡¯s onChanges hook and event handlers. Nothing outside the component can change them in any way. This is a good result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000053","sortNo":43,"contentFormatId":"1","contentTxt":"PERFORMANCE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000054","sortNo":44,"contentFormatId":"1","contentTxt":"This setup works for us, but it also works for Angular. The framework will check OnPush components only when their inputs change or components¡¯ templates emit events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000055","sortNo":45,"contentFormatId":"1","contentTxt":"ENCAPSULATION","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000056","sortNo":46,"contentFormatId":"1","contentTxt":"And we did not break the component¡¯s encapsulation. In the typeahead example, the scrolling position is private to the component. So the client using it does not need to know that the property event exists.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000057","sortNo":47,"contentFormatId":"1","contentTxt":"But we lost something too. The application state is no longer stored in our place. As a result, the precise control over all mutations is no longer there. An this, for instance, can have a negative impact on tooling.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000058","sortNo":48,"contentFormatId":"1","contentTxt":"BE PRAGMATIC","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000059","sortNo":49,"contentFormatId":"1","contentTxt":"We often contrast the ¡°everything-is-mutable¡± with ¡°everything-is-a-pure-function¡± styles of programmings. In this article I showed that both of these have pros and cons, and that there are pragmatic options in between the two extremes that you can consider.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000060","sortNo":50,"contentFormatId":"1","contentTxt":"SUMMARY","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000061","sortNo":51,"contentFormatId":"1","contentTxt":"1. Using mutable objects for modeling application state has a negative impact on performance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000062","sortNo":52,"contentFormatId":"1","contentTxt":"2. It also makes tracking changes really hard.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000063","sortNo":53,"contentFormatId":"1","contentTxt":"3. Switching to immutable objects for modeling application state solves these problems.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000064","sortNo":54,"contentFormatId":"1","contentTxt":"4. Keeping scoped mutable state in components preserves most of the benefits of using immutable objects without breaking encapsulation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201512280000000065","sortNo":55,"contentFormatId":"1","contentTxt":"5. To enable that use ChangeDetectionStrategy.OnPush.","contentBinary":"","contentPoster":"","contentUrl":null}]
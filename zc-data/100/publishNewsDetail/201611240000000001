[{"id":"201611240000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In a contacts application where we’re able to click on a contact to view a contact’s details, the contact data should’ve been loaded before the component we’re routing to is instantiated, otherwise we might end up with a UI that already renders its view and a few moments later, the actual data arrives (of course, there are many ways to get around this). Route resolvers allow us to do exactly that and in this article we’re going to explore how they work!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000002","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Understanding the problem</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Let’s just stick with the scenario of a contacts application. We have a route for a contacts list, and a route for contacts details. Here’s what the route configuration might look like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000005","sortNo":5,"contentFormatId":"1","contentTxt":"And of course, we use that configuration to configure the router for our application:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000006","sortNo":6,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000007","sortNo":7,"contentFormatId":"1","contentTxt":"Nothing special going on here. However, if this is all new to you, you might want to read our article on routing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000008","sortNo":8,"contentFormatId":"1","contentTxt":"Let’s take a look at the ContactsDetailComponent. This component is responsible of displaying contact data, so it somehow has to get access to a contact object, that matches the id provided in the route URL (hence the :id parameter in the route configuration). In our article on routing in Angular 2, we’ve learned that we can easily access route parameters using the ActivatedRoute like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000009","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Okay, cool. So the only thing ContactsDetailComponent does, is to fetch a contact object by the given id and assign that object to its local contact property, which then allows us to interpolate expressions like {{contact.name}} in the template of the component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000011","sortNo":11,"contentFormatId":"1","contentTxt":"Let’s take a look at the component’s template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000012","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Notice that we’ve attached Angular’s Safe Navigation Operator to all of our expressions that rely on contact. The reason for that is, that contact will be undefined at the time this component is initialized, since we’re fetching the data asynchronously. The Safe Navigation Operator ensures that Angular won’t throw any errors when we’re trying to read from an object that is null or undefined.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000014","sortNo":14,"contentFormatId":"1","contentTxt":"In order to demonstrate this issue, let’s assume ContactsService#getContact() takes 3 seconds until it emits a contact object. In fact, we can easily fake that delay right away like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Depending on our template, adding Safe Navigation Operators everywhere can be quite tiring as well. In addition to that, some constructs don’t support that operator, like NgModel and RouterLink directives. Let’s take a look at how we can solve this using route resolvers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000017","sortNo":17,"contentFormatId":"1","contentTxt":"<strong>Defining resolvers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000018","sortNo":18,"contentFormatId":"1","contentTxt":"As mentioned ealier, route resolvers allow us to provide the needed data for a route, before the route is activated. There are different ways to create a resolver and we’ll start with the easiest: a function. A resolver is a function that returns either Observable<any>, Promise<any> or just data. This is great, because our ContactsService#getContact() method returns an Observable<Contact>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000019","sortNo":19,"contentFormatId":"1","contentTxt":"Resolvers need to be registered via providers. Our article on Dependency Injection in Angular 2 explains nicely how to make functions available via DI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000020","sortNo":20,"contentFormatId":"1","contentTxt":"Here’s a resolver function that resolves with a static contact object:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000021","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000022","sortNo":22,"contentFormatId":"1","contentTxt":"Let’s ignore for a second that we don’t always want to return he same contact object when this resolver is used. The point here is that we can register a simple resolver function using Angular’s dependency injection. Now, how do we attach this resolver to a route configuration? That’s pretty straight forward. All we have to do is add a resolve property to a route configuration, which is an object where each key points to a resolver.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000023","sortNo":23,"contentFormatId":"1","contentTxt":"Here’s how we add our resolver function to our route configuration:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000024","sortNo":24,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000025","sortNo":25,"contentFormatId":"1","contentTxt":"That’s it? Yes! 'contact' is the provider token we refer to when attaching resolvers to route configurations. Of course, this can also be an OpaqueToken, or a class (as discussed later).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000026","sortNo":26,"contentFormatId":"1","contentTxt":"Now, the next thing we need to do is to change the way ContactsDetailComponent gets hold of the contact object. Everything that is resolved via route resolvers is exposed on an ActivatedRoute’s data property. In other words, for now we can get rid of the ContactsService dependency like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000027","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000028","sortNo":28,"contentFormatId":"1","contentTxt":"In fact, when defining a resolver as a function, we get access to the ActivatedRouteSnapshot, as well as the RouterStateSnapshot like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000029","sortNo":29,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000030","sortNo":30,"contentFormatId":"1","contentTxt":"This is useful in many scenarios where we need access to things like router parameters, which we actually do. However, we also need a ContactsService instance, which we don’t get injected here. So how do we create resolver that need dependency injection?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000031","sortNo":31,"contentFormatId":"1","contentTxt":"<strong>Resolvers with dependencies</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000032","sortNo":32,"contentFormatId":"1","contentTxt":"As we know, dependency injection works on class constructors, so what we need is a class. We can create resolvers as classes as well! The only thing we need to do, is to implement the Resolve interface, which ensures that our resolver class has a resolve() method. This resolve() method is pretty much the same function we have currently registered via DI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000033","sortNo":33,"contentFormatId":"1","contentTxt":"Here’s what our contact resolver could look like as a class implementation:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000034","sortNo":34,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000035","sortNo":35,"contentFormatId":"1","contentTxt":"As soon as our resolver is a class, our provider configuration becomes simpler as well, because the class can be used as provider token!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000036","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000037","sortNo":37,"contentFormatId":"1","contentTxt":"And of course, we use the same token to configure the resolver on our routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000038","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000039","sortNo":39,"contentFormatId":"1","contentTxt":"Angular is smart enough to detect if a resolver is a function, or a class and if it’s a class, it’ll call resolve() on it. Check out the demo below to see this code in action and note how Angular delays the component instantiation until the data has arrived.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611240000000040","sortNo":40,"contentFormatId":"1","contentTxt":"Hopefully this gave you a better idea of how route resolvers in Angular 2 work!","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201607070000000001","sortNo":1,"contentFormatId":"1","contentTxt":"At the core of the Angular router lies a powerful URL matching engine, which transforms URLs and converts them into router states.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000002","sortNo":2,"contentFormatId":"1","contentTxt":"In this article I will show how to use three of the engine’s features: empty-path routes, componentless routes, and redirects. And how using them together, we can implement advanced patterns in just a few lines of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Empty-Path Routes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Let’s start with this configuration.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000005","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000006","sortNo":6,"contentFormatId":"1","contentTxt":"When navigating to ’/team/11/user/bob’, the router will instantiate the team component with the user component in it. And when navigating to ’/team/11/users’, the router will show the list of all users. This configuration works. But a more common way of doing this would be to render the list when navigating to /team/11. That’s what empty-path routes are for.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000007","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000008","sortNo":8,"contentFormatId":"1","contentTxt":"By setting ‘path’ to an empty string, we can create a route that instantiates a component but does not “consume” any URL segments.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000009","sortNo":9,"contentFormatId":"1","contentTxt":"There is nothing really special about such a route. For instance, as any other route, it can have children.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000010","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000011","sortNo":11,"contentFormatId":"1","contentTxt":"In this example, when navigating to ’/team/11/user/jim’, the router will instantiate the wrapper component with UserComponent in it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000012","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Matching Strategies and Redirects</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000013","sortNo":13,"contentFormatId":"1","contentTxt":"To understand the second feature, let’s step back to think about how the router does matching. The router takes an array of routes and a URL, and tries to create a RouterState.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000014","sortNo":14,"contentFormatId":"1","contentTxt":"Let’s imagine we have this configuration, and we are navigating to ’/team/11/user/jim’.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000016","sortNo":16,"contentFormatId":"1","contentTxt":"The router will go through the array of routes, which in this case there is only one, and it will check if the URL starts with the route’s path. Here it will check that ’/team/11/user/jim’ starts with 'team/:id’. Because it matches, the router will carry on matching by taking what is left in the URL and the matched route’s children. If the taken path through the configuration does not “consume” the whole url, the router backtracks to try an alternative path.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000017","sortNo":17,"contentFormatId":"1","contentTxt":"The default matching strategy is called 'prefix’ because a match is successful when a route’s path is the prefix of what is left in the URL. We can set the strategy explicitly, as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000018","sortNo":18,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000019","sortNo":19,"contentFormatId":"1","contentTxt":"The router supports a second matching strategy–full, which checks that the path is “equal” to what is left in the URL. This is mostly important for redirects. To see why, let’s look at the this example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000020","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000021","sortNo":21,"contentFormatId":"1","contentTxt":"Most likely your intent is to render the Teams component when navigating to ’/teams’, and redirect to ’/teams’ when navigating to ’/’. But since the default matching strategy is 'prefix’, and an empty string is a prefix of any URL, the router will apply the redirect even when we are navigating to ’/teams’. Now, if we change the matching strategy to 'full’, the router will apply the redirect only when navigating to ’/’.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000022","sortNo":22,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000023","sortNo":23,"contentFormatId":"1","contentTxt":"<strong>Absolute Redirects</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000024","sortNo":24,"contentFormatId":"1","contentTxt":"If the 'redirectTo’ value starts with a ’/’, then it is an absolute redirect. The next example shows the difference between relative and absolute redirects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000025","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000026","sortNo":26,"contentFormatId":"1","contentTxt":"When navigating to ’/team/11/legacy/user/jim’, the router will apply the second redirect and will change the URL to ’/team/11/user/jim’. In other words, the part of the URL corresponding to the matched path will be replaced. But navigating to ’/team/11/org/eng’ will replace the whole URL with ’/org/eng’.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000027","sortNo":27,"contentFormatId":"1","contentTxt":"<strong>Componentless Routes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000028","sortNo":28,"contentFormatId":"1","contentTxt":"It is often useful to share parameters between sibling components. In this example we have two components–TeamListComponent and TeamDetailsComponent–that we want to put next to each other, and both of them require the team id parameter. TeamListComponent uses the id to highlight the selected team, and TeamDetailsComponent uses it to show the information about the team.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000029","sortNo":29,"contentFormatId":"1","contentTxt":"One way to model that would be to create a bogus parent component, which both TeamListComponent and TeamDetailsComponent can get the id parameter from, i.e. we can model this solution with the following configuration:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000030","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000031","sortNo":31,"contentFormatId":"1","contentTxt":"With this configuration in place, navigating to ’/team/11’ will result in this component tree:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000032","sortNo":32,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000033","sortNo":33,"contentFormatId":"1","contentTxt":"This solution has two problems. First, we need to create the team parent component, which serves no real purpose. Second, TeamListComponent and TeamDetailsComponent have to access the id parameter through the parent, which makes them less reusable. Because this use case is so common, the router supports a feature called componentless routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000034","sortNo":34,"contentFormatId":"1","contentTxt":"Componentless routes “consume” URL segments without instantiating components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000035","sortNo":35,"contentFormatId":"1","contentTxt":"Let’s change the 'team/:id’ route to make it Componentless.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000036","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000037","sortNo":37,"contentFormatId":"1","contentTxt":"Now, when navigating to ’/team/11’, the router will create the following component tree:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000038","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000039","sortNo":39,"contentFormatId":"1","contentTxt":"Why is this better? First of all, we’ve gotten rid of the bogus component. Second, since there is no component associated with the ’/team/:id’ route, the router will merge its params, data, and resolve into the children. As a result, TeamListComponent and TeamDetailsComponent can access the id parameter directly, without going through the parent route.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000040","sortNo":40,"contentFormatId":"1","contentTxt":"<strong>Composing Empty-Path Routes, Componentless Routes, and Redirects</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000041","sortNo":41,"contentFormatId":"1","contentTxt":"What is really exciting about all these features is that they compose very nicely. And we can use them together to implement advanced patterns in just a few lines of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000042","sortNo":42,"contentFormatId":"1","contentTxt":"Let me give you an example. We’ve learned that we can use empty-path routes to instantiate components without consuming any URL segments, and we can use Componentless routes to consume URL segments without instantiating components. What about combining them?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000043","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000044","sortNo":44,"contentFormatId":"1","contentTxt":"Here we’ve defined a route that neither consumes any URL segments nor creates any components, but used merely for running guards and fetching data that will be used by boths TeamsComponent and OrgsComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Next example, although contrived, shows how we can use the three features to implement interesting URL transformations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000046","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607070000000047","sortNo":47,"contentFormatId":"1","contentTxt":"With this configuration in place, the navigation to 'team/11’ will result in 'team/11/(list/default//aux:details).","contentBinary":"","contentPoster":"","contentUrl":null}]
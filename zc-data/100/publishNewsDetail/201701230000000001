[{"id":"201701230000000001","sortNo":1,"contentFormatId":"1","contentTxt":"This is the third post in the Essential Angular series, which aims to be a short, but at the same time, fairly complete overview of the key aspects of Angular. In this post I’ll cover components and directives.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000002","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000005","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000006","sortNo":6,"contentFormatId":"1","contentTxt":"To build an Angular application you define a set of components, for every UI element, screen, and route. An application will always have root components (usually just one) that contain all other components. To make things simpler, in this post let’s assume the application has a single root component, and thus our Angular application will have a component tree, that may look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000007","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000008","sortNo":8,"contentFormatId":"1","contentTxt":"AppCmp is the root component. The FiltersCmp component has the speaker input and the filter button. TalksCmp is the list you see at the bottom. And TalkCmp is an item in that list.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000009","sortNo":9,"contentFormatId":"1","contentTxt":"To understand what constitutes a component in Angular, let’s look closer at TalkCmp.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000010","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000011","sortNo":11,"contentFormatId":"1","contentTxt":"<strong>Input and Output Properties</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000012","sortNo":12,"contentFormatId":"1","contentTxt":"A component has input and output properties, which can be defined in the component decorator or using property decorators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000013","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000014","sortNo":14,"contentFormatId":"1","contentTxt":"Data flows into a component via input properties. Data flows out of a component via output properties, hence the names: ‘input’ and ‘output’.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Input and output properties are the public API of a component. You use them when you instantiate a component in your application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000017","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000018","sortNo":18,"contentFormatId":"1","contentTxt":"You can set input properties using property bindings, through square brackets. You can subscribe to output properties using event bindings, through parenthesis.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000019","sortNo":19,"contentFormatId":"1","contentTxt":"<strong>Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000020","sortNo":20,"contentFormatId":"1","contentTxt":"A component has a template, which describes how the component is rendered on the page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000021","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000022","sortNo":22,"contentFormatId":"1","contentTxt":"You can define the template inline, as shown above, or externally using templateUrl. In addition to the template, a component can define styles using the style and styleUrls properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000023","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000024","sortNo":24,"contentFormatId":"1","contentTxt":"By default the styles are encapsulated, so the margin defined above won’t affect any other component using `watch-button`.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000025","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Lifecycle</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000026","sortNo":26,"contentFormatId":"1","contentTxt":"Components have a well-defined lifecycle, which you can tap into. TalkCmp does not subscribe to any lifecycle events, but some other components can. For instance, this component will be notified when its input properties change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000027","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000028","sortNo":28,"contentFormatId":"1","contentTxt":"<strong>Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000029","sortNo":29,"contentFormatId":"1","contentTxt":"A component can configure dependency injection by defining the list of providers the component and its children may inject.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000030","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000031","sortNo":31,"contentFormatId":"1","contentTxt":"In this example, we have the logger service declared in the app component, which makes them available in the whole application. The talks component injects the logger service. I will cover dependency injection in detail in an upcoming post. For now, just remember that components can configure dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000032","sortNo":32,"contentFormatId":"1","contentTxt":"<strong>Host Element</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000033","sortNo":33,"contentFormatId":"1","contentTxt":"To turn an Angular component into something rendered in the DOM you have to associate an Angular component with a DOM element. We call such elements host elements.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000034","sortNo":34,"contentFormatId":"1","contentTxt":"A component can interact with its host DOM element in the following ways:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000035","sortNo":35,"contentFormatId":"1","contentTxt":"1. It can listen to its events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000036","sortNo":36,"contentFormatId":"1","contentTxt":"2. It can update its properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000037","sortNo":37,"contentFormatId":"1","contentTxt":"3. It can invoke methods on it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000038","sortNo":38,"contentFormatId":"1","contentTxt":"The component, for instance, listens to the input event using hostListeners, trims the value, and then stores it in a field. Angular will sync up the stored value with the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000039","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000040","sortNo":40,"contentFormatId":"1","contentTxt":"Note, I don’t actually interact with the DOM directly. Angular aims to provide a higher-level API, so the native platform, the DOM, will just reflect the state of the Angular application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000041","sortNo":41,"contentFormatId":"1","contentTxt":"This is useful for a couple of reasons:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000042","sortNo":42,"contentFormatId":"1","contentTxt":"1. It makes components easier to refactor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000043","sortNo":43,"contentFormatId":"1","contentTxt":"2. It allows unit testing most of the behavior of an application without touching the DOM. Such tests are easier to write and understand. In addition, they are significantly faster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000044","sortNo":44,"contentFormatId":"1","contentTxt":"3. It allows running Angular applications in a web worker, server, or other platforms where a native DOM isn’t present.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000045","sortNo":45,"contentFormatId":"1","contentTxt":"4. Sometimes you just need to interact with the DOM directly. Angular provides such APIs, but our hope is that you will rarely need to use them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000046","sortNo":46,"contentFormatId":"1","contentTxt":"<strong>Queries</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000047","sortNo":47,"contentFormatId":"1","contentTxt":"In addition to access its host element, a component can interact with its children. There are two types of children a component can have: content children and view children. To understand the difference between them, let’s look at the following example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000048","sortNo":48,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000049","sortNo":49,"contentFormatId":"1","contentTxt":"The content children of the tabs component are the three tab components. The user of the tabs component provided those. The previous and next buttons are the view children of the tabs component. The author of the tabs component provided those. Components can query their children using the ContentChild, ContentChildren, ViewChild, and ViewChildren decorators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000050","sortNo":50,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000051","sortNo":51,"contentFormatId":"1","contentTxt":"Angular will set this list during the construction of the tabs component, and will keep it updated when content children get created, removed, or reordered. I will talk more about this in the upcoming post on change detection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000052","sortNo":52,"contentFormatId":"1","contentTxt":"<strong>What is a Component?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000053","sortNo":53,"contentFormatId":"1","contentTxt":"What I have listed constitutes a component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000054","sortNo":54,"contentFormatId":"1","contentTxt":"1. A component knows how to interact with its host element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000055","sortNo":55,"contentFormatId":"1","contentTxt":"2. A component knows how to interact with its content and view children.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000056","sortNo":56,"contentFormatId":"1","contentTxt":"3. A component knows how to render itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000057","sortNo":57,"contentFormatId":"1","contentTxt":"4. A component configures dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000058","sortNo":58,"contentFormatId":"1","contentTxt":"5. A component has a well-defined public API of input and output properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000059","sortNo":59,"contentFormatId":"1","contentTxt":"All of these make components in Angular self-describing, so they contain all the information needed to instantiate them. And this is extremely important.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000060","sortNo":60,"contentFormatId":"1","contentTxt":"This means that any component can be bootstrapped. It does not have to be special in any way. Moreover, any component can be loaded into a router outlet. As a result, you can write a component that can be bootstrapped as an application, loaded as a route, or used in some other component directly. This results in less API to learn. And it also makes components more reusable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000061","sortNo":61,"contentFormatId":"1","contentTxt":"<strong>What About Directives?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000062","sortNo":62,"contentFormatId":"1","contentTxt":"If you are familiar with Angular 1, you must be wondering “What happened to directives?”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000063","sortNo":63,"contentFormatId":"1","contentTxt":"Actually directives are still here in Angular. The component is just the most important type of a directive, but not the only one. A component is a directive with a template. But you can still write decorator-style directives, which do not have templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000064","sortNo":64,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000065","sortNo":65,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201601110000000003","sortNo":1,"contentFormatId":"1","contentTxt":"Some people seem to be confused why Angular 2 seems to favor the Observable abstraction over the Promise abstraction when it comes to dealing with async behavior.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000004","sortNo":2,"contentFormatId":"1","contentTxt":"There are pretty good resources about the difference between Observables and Promises already out there. I especially like to highlight this free 7 minutes video by Ben Lesh on egghead.io. Technically there are a couple of obvious differences like the disposability and lazyness of Observables. In this article we like to focus on some practical advantages that Observables introduce for server communication.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000005","sortNo":3,"contentFormatId":"1","contentTxt":"The scenario","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000006","sortNo":4,"contentFormatId":"1","contentTxt":"Consider you are building a search input mask that should instantly show you results as you type.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000007","sortNo":5,"contentFormatId":"1","contentTxt":"If you’ve ever build such a thing before you are probably aware of the challenges that come with that task.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000008","sortNo":6,"contentFormatId":"1","contentTxt":"1. Don’t hit the search endpoint on every key stroke","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000009","sortNo":7,"contentFormatId":"1","contentTxt":"Treat the search endpoint as if you pay for it on a per-request basis. No matter if it’s your own hardware or not. We shouldn’t be hammering the search endpoint more often than needed. Basically we only want to hit it once the user has stopped typing instead of with every keystroke.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000010","sortNo":8,"contentFormatId":"1","contentTxt":"2. Don’t hit the search endpoint with the same query params for subsequent requests","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000011","sortNo":9,"contentFormatId":"1","contentTxt":"Consider you type foo, stop, type another o, followed by an immediate backspace and rest back at foo. That should be just one request with the term foo and not two even if we technically stopped twice after we had foo in the search box.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000134","sortNo":10,"contentFormatId":"1","contentTxt":"3. Deal with out-of-order responses","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000135","sortNo":11,"contentFormatId":"1","contentTxt":"When we have multiple requests in-flight at the same time we must account for cases where they come back in unexpected order. Consider we first typed computer, stop, a request goes out, we type car, stop, a request goes out. Now we have two requests in-flight. Unfortunately the request that carries the results for computer comes back after the request that carries the results for car. This may happen because they are served by different servers. If we don’t deal with such cases properly we may end up showing results for computer whereas the search box reads car.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000136","sortNo":12,"contentFormatId":"1","contentTxt":"Challenge accepted","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000137","sortNo":13,"contentFormatId":"1","contentTxt":"We will use the free and open wikipedia API to write a little demo.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000138","sortNo":14,"contentFormatId":"1","contentTxt":"For simplicity our demo will simply consist of two files: app.ts and wikipedia-service.ts. In a real world scenario we would most likely split things further up though.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000139","sortNo":15,"contentFormatId":"1","contentTxt":"Let’s start with a Promise-based implementation that doesn’t handle any of the described edge cases.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000140","sortNo":16,"contentFormatId":"1","contentTxt":"This is what our WikipediaService looks like. Despite the fact that the Http/JsonP API still has some little unergonomic parts, there shouldn’t be much of surprise here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000141","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000142","sortNo":18,"contentFormatId":"1","contentTxt":"Basically we are injecting the Jsonp service to make a GET request against the wikipedia API with a given search term. Notice that we call toPromise in order to get from an Observable<Response> to a Promise<Response>. With a little bit of then-chaining we eventually end up with a Promise<Array<string>> as the return type of our search method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000143","sortNo":19,"contentFormatId":"1","contentTxt":"So far so good, let’s take a look at the app.ts file that holds our App Component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000144","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000145","sortNo":21,"contentFormatId":"1","contentTxt":"Not much of a surprise here either. We inject our WikipediaService and expose it’s functionality via a search method to the template. The template simply binds to keyup and calls search(term.value) leveraging Angular 2’s awesome template ref feature.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000146","sortNo":22,"contentFormatId":"1","contentTxt":"We unwrap the result of the Promise that the search method of the WikipediaService returns and expose it as a simple Array of strings to the template so that we can have *ngFor loop through it and build up a list for us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000147","sortNo":23,"contentFormatId":"1","contentTxt":"You can play with the demo and fiddle with the code through this plnkr.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000148","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000149","sortNo":25,"contentFormatId":"1","contentTxt":"Unfortunately this implementation doesn’t address any of the described edge cases that we would like to deal with. Let’s refactor our code to make it match the expected behavior.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000150","sortNo":26,"contentFormatId":"1","contentTxt":"Taming the user input","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000151","sortNo":27,"contentFormatId":"1","contentTxt":"Let’s change our code to not hammer the endpoint with every keystroke but instead only send a request when the user stopped typing for 400 ms. This is where Observables really shine. The Reactive Extensions (Rx) offer a broad range of operators that let us alter the behavior of Observables and create new Observables with the desired semantics.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000152","sortNo":28,"contentFormatId":"1","contentTxt":"To unveil such super powers we first need to get an Observable<string> that carries the search term that the user types in. Instead of manually binding to the keyup event we use ngFormControl from within our template and set it to the name \"term\".","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000153","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000154","sortNo":30,"contentFormatId":"1","contentTxt":"In our component we create an instance of Control from angular2/common and expose it as a field under the name term on our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000155","sortNo":31,"contentFormatId":"1","contentTxt":"Behind the scenes term automatically exposes an Observable<string> as property valueChanges that we can subscribe to. Now that we have an Observable<string>, taming the user input is as easy as calling debounceTime(400) on our Observable. This will return a new Observable<string> that will only emit a new value when there haven’t been coming new values for 400ms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000156","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000157","sortNo":33,"contentFormatId":"1","contentTxt":"Don’t hit me twice","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000158","sortNo":34,"contentFormatId":"1","contentTxt":"As we said, it would be a waste of resources to send out another request for a search term that our app already shows the results for. Fortunately Rx simplifies many operations that it nearly feels unnecessary to mention them. All we have to do to achieve the desired behavior is to call the distinctUntilChanged operator right after we called debounceTime(400). Again, we will get back an Observable<string> but one that ignores values that are the same as the previous.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000159","sortNo":35,"contentFormatId":"1","contentTxt":"Dealing with out-of-order responses","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000160","sortNo":36,"contentFormatId":"1","contentTxt":"Dealing with out of order responses can be a tricky task. Basically we need a way to express that we aren’t interested anymore in results from previous in-flight requests as soon as we are sending out new requests. In other words: cancel out all previous request as soon as we start a new one. As I briefly mentioned in the beginning Observables are disposable which mean we can unsubscribe from then.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000161","sortNo":37,"contentFormatId":"1","contentTxt":"This is where we want to change our WikipediaService to return an Observable<Array<string>> instead of an Promise<Array<string>>. That’s as easy as dropping toPromise and using map instead of then.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000162","sortNo":38,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000163","sortNo":39,"contentFormatId":"1","contentTxt":"Now that our WikipediaSerice returns an Observable instead of a Promise we simply need to replace then with subscribe in our App component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000164","sortNo":40,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000165","sortNo":41,"contentFormatId":"1","contentTxt":"But now we have two subscribe calls. This is needlessly verbose and often a sign for unidiomatic usage. The good news is, now that search returns an Observable<Array<string>> we can simply use flatMap to project our Observable<string> into the desired Observable<Array<string>> by composing the Observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000166","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000167","sortNo":43,"contentFormatId":"1","contentTxt":"You may be wondering what flatMap does and why we can’t use map here. The answer is quite simple. The map operator expects a function that takes a value T and returns a value U. For instance a function that takes in a string and returns a Number. Hence when you use map you get from an Observable<T> to an Observable<U>. However, our search method produces an Observable<Array> itself. So coming from an Observable<string> that we have right after distinctUntilChanged, map would take us to an Observable<Observable<Array<string>>. That’s not quite what we want.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000168","sortNo":44,"contentFormatId":"1","contentTxt":"The flatMap operator on the other hand expects a function that takes a T and returns an Observable<U> and produces an Observable<U> for us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000169","sortNo":45,"contentFormatId":"1","contentTxt":"NOTE: That’s not entirely true, but it helps as a simplification.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000170","sortNo":46,"contentFormatId":"1","contentTxt":"That perfectly matches our case. We have an Observable<string>, then call flatMap with a function that takes a string and returns an Observable<Array<string>>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000171","sortNo":47,"contentFormatId":"1","contentTxt":"So does this solve our out-of-order response issues? Unfortunately not. So, why am I bothering you with all this in the first place? Well, now that you understood flatMap just replace it with switchMap and you are done.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000172","sortNo":48,"contentFormatId":"1","contentTxt":"What?! You may be wondering if I’m kidding you but no I am not. That’s the beautify of Rx with all it’s useful operators. The switchMap operator is comparable to flatMap in a way. Both operators automatically subscribe to the Observable that the function produces and flatten the result for us. The difference is that the switchMap operator automatically unsubscribes from previous subscriptions as soon as the outer Observable emits new values.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000173","sortNo":49,"contentFormatId":"1","contentTxt":"Putting some sugar on top","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000174","sortNo":50,"contentFormatId":"1","contentTxt":"Now that we got the semantics right, there’s one more little trick that we can use to save us some typing. Instead of manually subscribing to the Observable we can let Angular do the unwrapping for us right from within the template. All we have to do to accomplish that is to use the AsyncPipe in our template and expose the Observable<Array<string>> instead of Array<string>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000175","sortNo":51,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null}]
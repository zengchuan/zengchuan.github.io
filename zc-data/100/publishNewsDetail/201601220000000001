[{"id":"201601220000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Background","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Disclaimer: Angular 2 is still in alpha. All the APIs we're using here are quite likely to change. If you notice that the article is not up to date, please open a PR, leave a comment or contact me via twitter.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000003","sortNo":3,"contentFormatId":"1","contentTxt":"In order to get familiar with the upcoming content you need to have basic understanding of Angular 2 and the component based router introduced by the framework. Good introduction to routing in Angular 2 could be found here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Sample Application","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000005","sortNo":5,"contentFormatId":"1","contentTxt":"Lets take a look at this sample application:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000006","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000121","sortNo":7,"contentFormatId":"1","contentTxt":"This is the root component of angular2-seed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000122","sortNo":8,"contentFormatId":"1","contentTxt":"In the snippet above we create a new component with controller the App class. We also register two routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000123","sortNo":9,"contentFormatId":"1","contentTxt":"1. / - once opened the Home component will be rendered.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000124","sortNo":10,"contentFormatId":"1","contentTxt":"2. /about - once opened the About component will be rendered.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000125","sortNo":11,"contentFormatId":"1","contentTxt":"Here's the implementation of the About component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000126","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000127","sortNo":13,"contentFormatId":"1","contentTxt":"The About component uses the service NameList, which is located under ../../services/NameList. So far so good, now lets take a look at how our application looks like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000128","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000129","sortNo":15,"contentFormatId":"1","contentTxt":"As we can see from Chrome DevTools' Network tab, during the initial page load all the components and services used in the entire application are being downloaded. However, in order to render the Home view we don't need the About component, neither the NameList service (usually the template of the About component will be requested as well. However, in this example it is being inlined inside the component by a gulp task).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000130","sortNo":16,"contentFormatId":"1","contentTxt":"Place for Improvements!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000131","sortNo":17,"contentFormatId":"1","contentTxt":"In the sample application above, loading a couple of files more is not such a big problem since the entire app consists only two views and a single service. However, in a real-life application downloading the entire dependency graph during the initial page load may create quite poor user experience. Imagine we had n views, each of these n components had m dependencies, which had another k dependencies, etc.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000132","sortNo":18,"contentFormatId":"1","contentTxt":"Lazy Loading","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000133","sortNo":19,"contentFormatId":"1","contentTxt":"The practice of lazy loading is quite common in web development. We lazy load assets, partials, basically whatever we need in order to speedup our load time and we load it on demand!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000134","sortNo":20,"contentFormatId":"1","contentTxt":"The Problem","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000135","sortNo":21,"contentFormatId":"1","contentTxt":"Although the About component is not essential for rendering the Home component it is referenced directly inside the file, which contains the definition of the root component of our application (App). App cannot be rendered until all of the dependencies, which are declared inside of the file are not loaded. Although the ES2015 modules have implicit asynchronous behavior the rendering of the App component happens synchronously, since we need to resolve all of its dependencies before it appears onto the screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000136","sortNo":22,"contentFormatId":"1","contentTxt":"In order to workaround this issue we can use the ES2015 module loader imperative API.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000137","sortNo":23,"contentFormatId":"1","contentTxt":"AsyncRoute","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000138","sortNo":24,"contentFormatId":"1","contentTxt":"The obvious Angular solution to the problem us using AsyncRoute. This is class, which implements RouteDefinition and allows asynchronous loading of the component associated with given route. This allows on demand loading of the component's dependencies as well. Here's now our definition will look like with AsyncRoute:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000139","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000140","sortNo":26,"contentFormatId":"1","contentTxt":"Basically we register two routes: - A regular route - Async route. The async route accepts as argument a loader. The loader is a function that must return a promise, which needs to be resolved with the component that needs to be rendered.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000141","sortNo":27,"contentFormatId":"1","contentTxt":"So far so good! Everything looks great and we achieved our goal. However, there are some more advanced cases we may want to cover. For example, we may need to throw events when the route change has started and completed. In the case of AsyncRoute we can implement a generic loader, which takes care of this. However, we may want to implement something like a splash screen or have even further control on the component's rendering. In such case we may use a:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000142","sortNo":28,"contentFormatId":"1","contentTxt":"Virtual Proxy","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000143","sortNo":29,"contentFormatId":"1","contentTxt":"The Angular router accepts a component for value of the component property of all of its routes definitions. However, instead of providing the concrete component, which needs to be rendered we can provide a component proxy. This is the Virtual Proxy pattern. Inside the component proxy we can load the target component and later, when it is loaded, using the DynamicComponentLoader we can render it onto the screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000144","sortNo":30,"contentFormatId":"1","contentTxt":"Lets define a componentProxyFactory, which will be responsible for creating component proxies:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000145","sortNo":31,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000146","sortNo":32,"contentFormatId":"1","contentTxt":"Now lets take a look at the code step by step:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000147","sortNo":33,"contentFormatId":"1","contentTxt":"1. We define a class called ComponentProvider. It contains two properties:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000148","sortNo":34,"contentFormatId":"1","contentTxt":"(1). path - a path to the component, which will be used by the module loader.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000149","sortNo":35,"contentFormatId":"1","contentTxt":"(2). provide - a provider, which will return the target component based on the passed module as argument","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000150","sortNo":36,"contentFormatId":"1","contentTxt":"2. We define a function called componentProxyFactory:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000151","sortNo":37,"contentFormatId":"1","contentTxt":"(1). This function accepts as argument a ComponentProvider object and returns a new component called VirtualComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000152","sortNo":38,"contentFormatId":"1","contentTxt":"(2). The VirtualComponent defines a single binding, in order to allow the provider to be passed as argument to the constructor through DI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000153","sortNo":39,"contentFormatId":"1","contentTxt":"(3). Inside VirtualComponent's constructor we load the module based on the provider's path and right after that loaded in the template using: loader.loadIntoLocation(provider.provide(m), el, 'content');","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000154","sortNo":40,"contentFormatId":"1","contentTxt":"Now lets take a look how we can refactor our root component in order to take advantage of the lazy loading:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000155","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000156","sortNo":42,"contentFormatId":"1","contentTxt":"Now the file doesn't contain any reference to the About component. Instead it registers in the route definition for the About component using:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000157","sortNo":43,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000158","sortNo":44,"contentFormatId":"1","contentTxt":"Results","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000159","sortNo":45,"contentFormatId":"1","contentTxt":"As we can see there are two additional resources, which are being downloaded on demand:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000160","sortNo":46,"contentFormatId":"1","contentTxt":"about.js, NameList.js","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000161","sortNo":47,"contentFormatId":"1","contentTxt":"Conclusion","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000162","sortNo":48,"contentFormatId":"1","contentTxt":"There are still a lot of things to be considered. For example, in a real-life application you'll most likely have different bundles in order to reduce the number of downloaded files even further. In our case we can combine the About component and NameList in a single file during the build process.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000163","sortNo":49,"contentFormatId":"1","contentTxt":"Also do not forget that Angular 2 is still in early alpha so the framework and the entire API are under development. However, no one stops you from having fun with it!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000164","sortNo":50,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000165","sortNo":51,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/mgechev/angular2-seed\">https://github.com/mgechev/angular2-seed</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201705260000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000002","sortNo":2,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Two Modules</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000004","sortNo":4,"contentFormatId":"1","contentTxt":"FormsModule and ReactiveFormsModule","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000005","sortNo":5,"contentFormatId":"1","contentTxt":"1. FormsModule implements AngularJS-style form handling. We create a form by placing directives in the template. We then use data bindings get data in and out of that form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000006","sortNo":6,"contentFormatId":"1","contentTxt":"2. ReactiveFormsModule is another take on handling input, where we define a form in the component class and just bind it to elements in the template. We tend to use reactive programming to get data in and out of the form, hence the name “reactive”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000007","sortNo":7,"contentFormatId":"1","contentTxt":"At first glance, these two modules seem very different. But once we understand the underlying mechanisms, we will see how much they have in common. In addition, it will give us an idea of how to build our own form-handling module if needed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000008","sortNo":8,"contentFormatId":"1","contentTxt":"<strong>High-Level Overview</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000009","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000010","sortNo":10,"contentFormatId":"1","contentTxt":"<strong>App Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000011","sortNo":11,"contentFormatId":"1","contentTxt":"The app model is an object provided by the application developer. It can be a JSON object fetched from the server, or some object constructed on the client side. Angular doesn’t make any assumptions about it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000012","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Form Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000013","sortNo":13,"contentFormatId":"1","contentTxt":"The form model is a UI-independent representation of a form. It consists of three building blocks: FormControl, FormGroup, and FormArray. We will look at the form model in detail later in this chapter. Both FormsModule and ReactiveFormsModule use this model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000014","sortNo":14,"contentFormatId":"1","contentTxt":"<strong>Form Directives</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000015","sortNo":15,"contentFormatId":"1","contentTxt":"These are the directives connecting the form model to the DOM (e.g., NgModel). FormsModule and ReactiveFormsModule provide different sets of these directives.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000016","sortNo":16,"contentFormatId":"1","contentTxt":"<strong>DOM</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000017","sortNo":17,"contentFormatId":"1","contentTxt":"These are ours inputs, checkboxes, and radio buttons.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000018","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Form Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000019","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000020","sortNo":20,"contentFormatId":"1","contentTxt":"To make form handling less UI-dependent, @angular/forms provides a set of primitives for modelling forms: FormControl, FormGroup, and FormArray.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000021","sortNo":21,"contentFormatId":"1","contentTxt":"<strong>Form Control</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000022","sortNo":22,"contentFormatId":"1","contentTxt":"FormControl is an indivisible part of the form, an atom. It usually corresponds to a simple UI element, such as an input.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000023","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000024","sortNo":24,"contentFormatId":"1","contentTxt":"A FormControl has a value, status, and a map of errors:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000025","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000026","sortNo":26,"contentFormatId":"1","contentTxt":"<strong>Form Group</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000027","sortNo":27,"contentFormatId":"1","contentTxt":"FormGroup is a fixed-size collection of controls, a record.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000028","sortNo":28,"contentFormatId":"1","contentTxt":"A FormGroup is itself a control, and, as such, has the same methods as FormControl.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000029","sortNo":29,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000030","sortNo":30,"contentFormatId":"1","contentTxt":"The value of a group is just an aggregation of the values of its children. Any time the value of a child control changes, the value of the group will change as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000031","sortNo":31,"contentFormatId":"1","contentTxt":"In opposite to the value, the form group doesn’t aggregate the errors of its children. It has its own validators and its own collection of errors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000032","sortNo":32,"contentFormatId":"1","contentTxt":"The status of a group is calculated as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000033","sortNo":33,"contentFormatId":"1","contentTxt":"<ul>\n<li>If one of its children is invalid, the group is invalid.                                </li>\n<li>If all of its children are valid, but the group itself has errors, the group is invalid.    </li>\n<li>If all of its children are valid, and the group has no errors, the group is valid.          </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000034","sortNo":34,"contentFormatId":"1","contentTxt":"Since a form group acts like a control, we can nest form groups in arbitrary ways.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000035","sortNo":35,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000036","sortNo":36,"contentFormatId":"1","contentTxt":"<strong>Form Array</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000037","sortNo":37,"contentFormatId":"1","contentTxt":"Whereas FormGroup is a collection of different control types of fixed length, FormArray is a collection of the same control type of a variable length.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000038","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000039","sortNo":39,"contentFormatId":"1","contentTxt":"All the considerations regarding FormGroup’s value, status, and errors apply here as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000040","sortNo":40,"contentFormatId":"1","contentTxt":"<strong>Updating Form Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000041","sortNo":41,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000042","sortNo":42,"contentFormatId":"1","contentTxt":"There are two ways to update the value of a form: setValue and patchValue:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000043","sortNo":43,"contentFormatId":"1","contentTxt":"The setValue method is strict and requires the value to match the structure of the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000044","sortNo":44,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000045","sortNo":45,"contentFormatId":"1","contentTxt":"If we try to set the value of a control that doesn’t exist, or if we exclude the value of a control, setValue will fail.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000046","sortNo":46,"contentFormatId":"1","contentTxt":"The patchValue method works as setValue except that it doesn’t throw when the value is a superset or a subset of the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000047","sortNo":47,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000048","sortNo":48,"contentFormatId":"1","contentTxt":"By default updating a control will update its parents. We can prevent the change from propagating through the parents by passing onlySelf: true:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000049","sortNo":49,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000050","sortNo":50,"contentFormatId":"1","contentTxt":"<strong>Disabling Form Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000051","sortNo":51,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000052","sortNo":52,"contentFormatId":"1","contentTxt":"This exempts acceptTerms validation checks and excludes it from the aggregate value of any parent. Its status gets set to DISABLED.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000053","sortNo":53,"contentFormatId":"1","contentTxt":"<strong>Async Validations</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000054","sortNo":54,"contentFormatId":"1","contentTxt":"The required validator we have used throughout the chapter is synchronous. The moment we set value, the moment the control goes into the VALID or INVALID state. Some validations, however, have to be asynchronous. A good example is the uniqueness of the login.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000055","sortNo":55,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000056","sortNo":56,"contentFormatId":"1","contentTxt":"This will set the status of the control and its parents to PENDING. And, once the promise returned by uniqLoginValidator resolves, the status will be set to either INVALID or VALID.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000057","sortNo":57,"contentFormatId":"1","contentTxt":"In addition to declarative validators, we can always set the errors on the control imperatively.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000058","sortNo":58,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000059","sortNo":59,"contentFormatId":"1","contentTxt":"<strong>Composing Validators</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000060","sortNo":60,"contentFormatId":"1","contentTxt":"A validator is just a function that takes a control and returns a map of errors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000061","sortNo":61,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000062","sortNo":62,"contentFormatId":"1","contentTxt":"The value doesn’t have to be a boolean. We can provide extra information to create a more meaningful error message.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000063","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000064","sortNo":64,"contentFormatId":"1","contentTxt":"Since the return value of a validator is a map, and not a single value, it’s easy to compose multiple validators into one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000065","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000066","sortNo":66,"contentFormatId":"1","contentTxt":"The provided compose function will execute all the validators and merge the errors. We can, of course, implement our own compose function that, for instance, will execute validators until the first failure.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000067","sortNo":67,"contentFormatId":"1","contentTxt":"<strong>Listening to Changes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000068","sortNo":68,"contentFormatId":"1","contentTxt":"Any time a control updates, it will emit the value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000069","sortNo":69,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000070","sortNo":70,"contentFormatId":"1","contentTxt":"As you can see the value of the form has been updated twice. We can prevent this by setting the value on the form itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000071","sortNo":71,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000072","sortNo":72,"contentFormatId":"1","contentTxt":"We can also prevent the events from being emitted altogether by passing emitEvent: false.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000073","sortNo":73,"contentFormatId":"1","contentTxt":"<strong>Power of RxJS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000074","sortNo":74,"contentFormatId":"1","contentTxt":"Since valueChanges and statusChanges are RxJS observables, we can use the rich set of RxJS combinators to implement powerful user interactions in a just a few lines of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000075","sortNo":75,"contentFormatId":"1","contentTxt":"<strong>Why Form Model?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000076","sortNo":76,"contentFormatId":"1","contentTxt":"The form model is a UI-independent way to represent user input comprising simple controls (FormControl) and their combinations (FormGroup and FormArray), where:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000077","sortNo":77,"contentFormatId":"1","contentTxt":"<ul>\n<li>Each control has a value.              </li>\n<li>Each control has a status.             </li>\n<li>Each control has validators and errors.</li>\n<li>Each control can be disabled.          </li>\n<li>Each control emits events.             </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000078","sortNo":78,"contentFormatId":"1","contentTxt":"Having this model has the following advantages:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000079","sortNo":79,"contentFormatId":"1","contentTxt":"<ul>\n<li>Form handling is a complex problem. Splitting it into UI-independent and UI-dependent parts makes them easier to manage.</li>\n<li>We can test form handling without rendering UI.                                                                             </li>\n<li>Having the form model makes reactive forms possible (see below).                                                            </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000080","sortNo":80,"contentFormatId":"1","contentTxt":"<strong>Form Directives</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000081","sortNo":81,"contentFormatId":"1","contentTxt":"Abstractly describing input is all well and good, but at some point we will need to connect it to the UI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000082","sortNo":82,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000083","sortNo":83,"contentFormatId":"1","contentTxt":"@angular/forms provides two modules that do that: FormsModule and ReactiveFormsModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000084","sortNo":84,"contentFormatId":"1","contentTxt":"<strong>ReactiveFormsModule</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000085","sortNo":85,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000086","sortNo":86,"contentFormatId":"1","contentTxt":"ReactiveFormsModule is simpler to understand and explain than FormsModule. That’s why I will cover it first.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000087","sortNo":87,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000088","sortNo":88,"contentFormatId":"1","contentTxt":"There are a few things here to note.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000089","sortNo":89,"contentFormatId":"1","contentTxt":"First, we import ReactiveFormsModule, which provides, among others, the formGroup and formControlName directives.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000090","sortNo":90,"contentFormatId":"1","contentTxt":"Second, we manually construct a form model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000091","sortNo":91,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000092","sortNo":92,"contentFormatId":"1","contentTxt":"Third, we bind the constructed form to the div using formGroup. Then we use formControlName to bind the title, speaker, and highRating to the three inputs. The name suffix indicates that we need to pass the name of a field of the containing group.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000093","sortNo":93,"contentFormatId":"1","contentTxt":"When using ReactiveFormsModule we are responsible for creating the form model. We use the directives merely to bind the form to elements in the UI.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000094","sortNo":94,"contentFormatId":"1","contentTxt":"Then we use the constructed form model directly to synchronize it with the client model or trigger events. And we often do it by subscribing to the valueChanges and statusChanges observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000095","sortNo":95,"contentFormatId":"1","contentTxt":"<strong>FormsModule</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000096","sortNo":96,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000097","sortNo":97,"contentFormatId":"1","contentTxt":"FormsModule implements AngularJS-style forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000098","sortNo":98,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000099","sortNo":99,"contentFormatId":"1","contentTxt":"This is similar to AngularJS 1.x. We use the [()] syntax to bind the speaker, title, and highRating properties of the filters component to the three inputs. We then invoke the applyFilters method when the user submits the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000100","sortNo":100,"contentFormatId":"1","contentTxt":"Even though it’s not seen in the example, the following form group still gets created:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000101","sortNo":101,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000102","sortNo":102,"contentFormatId":"1","contentTxt":"The difference is that it does not get created by the application developer, but by the NgModel and NgForm directives.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000103","sortNo":103,"contentFormatId":"1","contentTxt":"<ul>\n<li>The NgForm directive gets instantiated at form (submit)=”applyFilters()”. This directive creates an empty FormGroup.</li>\n<li>The NgModel directive gets instantiated at input [(ngModel)]=”speaker” name=”speaker” placeholder=”Speaker”. This directive creates a `FormControl` and adds it to the FormGroup created by the encompassing NgForm. </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000104","sortNo":104,"contentFormatId":"1","contentTxt":"<strong>How is it possible?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000105","sortNo":105,"contentFormatId":"1","contentTxt":"If you have read the chapter on change detection carefully, you probably wonder how this works. Shouldn’t the following fail?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000106","sortNo":106,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000107","sortNo":107,"contentFormatId":"1","contentTxt":"If NgModel and NgForm were implemented naively, the {{f.controls.speaker == null}} binding would evaluate to true the first time, when the group is empty, and will evaluate to false once NgModels add their form controls to the group. This change from true to false will happen within a change detection run, which, in opposite to AngularJS 1.x, is disallowed in Angular 2.x+. The value of a binding can change only between change detection runs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000108","sortNo":108,"contentFormatId":"1","contentTxt":"To make it work, NgModel doesn’t add a form control synchronously — it does it in a microtask. In the example above, the three ngModels will schedule three microtasks to add the speaker, title, and highRating controls.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000109","sortNo":109,"contentFormatId":"1","contentTxt":"During the first change detection run, the form will always be empty and {{f.controls.speaker == null}} will always evaluate to true. Then, after the three microtasks, Angular will run change detection again, and {{f.controls.speaker == null}} will evaluate to false.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000110","sortNo":110,"contentFormatId":"1","contentTxt":"This is how we can preserve all the guarantees of Angular 2.x+ and still make the API feel AngularJS-like.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000111","sortNo":111,"contentFormatId":"1","contentTxt":"<strong>Accessing Form Model When Using FormsModule</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000112","sortNo":112,"contentFormatId":"1","contentTxt":"We can still access the form model by either querying for the NgForm directive or by referencing it in the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000113","sortNo":113,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000114","sortNo":114,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000115","sortNo":115,"contentFormatId":"1","contentTxt":"Once we get the model, we can interact with it imperatively or subscribe to its observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000116","sortNo":116,"contentFormatId":"1","contentTxt":"<strong>The DOM</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000117","sortNo":117,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000118","sortNo":118,"contentFormatId":"1","contentTxt":"The ngModel, ngControlName and other form directives bind the form model to UI elements, which are often native to the platform (e.g., <input>), but they do not have to be. For instance, NgModel can be applied to an Angular component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000119","sortNo":119,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000120","sortNo":120,"contentFormatId":"1","contentTxt":"A ControlValueAccessor is a directive that acts like a adapter connecting a UI element to NgModel. It knows how to read and write to the native UI-element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000121","sortNo":121,"contentFormatId":"1","contentTxt":"The @angular/forms package comes with value accessors for all built-in UI elements (input, textarea, etc). But if we want to apply an NgModel to a custom element or an Angular component, we will have to provide a value accessor for it ourselves.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000122","sortNo":122,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000123","sortNo":123,"contentFormatId":"1","contentTxt":"<strong>Wrapping Up</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000124","sortNo":124,"contentFormatId":"1","contentTxt":"Form handling is a complex problem. One of the main reasons AngularJS got so successful is that two-way bindings and ng-model provided a good solution for it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000125","sortNo":125,"contentFormatId":"1","contentTxt":"But there were some downsides, mainly complex forms built with ng-model made the data flow of the application hard to follow and debug. Angular 2.x+ builds up on the ideas from Angular 1, but avoids its problems.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000126","sortNo":126,"contentFormatId":"1","contentTxt":"NgModel and friends are no longer part of the core framework. The @angular/core package only contains the primitives we can use to build a form-handling module. Instead, Angular has a separate package — @angular/forms— that comes with FormsModule and ReactiveFormsModule that provide two different styles of handling user input.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000127","sortNo":127,"contentFormatId":"1","contentTxt":"Both the modules depend on the form model consisting of FormControl, FormGroup, and FormArray. Having this UI-independent model, we can model and test input handling without rendering any components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000128","sortNo":128,"contentFormatId":"1","contentTxt":"Finally, @angular/forms comes with a set of directives to handle build-in UI elements (such as input), but we can provide our own.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000129","sortNo":129,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201705260000000130","sortNo":130,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201611170000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Recently, I started on a project to migrate JavaScript to TypeScript in one of Lucidchart’s Angular 2 applications. This application has several components, each with its unique view. For those not familiar with Angular 2, a component is merely an encapsulation of a view on a webpage with its associated functionality and styling; e.g., HTML + JS + CSS. In our application, these components use the same data received from the backend, but present a unique view in each of them. The application’s performance and usability relies on the fastest possible availability of data. Since some of these components are rendered simultaneously, effective data-sharing was a good solution to greatly improve the user-experience.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000002","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Naive implementation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Let’s prototype this data-sharing service using TypeScript (JavaScript would look the same):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000005","sortNo":5,"contentFormatId":"1","contentTxt":"There are several things to note in the above code snippet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000006","sortNo":6,"contentFormatId":"1","contentTxt":"1. There is a class SharingService which acts like the data-sharing service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000007","sortNo":7,"contentFormatId":"1","contentTxt":"2. The SharingService class is injected into a component CustomComp using Angular 2’s dependency injection framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000008","sortNo":8,"contentFormatId":"1","contentTxt":"3. The data is obtained from the SharingService by the CustomComp during its initialization (ngOnInit).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000009","sortNo":9,"contentFormatId":"1","contentTxt":"The idea of a sharing service here is quite simple. It has a method getData1 that returns a Promise of the data you are interested in and a member variable data1 to store the data. Any other component that’s interested in data1 will have a resolved Promise ready to serve up data1. The following figure better explains the flow of data:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000010","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000011","sortNo":11,"contentFormatId":"1","contentTxt":"While this implementation is straightforward, it’s not perfect. When data1 is fetched by a component (say component A) once, it remains the same throughout the lifetime of the component. When the sharing service fetches the data again for another component (say component B), this new data is not available for component A, unless component A polls for it or if component A is restarted. Communication between components A and B to know if the data needs to be loaded again can be painful, complicated, and difficult to scale.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000012","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Observables: Promises on Steroids</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000013","sortNo":13,"contentFormatId":"1","contentTxt":"While a Promise represents a value to be resolved in future, an Observable represents a stream of values throughout. An Observable may be completed, which means it won’t emit any further values. An Observer subscribes to these Observables. These Observers are essentially callbacks to emissions of the Observable. This paradigm supports asynchronous operations naturally. In our application, the Angular 2 components have functions which act as Observers, while the data-sharing service can act as an Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000014","sortNo":14,"contentFormatId":"1","contentTxt":"<strong>Defining Data Sources with Subjects</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000015","sortNo":15,"contentFormatId":"1","contentTxt":"But since the data-sharing service is not the actual source of the data, Observables are not enough. Our data-sharing service would need to observe the data source (in our case, some HTTP module) while emitting the fetched data. Hence, we need Subjects. A Subject is both an observer and an observable. This is how it works:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000016","sortNo":16,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000017","sortNo":17,"contentFormatId":"1","contentTxt":"This sharing service has a Subject. We only need the Observable portion of the subject for our components: The asObservable method is used to get the data. We also have another method called refresh. This method uses the Net module to fetch the data from the back-end service and pipes it into the Subject using the next call, to which it reacts by emitting the same value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000018","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Storing the Last Value with BehaviorSubject</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000019","sortNo":19,"contentFormatId":"1","contentTxt":"The data reaches the component when refresh is called on the sharing service and when the component subscribes using the method getData1. However, this solution still isn’t quite right. A normal Subject will emit only future events to an Observer after subscription. For example, if component B subscribes to the data after it is refreshed once, it might not get any data at all unless it’s refreshed again or it subscribed before data was fetched by the Net module. But there is an easier solution to this problem.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000020","sortNo":20,"contentFormatId":"1","contentTxt":"BehaviorSubject solves our last problem; it is a type of Subject which always emits the last emitted value to any new subscriber. Unfortunately, BehaviorSubject needs an initial value. Since our data source is a back-end service, there is no synchronous value to initialize with. Hence, we live with using an undefined as the initial state.  The key benefit in this approach is that when component B initiates a refresh, component A will automatically receive the new data. Component A doesn’t need any kind of messaging system to be informed about new data. The data in component A is ever-changing throughout its lifetime.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000021","sortNo":21,"contentFormatId":"1","contentTxt":"<strong>Dealing with Update Propagation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000022","sortNo":22,"contentFormatId":"1","contentTxt":"There is still one more problem left to be addressed. Since none of the components talk to each other, it’s pretty hard to know when a refresh needs to happen. There is no reason to fetch the data before it’s actually necessary. At the same time, each component shouldn’t need to refresh again and again unless it’s necessary. The simplest solution might be to add a flag to the SharingService, to indicate the availability of data. However, this solution requires that the components know about the internals of our SharingService. A better approach might be to expose a different API to the components that takes care of handling the refresh internally. Here is what it looks like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000023","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000024","sortNo":24,"contentFormatId":"1","contentTxt":"Several improvements have been made in the above snippet. The awaitData method is a better solution to the last problem—it decides whether or not it is necessary to fetch new data while returning an Observable of the data source. We also added error handling to the refresh method. The below sequence diagram helps visualize the interactions between all the pieces from our final example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000025","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000026","sortNo":26,"contentFormatId":"1","contentTxt":"<strong>How Can You Benefit From Observables</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000027","sortNo":27,"contentFormatId":"1","contentTxt":"To summarize, using the Observable pattern provides the following key benefits while developing complex web applications:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000028","sortNo":28,"contentFormatId":"1","contentTxt":"1. Provides an easy-to-use event-like abstraction layer where Observable emissions are synonymous with events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000029","sortNo":29,"contentFormatId":"1","contentTxt":"2. Helps develop asynchronous, user-interactive applications efficiently.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000030","sortNo":30,"contentFormatId":"1","contentTxt":"3. Enables a simple communication mechanism across different parts of the application without introducing explicit dependencies between components.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201601140000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Ok, so you're ready to roll up your sleeves and get something practical done with Angular2. Let's take a look at how to get some data via the new Http service - it's quite a bit different than the Angular 1 $http service semantically, but serves the same purpose.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Setting up the Http service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000003","sortNo":3,"contentFormatId":"1","contentTxt":"In our application component, we need to import HTTP_PROVIDERS, and then send it along to our bootstrap function so the injector knows to configure it on the way up. Here's the relevant code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000004","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000005","sortNo":5,"contentFormatId":"1","contentTxt":"This is somewhat similar to the Angular 1 way of bootstrapping a library, but in Angular 2 we don't get Http for free as part of a built-in module. Everything is added by you, the developer, when bootstrapping the app or providing a component. Doing this should make applications that don't rely on these libraries boot quicker and also consume less overall memory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Angular 2 Asynchrony and stream-based processing with Reactive Observables","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000007","sortNo":7,"contentFormatId":"1","contentTxt":"The Angular 2 team has thrown in to the Reactive programming game by making async calls use the RxJs library from Microsoft. This library, Reactive Extensions for JavaScript, provides an event-driven stream of notifications to a caller by issuing a return type known as an Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000008","sortNo":8,"contentFormatId":"1","contentTxt":"The caller typically executes a call to an Angular 2 Service (or component method), and is fed an Observable, which it then can hook a chain of functional programming methods to just like ES6 generators and iterators do, except that the data is coming back asynchronously. Think of it as iterating what you think is a list of results, but these results are fed as they are fetched from the server, even via multiple web calls.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000170","sortNo":9,"contentFormatId":"1","contentTxt":"A single-component Observable","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000171","sortNo":10,"contentFormatId":"1","contentTxt":"In the single-component mode, here's how you use the Http service. We'll start assuming we've bootstrapped the application using the HTTP_PROVIDERS dependency as described above.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000172","sortNo":11,"contentFormatId":"1","contentTxt":"Here are the imports required:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000173","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000174","sortNo":13,"contentFormatId":"1","contentTxt":"We'll need Task, which is a simple value object we've defined elsewhere, and we'll need Http - beyond that the Component and CORE_DIRECTIVES imports are required to mount our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000175","sortNo":14,"contentFormatId":"1","contentTxt":"Next, the component annotation and view template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000176","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000177","sortNo":16,"contentFormatId":"1","contentTxt":"You'll note that we are no longer using @View in this example. As of recent builds (Alpha 40?) they've added some of the view annotation properties such as template to @Component to cut down on the number of objects and annotations required.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000178","sortNo":17,"contentFormatId":"1","contentTxt":"Also, note the back-ticks for the super handy multi-line embedded templates. These alone are worth their weight in gold.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000179","sortNo":18,"contentFormatId":"1","contentTxt":"The iterator (*ng-for=\"#task of tasks\") is similar to Angular 1's ng-repeat statement, just with a different syntax. As with the old ngFor, it creates a nested template data context (think scope but we don't call it that anymore) and stores task within it. The # is shorthand, you would have to specify var task instead. (So is the * in *ng-for but that's for another blog post).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000180","sortNo":19,"contentFormatId":"1","contentTxt":"Beyond that, the component annotation is a pretty standard one - we include the CORE_DIRECTIVES array of components so we gain access to ngForOf.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000181","sortNo":20,"contentFormatId":"1","contentTxt":"The TaskComponent class","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000182","sortNo":21,"contentFormatId":"1","contentTxt":"Now, we'll discuss the class definition. I've commented that one inline and will provide some discussion below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000183","sortNo":22,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000184","sortNo":23,"contentFormatId":"1","contentTxt":"Let's step through what a component would have to do if it made the http.get call itself and processed the results, putting them in the tasks collection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000185","sortNo":24,"contentFormatId":"1","contentTxt":"The Http get method","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000186","sortNo":25,"contentFormatId":"1","contentTxt":"The get method of http (from the angular/http/Http class) creates an Observable object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000187","sortNo":26,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000188","sortNo":27,"contentFormatId":"1","contentTxt":"In this 'all-in-one' case where the entire process is performed from a @Component, we work with the observable directly, telling Angular how we should process the results.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000189","sortNo":28,"contentFormatId":"1","contentTxt":"Mapping the initial result to JSON","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000190","sortNo":29,"contentFormatId":"1","contentTxt":"We begin our processing by mapping the result object (providing a result object for the incoming request) using map:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000191","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000192","sortNo":31,"contentFormatId":"1","contentTxt":"The map function processes a result from the observable (in our case, the fetched payload of an http.get call), using an ES6 arrow function.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000193","sortNo":32,"contentFormatId":"1","contentTxt":"The arrow function's parameter res is actually a ResponseData object, and can be parsed as binary (blob()), string (text()) or, in our case, JavaScript via JSON (json()) content via its helper methods.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000194","sortNo":33,"contentFormatId":"1","contentTxt":"So in this way, we're already transforming the output from a raw HTTP Response to a JavaScript object. This is, indeed, a step we don't normally take from Angular 1, but it makes our content a bit more flexible to deal with.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000195","sortNo":34,"contentFormatId":"1","contentTxt":"Second-level transformation into Value Objects","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000196","sortNo":35,"contentFormatId":"1","contentTxt":"We can further transform with a second map request, as each map mutates the response and provides a more specific observable:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000197","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000198","sortNo":37,"contentFormatId":"1","contentTxt":"In this mapping method, we receive the array of JSON results (hence the type <any>), create a typed array of our output type (Task, which we'll show below), and iterate through them with forEach. In TypeScript + Angular 2, we don't need to worry about our browser providing the Array.prototype.forEach method, since we'll be using the es6-shim for that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000199","sortNo":38,"contentFormatId":"1","contentTxt":"After we're done with our mappings, we can subscribe to the observable, handing the answer off to our view by binding the result to the tasks property of the class instance:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000200","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000201","sortNo":40,"contentFormatId":"1","contentTxt":"As you might have guessed, this is a one-shot observable. It only does one request, and then it completes. Later on, we'll see how to emit multiple events, using almost the same client code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000202","sortNo":41,"contentFormatId":"1","contentTxt":"The entire component body","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000203","sortNo":42,"contentFormatId":"1","contentTxt":"Here is the entire component body, with comments inline:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000204","sortNo":43,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000205","sortNo":44,"contentFormatId":"1","contentTxt":"Here is the Task object:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000206","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000207","sortNo":46,"contentFormatId":"1","contentTxt":"Separating the Component and its data Services","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000208","sortNo":47,"contentFormatId":"1","contentTxt":"So now you might be thinking \"This is fine, but we started this way prototyping Angular 1 code, and we moved to services.\" You're right, you did. And the process now is very similar. Let's move the Http code to a service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000209","sortNo":48,"contentFormatId":"1","contentTxt":"Creating a Service in Angular2 - the TaskService","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000210","sortNo":49,"contentFormatId":"1","contentTxt":"First, we'll look at the service itself. We'll move the imports over:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000211","sortNo":50,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000212","sortNo":51,"contentFormatId":"1","contentTxt":"First, we'll look at the service itself. We'll move the imports over:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000213","sortNo":52,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000214","sortNo":53,"contentFormatId":"1","contentTxt":"We export the service class so we can import it later in the controller. This is how simple ES6 module syntax is: export a class from a file, then use import { ClassName } from 'filename'; to import it later.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000215","sortNo":54,"contentFormatId":"1","contentTxt":"Dependency injection in the TaskService","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000216","sortNo":55,"contentFormatId":"1","contentTxt":"Now we just use the constructor to inject the dependency. One way to do it is this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000217","sortNo":56,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000218","sortNo":57,"contentFormatId":"1","contentTxt":"Pretty easy. Another way to do it would be to use the @Inject annotation on each injected constructor parameter, but this one is cleaner. Again another thing the ThoughtRam article above will go into detail about.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000219","sortNo":58,"contentFormatId":"1","contentTxt":"Provide the method to observe","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000220","sortNo":59,"contentFormatId":"1","contentTxt":"Now, we'll see how we do the service-side call - we just literally return the result of the last map call - which is still an Observable - back to the caller.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000221","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000222","sortNo":61,"contentFormatId":"1","contentTxt":"Now, our refactored Component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000223","sortNo":62,"contentFormatId":"1","contentTxt":"If we're role playing Angular 1 -> Angular 2 migration here, the Component takes the place of our Controller and View. So we'll inject the TaskService into the controller and use the getTasks() method, and subscribe to the call results. The entire component is listed here because by now you should see the simplification:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000224","sortNo":63,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000225","sortNo":64,"contentFormatId":"1","contentTxt":"Why Observables are better for Angular2","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000226","sortNo":65,"contentFormatId":"1","contentTxt":"It should become apparent that Observables provide greater power to the developer. You can decide where you break the chain and export the observable, and both local and extra-method observables work in exactly the same way. But there are some really nifty additional features at work here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000227","sortNo":66,"contentFormatId":"1","contentTxt":"I'm about to paraphrase / lift some code ideas from Rob Wormald's talk - Everything is a stream. To really dig into what Angular 2 and observables can do, watch that talk.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000228","sortNo":67,"contentFormatId":"1","contentTxt":"For example, you can ask the server to retry your call several times:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000229","sortNo":68,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000230","sortNo":69,"contentFormatId":"1","contentTxt":"In addition you can poll for results - by using Observable.interval:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000231","sortNo":70,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000232","sortNo":71,"contentFormatId":"1","contentTxt":"What the what? Ok, so the pollTasks() method emits a call every 10 seconds, which triggers the call inside of flatMapLatest - we're basically ignoring the result of that event, and using it to trigger the http.get method to fetch our data. We'll map it into JSON each time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000233","sortNo":72,"contentFormatId":"1","contentTxt":"The caller of our pollTasks() method just gets an observable, which is emitting content every 10 seconds. To use it, the subscriber subscribe()s as usual, only this call is happening every 10 seconds, not once. You should turn it off once you don't care anymore, hence the unsubscribe() method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000234","sortNo":73,"contentFormatId":"1","contentTxt":"Also the flatMapLatest call is really interesting - any calls generated by previous events are canceled, including their in-flight HTTP method calls. Try doing that with a promise!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000235","sortNo":74,"contentFormatId":"1","contentTxt":"学习observable的地址：","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601140000000236","sortNo":75,"contentFormatId":"1","contentTxt":"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md","contentBinary":"","contentPoster":"","contentUrl":null}]
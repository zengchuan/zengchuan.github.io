[{"id":"201602250000000056","sortNo":1,"contentFormatId":"1","contentTxt":"NG-NL has happened and it was awesome! I had the honour of giving a talk about change detection in Angular 2 and it seemed to be a huge success as attendees liked it a lot. With this article, we’d like to transform the talk into a written version, so everyone can read about how Angular’s change detection works and how to make it faster for our use cases. If you’re interested in the talk, you can view the slides here and as soon as the talk recording is up, you’ll find it here as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000057","sortNo":2,"contentFormatId":"1","contentTxt":"Now let’s take a look at this beast.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000058","sortNo":3,"contentFormatId":"1","contentTxt":"What’s Change Detection anyways?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000059","sortNo":4,"contentFormatId":"1","contentTxt":"The basic task of change detection is to take the internal state of a program and make it somehow visible to the user interface. This state can be any kind of objects, arrays, primitives, … just any kind of JavaScript data structures.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000060","sortNo":5,"contentFormatId":"1","contentTxt":"This state might end up as paragraphs, forms, links or buttons in the user interface and specifically on the web, it’s the Document Object Model (DOM). So basically we take data structures as input and generate DOM output to display it to the user. We call this process rendering.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000061","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000062","sortNo":7,"contentFormatId":"1","contentTxt":"However, it gets trickier when a change happens at runtime. Some time later when the DOM has already been rendered. How do we figure out what has changed in our model, and where do we need to update the DOM? Accessing the DOM tree is always expensive, so not only do we need to find out where updates are needed, but we also want to keep that access as tiny as possible.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000063","sortNo":8,"contentFormatId":"1","contentTxt":"This can be tackled in many different ways. One way, for instance, is simply making a http request and re-rendering the whole page. Another approach is the concept of diffing the DOM of the new state with the previous state and only render the difference, which is what ReactJS is doing with Virtual DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000064","sortNo":9,"contentFormatId":"1","contentTxt":"Tero has written an awesome article on Change and its detection in JavaScript frameworks, we recommend checking it out if you’re more interested in how different frameworks solve this issue. In this article we’re going to focus on Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000284","sortNo":10,"contentFormatId":"1","contentTxt":"So basically the goal of change detection is always projecting data and its change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000285","sortNo":11,"contentFormatId":"1","contentTxt":"What causes change?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000286","sortNo":12,"contentFormatId":"1","contentTxt":"Now that we know what change detection is all about, we might wonder, when exactly can such a change happen? When does Angular know that it has to update the view? Well, let’s take a look at the following code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000287","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000288","sortNo":14,"contentFormatId":"1","contentTxt":"If this is the first time you’re seeing an Angular 2 component, you might want to read our article on building a tabs component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000289","sortNo":15,"contentFormatId":"1","contentTxt":"The component above simply displays two properties and provides a method to change them when the button in the template is clicked. The moment this particular button is clicked is the moment when application state has changed, because it changes the properties of the component. That’s the moment we want to update the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000290","sortNo":16,"contentFormatId":"1","contentTxt":"Here’s another one:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000291","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000292","sortNo":18,"contentFormatId":"1","contentTxt":"This component holds a list of contacts and when it initializes, it performs a http request. Once this request comes back, the list gets updated. Again, at this point, our application state has changed so we will want to update the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000293","sortNo":19,"contentFormatId":"1","contentTxt":"Basically application state change can be caused by three things:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000294","sortNo":20,"contentFormatId":"1","contentTxt":"1. Events - click, submit, …","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000295","sortNo":21,"contentFormatId":"1","contentTxt":"2. XHR - Fetching data from a remote server","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000296","sortNo":22,"contentFormatId":"1","contentTxt":"3. Timers - setTimeout(), setInterval()","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000297","sortNo":23,"contentFormatId":"1","contentTxt":"They are all asynchronous. Which brings us to the conclusion that, basically whenever some asynchronous operation has been performed, our application state might have changed. This is when someone needs to tell Angular to update the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000298","sortNo":24,"contentFormatId":"1","contentTxt":"Who notifies Angular?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000299","sortNo":25,"contentFormatId":"1","contentTxt":"Alright, we now know what causes application state change. But what is it that tells Angular, that at this particular moment, the view has to be updated?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000300","sortNo":26,"contentFormatId":"1","contentTxt":"Angular allows us to use native APIs directly. There are no interceptor methods we have to call so Angular gets notified to update the DOM. Is that pure magic?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000301","sortNo":27,"contentFormatId":"1","contentTxt":"If you’ve followed our latest articles, you know that Zones take care of this. In fact, Angular comes with its own zone called NgZone, which we’ve written about in our article Zones in Angular 2. You might want to read that, too.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000302","sortNo":28,"contentFormatId":"1","contentTxt":"The short version is, that somewhere in Angular’s source code, there’s this thing called ApplicationRef, which listens to NgZones onTurnDone event. Whenever this event is fired, it executes a tick() function which essentially performs change detection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000303","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000304","sortNo":30,"contentFormatId":"1","contentTxt":"Change Detection","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000305","sortNo":31,"contentFormatId":"1","contentTxt":"Okay cool, we now know when change detection is triggered, but how is it performed? Well, the first thing we need to notice is that, in Angular 2, each component has its own change detector.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000306","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000307","sortNo":33,"contentFormatId":"1","contentTxt":"This is a significant fact, since this allows us to control, for each component individually, how and when change detection is performed! More on that later.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000308","sortNo":34,"contentFormatId":"1","contentTxt":"Let’s assume that somewhere in our component tree an event is fired, maybe a button has been clicked. What happens next? We just learned that zones execute the given handler and notify Angular when the turn is done, which eventually causes Angular to perform change detection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000309","sortNo":35,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000310","sortNo":36,"contentFormatId":"1","contentTxt":"Since each component has its own change detector, and an Angular application consists of a component tree, the logical result is that we’re having a change detector tree too. This tree can also be viewed as a directed graph where data always flows from top to bottom.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000311","sortNo":37,"contentFormatId":"1","contentTxt":"The reason why data flows from top to bottom, is because change detection is also always performed from top to bottom for every single component, every single time, starting from the root component. This is awesome, as unidirectional data flow is more predictable than cycles. We always know where the data we use in our views comes from, because it can only result from its component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000312","sortNo":38,"contentFormatId":"1","contentTxt":"Another interesting observation is that change detection gets stable after a single pass. Meaning that, if one of our components causes any additional side effects after the first run during change detection, Angular will throw an error.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000313","sortNo":39,"contentFormatId":"1","contentTxt":"Performance","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000314","sortNo":40,"contentFormatId":"1","contentTxt":"By default, even if we have to check every single component every single time an event happens, Angular is very fast. It can perform hundreds of thousands of checks within a couple of milliseconds. This is mainly due to the fact that Angular generates VM friendly code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000315","sortNo":41,"contentFormatId":"1","contentTxt":"What does that mean? Well, when we said that each component has its own change detector, it’s not like there’s this single generic thing in Angular that takes care of change detection for each individual component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000316","sortNo":42,"contentFormatId":"1","contentTxt":"The reason for that is, that it has to be written in a dynamic way, so it can check every component no matter what its model structure looks like. VMs don’t like this sort of dynamic code, because they can’t optimize it. It’s considered polymorphic as the shape of the objects isn’t always the same.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000317","sortNo":43,"contentFormatId":"1","contentTxt":"Angular creates change detector classes at runtime for each component, which are monomorphic, because they know exactly what the shape of the component’s model is. VMs can perfectly optimize this code, which makes it very fast to execute. The good thing is that we don’t have to care about that too much, because Angular does it automatically.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000318","sortNo":44,"contentFormatId":"1","contentTxt":"Check out Victor Savkin’s talk on Change Detection Reinvented for a deeper explanation on this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000319","sortNo":45,"contentFormatId":"1","contentTxt":"Smarter Change Detection","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000320","sortNo":46,"contentFormatId":"1","contentTxt":"Again, Angular has to check every component every single time an event happens because… well, maybe the application state has changed. But wouldn’t it be great if we could tell Angular to only run change detection for the parts of the application that changed their state?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000321","sortNo":47,"contentFormatId":"1","contentTxt":"Yes it would, and in fact we can! It turns out there are data structures that give us some guarantees of when something has changed or not - Immutables and Observables. If we happen to use these structures or types, and we tell Angular about it, change detection can be much much faster. Okay cool, but how so?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000322","sortNo":48,"contentFormatId":"1","contentTxt":"Understanding Mutability","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000323","sortNo":49,"contentFormatId":"1","contentTxt":"In order to understand why and how e.g. immutable data structures can help, we need to understand what mutability means. Assume we have the following component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000324","sortNo":50,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000325","sortNo":51,"contentFormatId":"1","contentTxt":"VCardApp uses <v-card> as a child component, which has an input property vData. We’re passing data to that component with VCardApp’s own vData property. vData is an object with two properties. In addition, there’s a method changeData(), which changes the name of vData. No magic going on here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000326","sortNo":52,"contentFormatId":"1","contentTxt":"The important part is that changeData() mutates vData by changing its name property. Even though that property is going to be changed, the vData reference itself stays the same.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000327","sortNo":53,"contentFormatId":"1","contentTxt":"What happens when change detection is performed, assuming that some event causes changeData() to be executed? First, vData.name gets changed, and then it’s passed to <v-card>. <v-card>’s change detector now checks if the given vData is still the same as before, and yes, it is. The reference hasn’t changed. However, the name property has changed, so Angular will perform change detection for that object nonetheless.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000328","sortNo":54,"contentFormatId":"1","contentTxt":"Because objects are mutable by default in JavaScript (except for primitives), Angular has to be conservative and run change detection every single time for every component when an event happens.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000329","sortNo":55,"contentFormatId":"1","contentTxt":"This is where immutable data structures come into play.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000330","sortNo":56,"contentFormatId":"1","contentTxt":"Immutable Objects","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000331","sortNo":57,"contentFormatId":"1","contentTxt":"Immutable objects give us the guarantee that objects can’t change. Meaning that, if we use immutable objects and we want to make a change on such an object, we’ll always get a new reference with that change, as the original object is immutable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000332","sortNo":58,"contentFormatId":"1","contentTxt":"This pseudo code demonstrates it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000333","sortNo":59,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000334","sortNo":60,"contentFormatId":"1","contentTxt":"someAPIForImmutables can be any API we want to use for immutable data structures. However, as we can see, we can’t simply change the name property. We’ll get a new object with that particular change and this object has a new reference. Or in short: If there’s a change, we get a new reference.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000335","sortNo":61,"contentFormatId":"1","contentTxt":"Reducing the number of checks","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000336","sortNo":62,"contentFormatId":"1","contentTxt":"Angular can skip entire change detection subtrees when input properties don’t change. We just learned that a “change” means “new reference”. If we use immutable objects in our Angular app, all we need to do is tell Angular that a component can skip change detection, if its input hasn’t changed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000337","sortNo":63,"contentFormatId":"1","contentTxt":"Let’s see how that works by taking a look at <v-card>:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000338","sortNo":64,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000339","sortNo":65,"contentFormatId":"1","contentTxt":"As we can see, VCardCmp only depends on its input properties. Great. We can tell Angular to skip change detection for this component’s subtree if none of its inputs changed by setting the change detection strategy to OnPush like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000340","sortNo":66,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000341","sortNo":67,"contentFormatId":"1","contentTxt":"That’s it! Now imagine a bigger component tree. We can skip entire subtrees when immutable objects are used and Angular is informed accordingly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000342","sortNo":68,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000343","sortNo":69,"contentFormatId":"1","contentTxt":"Jurgen Van De Moere has written an in-depth article on how he made a minesweeper game built with Angular 2 and Immutable.js blazingly fast. Make sure to check that one out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000344","sortNo":70,"contentFormatId":"1","contentTxt":"Observables","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000345","sortNo":71,"contentFormatId":"1","contentTxt":"As mentioned earlier, Observables also give us some certain guarantees of when a change has happened. Unlike immutable objects, they don’t give us new references when a change is made. Instead, they fire events we can subscribe to in order to react to them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000346","sortNo":72,"contentFormatId":"1","contentTxt":"So, if we use Observables and we want to use OnPush to skip change detector subtrees, but the reference of these objects will never change, how do we deal with that? It turns out Angular has a very smart way to enable paths in the component tree to be checked for certain events, which is exactly what we need in that case.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000347","sortNo":73,"contentFormatId":"1","contentTxt":"To understand what that means, let’s take a look at this component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000348","sortNo":74,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000349","sortNo":75,"contentFormatId":"1","contentTxt":"Let’s say we build an e-commerce application with a shopping cart. Whenever a user puts a product into the shopping cart, we want a little counter to show up in our UI, so the user can see the amount of products in the cart.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000350","sortNo":76,"contentFormatId":"1","contentTxt":"CartBadgeCmp does exactly that. It has a counter and an input property addItemStream, which is a stream of events that gets fired, whenever a product is added to the shopping cart.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000351","sortNo":77,"contentFormatId":"1","contentTxt":"We won’t go into much detail on how observables work in this article. If you want to learn more about observables, make sure to read our article on taking advantage of Observables in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000352","sortNo":78,"contentFormatId":"1","contentTxt":"In addition, we set the change detection strategy to OnPush, so change detection isn’t performed all the time, only when the component’s input properties change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000353","sortNo":79,"contentFormatId":"1","contentTxt":"However, as mentioned earlier, the reference of addItemStream will never change, so change detection is never performed for this component’s subtree. This is a problem because the component subscribes to that stream in its ngOnInit life cycle hook and increments the counter. This is application state change and we want to have this reflected in our view right?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000354","sortNo":80,"contentFormatId":"1","contentTxt":"Here’s what our change detector tree might look like (we’ve set all to OnPush). No change detection will be performed when an event happens:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000355","sortNo":81,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000356","sortNo":82,"contentFormatId":"1","contentTxt":"How can we inform Angular about this change? How can we tell Angular that change detection needs to be performed for this component, even though the entire tree is set to OnPush?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000357","sortNo":83,"contentFormatId":"1","contentTxt":"No worries, Angular has us covered. As we’ve learned earlier, change detection is always performed from top to bottom. So what we need is a way to detect changes for the entire path of the tree to the component where the change happened. Angular can’t know which path it is, but we do.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000358","sortNo":84,"contentFormatId":"1","contentTxt":"We can access a component’s ChangeDetectorRef via dependency injection, which comes with an API called markForCheck(). This method does exactly what we need! It marks the path from our component until root to be checked for the next change detection run.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000359","sortNo":85,"contentFormatId":"1","contentTxt":"Let’s inject it into our component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000360","sortNo":86,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000361","sortNo":87,"contentFormatId":"1","contentTxt":"Then, tell Angular to mark the path from this component until root to be checked:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000362","sortNo":88,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000363","sortNo":89,"contentFormatId":"1","contentTxt":"Boom, that’s it! Here’s what it looks like after the observable event is fired but before change detection kicked in:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000364","sortNo":90,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000365","sortNo":91,"contentFormatId":"1","contentTxt":"Now, when change detection is performed, it’ll simply go from top to bottom.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000366","sortNo":92,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000367","sortNo":93,"contentFormatId":"1","contentTxt":"How cool is that? Once the change detection run is over, it’ll restore the OnPush state for the entire tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000368","sortNo":94,"contentFormatId":"1","contentTxt":"There’s more…","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000369","sortNo":95,"contentFormatId":"1","contentTxt":"In fact there are some more APIs which we haven’t covered in this article, but feel free to check out the slides and/or the recording of the talk.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000370","sortNo":96,"contentFormatId":"1","contentTxt":"Hopefully this made it a little bit more clear how using immutable data structures or Observables can make our Angular application even faster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000371","sortNo":97,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602250000000372","sortNo":98,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/thoughtram/angular2-change-detection-demos\">https://github.com/thoughtram/angular2-change-detection-demos</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
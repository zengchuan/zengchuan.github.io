[{"id":"201604050000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Static Components can be great, however most Components have the need for data to be passed in and out of them. Usually we would pass data into a Component, the Component would go to work, and let the parent Component know something has changed, passing back the changed value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000002","sortNo":2,"contentFormatId":"1","contentTxt":"We’ll need a parent Component where we can set some initial data:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000003","sortNo":3,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000004","sortNo":4,"contentFormatId":"1","contentTxt":"On the class AppComponent we’ve declared myValue with the type number and value of 2. Next we need to create a custom attribute name on the <counter> Component to pass this initial data into, let’s call it counterValue:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000005","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Note how we’ve used [counterValue] with square brackets around it, this tells Angular what property to bind to. This value corresponds with the internal counterValue property inside our CounterComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000007","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000008","sortNo":8,"contentFormatId":"1","contentTxt":"@Input decorator for property bindings","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Let’s focus on public counterValue:number = 0; now, it’s currently an inner value of the CounterComponent, however we would ideally like to set the initial data and keep a bound reference from the parent. This is where we need to use Angular 2’s @Input() decorator. We import Input from the Angular core, and inside the class CounterComponent it’s a simple switch out:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000010","sortNo":10,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000011","sortNo":11,"contentFormatId":"1","contentTxt":"Note how @Input counterValue sets a default value of 0, which means if no data is passed in then this value will be used instead.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Without @Input decorator","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Let’s dive a little deeper. Using @Input is a preferred approach, however we don’t have to use it. The @Component decorator is rather awesome, and provides us an inputs property, which is an Array of @Input equivalents that we wish to use inside the particular Component. Refactoring the above code we can do this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000014","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Custom public property naming","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000016","sortNo":16,"contentFormatId":"1","contentTxt":"One thing we might want to keep internally inside CounterComponent is a property name such as counterValue, however expose a different property name to be able to bind to. Let’s say I want to expose init as the property name to bind to, so we’d use <counter [init]=\"\"></counter> instead of <counter [counterValue]=\"\"></counter>, we can do that by passing a custom String into the @Input decorator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000017","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000018","sortNo":18,"contentFormatId":"1","contentTxt":"We can also achieve the same thing with the inputs: [] property by setting the value of ['counterValue:init']:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000019","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000020","sortNo":20,"contentFormatId":"1","contentTxt":"The rule for this one is internalProp:externalProp, in this case counterValue:init.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201603230000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In Web Components, we had the <content> element, which was recently deprecated, which acted as a Shadow DOM insertion point. Angular 2 allows Shadow DOM through the use of ViewEncapsulation. Early alpha versions of Angular 2 adopted the <content> element, however due to the nature of a bunch of Web Component helper elements being deprecated, it was changed to <ng-content>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Single-slot content Projection","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000003","sortNo":3,"contentFormatId":"1","contentTxt":"In Angular 2’s single-slot content projection, the boilerplate is so much nicer and more descriptive. We simply use the <ng-content> element in our Component and that’s it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000004","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000005","sortNo":5,"contentFormatId":"1","contentTxt":"Now to use the element we import {MyComponent}, include it as a dependency in directives: [] and project some content between those <my-content> tags:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000006","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000007","sortNo":7,"contentFormatId":"1","contentTxt":"DOM output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000008","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Multi-slot content projection","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Multi-slot is just as easy as you’d think as well. Much like multi-slot in Angular 1.x, we use named slots again. However the only difference is instead of aliasing the DOM reference against a custom transclude: {} property, we talk to the DOM node directly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000011","sortNo":11,"contentFormatId":"1","contentTxt":"Let’s assume the following markup inside out Angular 2 my-app Component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000012","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Here we’re using custom elements, which are not created as separate components, merely just node references. Let’s grab those references and tell Angular to inject where appropriate. The only change we need to make from Angular 1.x thinking is adding a dedicated select=\"\" attribute to the <ng-content> element:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000014","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000015","sortNo":15,"contentFormatId":"1","contentTxt":"This internally fetches the relevant DOM node, which in this case are <my-component-title> and <my-component-content>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000016","sortNo":16,"contentFormatId":"1","contentTxt":"DOM output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000017","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000018","sortNo":18,"contentFormatId":"1","contentTxt":"We don’t have to use a custom element approach as above when declaring content to be projected, we can use regular elements and target them the way we talk to elements with document.querySelector:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000019","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000020","sortNo":20,"contentFormatId":"1","contentTxt":"And corresponding template changes inside MyComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000021","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null}]
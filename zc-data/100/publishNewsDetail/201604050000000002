[{"id":"201604050000000021","sortNo":1,"contentFormatId":"1","contentTxt":"Angular 2 Components have a far better way of notifying parent Components that something has happened via events. There is no longer two-way data binding in Angular 2 in the same way we knew it in Angular 1.x, it’s designed around a uni-directional data flow system that adopts a much more reasonable approach to application development. Let’s finalise the basics of parent-child and child-parent communication.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000022","sortNo":2,"contentFormatId":"1","contentTxt":"This tutorial will cover local Component events using the EventEmitter API and @Output decorator, which follows nicely from the previous article on passing data in Angular 2 Components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000023","sortNo":3,"contentFormatId":"1","contentTxt":"Parent “Listener”","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000024","sortNo":4,"contentFormatId":"1","contentTxt":"Let’s take our parent Component we know well by now and setup a function called myValueChange on the class that we want to invoke when we bind it to our CounterComponent’s API’:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000025","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000026","sortNo":6,"contentFormatId":"1","contentTxt":"On the class AppComponent we’ve declared myValueChange which accepts event as an argument. Next we need to create a custom attribute name on the <counter> Component to hook this function into, let’s call it counterChange:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000027","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000028","sortNo":8,"contentFormatId":"1","contentTxt":"Note how we’ve used (counterChange) with parentheses around it, this tells Angular that this is an event binding, similar to (click). Now we need to mirror this API inside the CounterComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000029","sortNo":9,"contentFormatId":"1","contentTxt":"@Output and EventEmitter","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000030","sortNo":10,"contentFormatId":"1","contentTxt":"This is where we need to use Angular 2’s @Output() decorator. We import Output from the Angular core, and inside the class CounterComponent` add the goodness:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000031","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000032","sortNo":12,"contentFormatId":"1","contentTxt":"Note how @Output counterChange is set to a new instance of EventEmitter, this @Output decorator makes the counterChange property available as an event binding like we saw in the above template (counterChange).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000033","sortNo":13,"contentFormatId":"1","contentTxt":"EventEmitter API","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000034","sortNo":14,"contentFormatId":"1","contentTxt":"Nearly there, we would like to tell the parent Component that the counterChange event has happened when the child Component actually updates the value, which as we know happens on a click event. Let’s emit an event there, as it seems a logical place to do so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000035","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000036","sortNo":16,"contentFormatId":"1","contentTxt":"Note that I’m emitting an Object with a property of value, you don’t have to do this however it looks nicer when using the event in a callback in the parent (event.value being more explicit).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000037","sortNo":17,"contentFormatId":"1","contentTxt":"Our parent Component can now fetch the $event Object, as we’ve passed it into the template using (counterChange)=\"myValueChange($event);\".","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000038","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000039","sortNo":19,"contentFormatId":"1","contentTxt":"Without @Output decorator","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000040","sortNo":20,"contentFormatId":"1","contentTxt":"Like with @Input and inputs: [] in the previous article, we have the same capabilities with @Output. The @Component decorator is rather awesome, and provides us an outputs property, which is an Array of @Output equivalents that we wish to use inside the particular Component. Refactoring the above code we can do this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000041","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000042","sortNo":22,"contentFormatId":"1","contentTxt":"Custom public property naming","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000043","sortNo":23,"contentFormatId":"1","contentTxt":"One thing we might want to keep internally inside CounterComponent is a property name such as counterChange, however expose a different property name to be able to listen to. Let’s say I want to expose change as the property name that the event is bound to, so we’d use <counter (change)=\"myValueChange($event);\"></counter> instead of <counter (counterChange)=\"myValueChange($event);\"></counter>, we can do that by passing a custom String into the @Output decorator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000044","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000045","sortNo":25,"contentFormatId":"1","contentTxt":"We can also achieve the same thing with the outputs: [] property by setting the value of ['counterChange:change']:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000046","sortNo":26,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000047","sortNo":27,"contentFormatId":"1","contentTxt":"The rule for this one is internalProp:externalProp, in this case counterChange:change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000048","sortNo":28,"contentFormatId":"1","contentTxt":"Altogether the CounterComponent has the following properties for @Input and @Output based on the above custom property setups:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604050000000049","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201608110000000018","sortNo":1,"contentFormatId":"1","contentTxt":"As I've been digging into Angular 2 over the past several months, one of the features that seems oddly absent is a basic logging service. In Angular 1.x, we had the $log service that could be safely invoked whether or not the underlying \"console\" object existed. In Angular 2, now that we have a multi-platform experience (think NativeScript, think Universal JavaScript), it would seem that a basic platform-safe logging service is more important than ever. As such, I wanted to take a run at implementing one for Angular 2 RC 4.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000019","sortNo":2,"contentFormatId":"1","contentTxt":"Unlike many business-oriented services that you might build in an Angular 2 application, basic logging is tied to the platform, not the application. As such, it has to be provided at the platform level, not the application level. And, in an Angular 2 application, that means that we have to provide it during the bootstrapping process.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000020","sortNo":3,"contentFormatId":"1","contentTxt":"One byproduct of this configuration is that the application can't know which implementation it's receiving during dependency-injection (DI); is it getting the one that works in the browser? the one that works in Node.js? the one that works in NativeScript? It doesn't care - it just asks for the \"logger\" and the one provided to the platform is the one that gets injected.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000021","sortNo":4,"contentFormatId":"1","contentTxt":"In order to keep the dependency-injection simple in NG2 TypeScript, the type annotation for the dependency has to be a Class. This means that we have to have some default implementation for the logger class that can be used both as the DI token and as the override-hook during bootstrapping. For this, I've created a shell class that does nothing but implement empty methods:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000022","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000023","sortNo":6,"contentFormatId":"1","contentTxt":"As you can see, this default-log module defines both the logger interface and the default implementation of the logger service. Once we have this class, we can use it as the DI-token during bootstrapping. For example, in the following main.ts, we're telling Angular to use our custom, browser-specific logging implementation as the class for the Logger DI token:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000024","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000025","sortNo":8,"contentFormatId":"1","contentTxt":"This tells Angular to provide the cached \"ConsoleLogService\" class instance any time a component or service in the application requests \"Logger\" as a dependency. Our ConsoleLogService class adheres to the Logger interface but provides an implementation that logs to the browser console:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000026","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000027","sortNo":10,"contentFormatId":"1","contentTxt":"Even though we know this is the implementation for the browser platform, I'm still including guard-statements for the existence of the \"console\" and the log-level methods. This way, we can ensure that the logging service never throws an error regardless of random cross-browser differences in the console implementation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000028","sortNo":11,"contentFormatId":"1","contentTxt":"And, once we have this ConsoleLogService being provided as the Logger implementation, we can now inject it into our application using the Logger DI token:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000029","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000030","sortNo":13,"contentFormatId":"1","contentTxt":"Here, the root component is requiring the Logger service, which the platform bootstrapper associates with our custom ConsoleLogService. Therefore, when we go to invoke the method on the user-interface (UI), it ends up logging to the browser console:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000031","sortNo":14,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201608110000000032","sortNo":15,"contentFormatId":"1","contentTxt":"I'm still very much trying to wrap my head around a multi-platform, or should I say platform-agnostic architecture; when stuff just needed to work \"in the browser,\" it was a much more simple mental model. Now that stuff has to work \"everywhere,\" you need to start thinking about what is application-specific and what is platform-specific. Something like a logging service seem, at least ot me, a platform-specific concern. That said, I'm still very unsure about many aspects of this facet of Angular 2 development; so, take this post from that perspective.","contentBinary":"","contentPoster":"","contentUrl":null}]
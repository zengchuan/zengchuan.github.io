[{"id":"201603010000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In this article I will demonstrate how we can use Observables to implement a basic pub sub example.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Angular 1.x supports custom event handling, but I always thought the implementation was a bit cumbersome. Through functions like emit and broadcast you can trigger custom events, but you have keep in mind which direction the event travels in the object hierarch â€“ up or down. You also have to consider the reach of the event based on whether it was triggered via $rootScope or regular $scope.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Angular 2.0 is really pushing the concept of Observables, so in this article I will show how to use an Observable to trigger custom events in order to implement basic pub sub.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000004","sortNo":4,"contentFormatId":"1","contentTxt":"I am still new to Observables, so I am far from an expert, but I mainly view it as an alternative way of looking at asynchronous event processing. The RxJs community has presented the idea that any series of events can be modeled as one or many asynchronous arrays. The array comparison is obvious since the Observable API is heavily influenced by standard array functions like map, forEach and filter. In fact it feels a bit like a lodash for anything asynchronous.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000005","sortNo":5,"contentFormatId":"1","contentTxt":"Starting to think in terms of Observables is a bit of a pivot, but the underlying concept is relatively straightforward and consists of two parts - Observer and Observable. The names are similar, but an Observable is something that emits events that can be observed by an Observer. In short the Observer observes and the Observable is producing events that are observed. The key idea is that the Observer may subscribe to events from the Observable for as long has the Observer is interested in the events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000006","sortNo":6,"contentFormatId":"1","contentTxt":"RxJs offers a construct called Subject which is an object that can double as both an Observer and an Observable. In order to encapsulate the emitted event I have sub classed Subject and created my own CustomerEventEmitter class. It's technically not necessary to sub class Subject, but I like to encapsulate the event and control the API.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000007","sortNo":7,"contentFormatId":"1","contentTxt":"In my sample I have included a producer component where my Observable emits that a customer has been created. On the other side there is a consumer component where customers are processed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000008","sortNo":8,"contentFormatId":"1","contentTxt":"I have wrapped the CustomerEventEmitter in the simple service shown below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000009","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000010","sortNo":10,"contentFormatId":"1","contentTxt":"The service is very simple since all it does it expose a stream of Customer objects. Keep in mind this Stream is the underlying Subject, which represents both Observer and Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000011","sortNo":11,"contentFormatId":"1","contentTxt":"On the producer side I am calling the emit function to publish a new Customer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000012","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Finally on the subscriber side I am subscribing to the stream of Customer objects by calling subscribe().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000014","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000015","sortNo":15,"contentFormatId":"1","contentTxt":"The subscription will last for as long as you want, but you may stop it at any time by calling unsubscribe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Anyway, this example just shows you the tip of the iceberg when it comes to the capabilities of Observables. In future posts I will try to include more advanced scenarios.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000017","sortNo":17,"contentFormatId":"1","contentTxt":"sourcecode:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603010000000018","sortNo":18,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/thelgevold/angular-2-samples\">https://github.com/thelgevold/angular-2-samples</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
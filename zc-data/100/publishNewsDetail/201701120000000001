[{"id":"201701120000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Let's start with a common use case. You have some data you get from external source (e.g. by calling API). You want to display it on screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000002","sortNo":2,"contentFormatId":"1","contentTxt":"However, instead of displaying it on the same component, you would like to pass the data to a child component to display.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000003","sortNo":3,"contentFormatId":"1","contentTxt":"The child component might has some logic to pre-process the data before showing on screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000004","sortNo":4,"contentFormatId":"1","contentTxt":"<strong>Our Example</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000005","sortNo":5,"contentFormatId":"1","contentTxt":"For example, you have a blogger component that will display blogger details and her posts. Blogger component will gets the list of posts from API.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Instead of writing the logic of displaying the posts in the blogger component, you want to reuse the posts component that is created by your teammate, what you need to do is pass it the posts data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000007","sortNo":7,"contentFormatId":"1","contentTxt":"The posts component will then group the posts by category and display accordingly, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000008","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000009","sortNo":9,"contentFormatId":"1","contentTxt":"<strong>Isn't That Easy?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000010","sortNo":10,"contentFormatId":"1","contentTxt":"t might look easy at the first glance. Most of the time we will initiate all the process during our component initialization time - during ngOnInit life cycle hook (refer here for more details on component life cycle hook).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000011","sortNo":11,"contentFormatId":"1","contentTxt":"In our case, you might think that we should run the post grouping logic during ngOnInit of the posts component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000012","sortNo":12,"contentFormatId":"1","contentTxt":"However, because the posts data is coming from server, when the blogger component passes the posts data to posts component, the posts component ngOnInit is already fired before the data get updated. Your post grouping logic will not be fired.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Our Post Interfaces and Data","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000014","sortNo":14,"contentFormatId":"1","contentTxt":"Let's start with interfaces.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Here is our mock posts data assets/mock-posts.json.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000017","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000018","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Blogger Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000019","sortNo":19,"contentFormatId":"1","contentTxt":"Let's take a look at our blogger component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000020","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000021","sortNo":21,"contentFormatId":"1","contentTxt":"We will get our mock posts data by issuing a HTTP GET call. Then, we assign the data to posts property. Subsequently, we bind posts to posts component in our view template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000022","sortNo":22,"contentFormatId":"1","contentTxt":"Please take note that, usually we will perform HTTP call in service. However, since it's not the focus of this tutorial (to shorten the tutorial), we will do that it in the same component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000023","sortNo":23,"contentFormatId":"1","contentTxt":"<strong>Posts Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000024","sortNo":24,"contentFormatId":"1","contentTxt":"Next, let's code out posts component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000025","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000026","sortNo":26,"contentFormatId":"1","contentTxt":"We have an input called data which will receive the posts data from parent component. In our case, blogger component will provide that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000027","sortNo":27,"contentFormatId":"1","contentTxt":"You can see that we implement two interfaces OnInit and OnChanges. These are the lifecycle hooks that Angular provide to us. We have not done anything in both ngOnInit and ngOnChanges just yet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000028","sortNo":28,"contentFormatId":"1","contentTxt":"The groupByCategory function is our core logic to group the posts by category. After the grouping, we will loop the result and display the grouped posts in our template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000029","sortNo":29,"contentFormatId":"1","contentTxt":"Remember to import these components in you module (e.g. app.module.ts) and add it under declarations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000030","sortNo":30,"contentFormatId":"1","contentTxt":"Save and run it. You will see a pretty empty page with the blogger name only. That's because we have not code our solution yet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000031","sortNo":31,"contentFormatId":"1","contentTxt":"<strong>Solution 1: Use *ngIf</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000032","sortNo":32,"contentFormatId":"1","contentTxt":"Solution one is the easiest. Use *ngIf in blogger component to delay the initialization of posts components. We will bind the post component only if the posts variable has a value. Then, we are safe to run our grouping logic in posts component ngOnInit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000033","sortNo":33,"contentFormatId":"1","contentTxt":"Our blogger component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000034","sortNo":34,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000035","sortNo":35,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000036","sortNo":36,"contentFormatId":"1","contentTxt":"A few things to note:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000037","sortNo":37,"contentFormatId":"1","contentTxt":"1. Since the grouping logic runs in ngOnInit, that means it will run only once. If there's any future updates on data (passed in from blogger component), it won't trigger again.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000038","sortNo":38,"contentFormatId":"1","contentTxt":"2. Therefore, if someone change the posts: Post[] property in the blogger component to posts: Post[] = [], that means our grouping logic will be triggered once with empty array. When the real data kicks in, it won't be triggered again.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000039","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>Solution 2: Use ngOnChanges</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000040","sortNo":40,"contentFormatId":"1","contentTxt":"ngOnChanges is a lifecycle hook that run whenever it detects changes to input properties. That means it's guaranteed that everytime data input value changed, our grouping logic will be triggered if we put our code here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000041","sortNo":41,"contentFormatId":"1","contentTxt":"Our blogger component, we don't need *ngIf anymore.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000042","sortNo":42,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000043","sortNo":43,"contentFormatId":"1","contentTxt":"Our posts component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000044","sortNo":44,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Please notes that changes is a key value pair object. The key is the name of the input property, in our case it's data. Whenever writing code in ngOnChanges, you may want to make sure that the logic run only when the target data changed, because you might have a few inputs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000046","sortNo":46,"contentFormatId":"1","contentTxt":"That's why we run our grouping logic only if there are changes in data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000047","sortNo":47,"contentFormatId":"1","contentTxt":"One thing I don't like about this solution is that we lose the strong typing and need to use magic string \"data\". In case we change the property name data to something else, we need to remember to change this as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000048","sortNo":48,"contentFormatId":"1","contentTxt":"Of course we can defined another interface for that, but that's too much work.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000049","sortNo":49,"contentFormatId":"1","contentTxt":"<strong>Solution 3: Use RxJs BehaviorSubject</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000050","sortNo":50,"contentFormatId":"1","contentTxt":"We can utilize RxJs BehaviorSubject to detect the changes. I suggest you take a look at the unit test of the official document here before we continue.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000051","sortNo":51,"contentFormatId":"1","contentTxt":"Just assume that BehaviorSubject is like a property with get and set abilities, plus an extra feature; you can subscribe to it. So whenever there are changes on the property, we will be notified, and we can act on that. In our case, it would be triggering the grouping logic.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000052","sortNo":52,"contentFormatId":"1","contentTxt":"There are no changes in our blogger component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000053","sortNo":53,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000054","sortNo":54,"contentFormatId":"1","contentTxt":"Let's update our post component to use BehaviorSubject.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000055","sortNo":55,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000056","sortNo":56,"contentFormatId":"1","contentTxt":"First of all, if you are not aware, Javacript supports getter and setter like C# and Java, check MDN for more info. In our case, we split the data to use getter and setter. Then, we have a private variable _data to hold the latest value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000057","sortNo":57,"contentFormatId":"1","contentTxt":"To set a value to BehaviorSubject, we use .next(theValue). To get the value, we use .getValue(), as simple as that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000058","sortNo":58,"contentFormatId":"1","contentTxt":"Then during component initialization, we subscribe to the _data, listen to the changes, and call our grouping logic whenever changes happens.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000059","sortNo":59,"contentFormatId":"1","contentTxt":"Take a note for observable and subject, you need to unsubscribe to avoid performance issues and possible memory leaks. You can do it manually in ngOnDestroyor you can use some operator to instruct the observable and subject to unsubscribe itself once it meet certain criteria.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000060","sortNo":60,"contentFormatId":"1","contentTxt":"In our case, we would like to unsubscribe once the groupPosts has value. We can add this line in our subscription to achieve that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000061","sortNo":61,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000062","sortNo":62,"contentFormatId":"1","contentTxt":"With this one line .takeWhile(() => !this.groupPosts), it will unsubscribe automatically once it's done. There are other ways to unsubscribe automatically as well, e.g take, take Util, but that's beyond this topic.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000063","sortNo":63,"contentFormatId":"1","contentTxt":"By using BehaviorSubject, we get strong typing, get to control and listen to changes. The only downside would be you need to write more code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000064","sortNo":64,"contentFormatId":"1","contentTxt":"<strong>Which One Should I Use?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000065","sortNo":65,"contentFormatId":"1","contentTxt":"The famous question comes with the famous answer: It depends.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000066","sortNo":66,"contentFormatId":"1","contentTxt":"Use *ngIf if you are sure that your changes run only once, it's very straightforward. Use ngOnChanges or BehaviorSubject if you want to listen to changes continuously or you want guarantee.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000067","sortNo":67,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701120000000068","sortNo":68,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/chybie/ng-musing/tree/master/src/app/three-ways\">https://github.com/chybie/ng-musing/tree/master/src/app/three-ways</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201606140000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Managing state transitions is one of the hardest parts of building applications. This is especially true on the web, where you also need to ensure that the state is reflected in the URL. In addition, we often want to split applications into multiple bundles and load them on demand. Doing this transparently isn’t trivial.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000002","sortNo":2,"contentFormatId":"1","contentTxt":"The Angular router is designed to solve these problems. Using the router, you can declaratively specify application state, manage state transitions while taking care of the URL, and load components on demand. In this article I will discuss the API of the router, as well as the mental model and the design principles behind it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>WHAT DO ROUTERS DO?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Before we jump into the specifics of the Angular Router, let’s talk about what routers do in general.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000005","sortNo":5,"contentFormatId":"1","contentTxt":"As you might know, an Angular 2 application is a tree of components. Some of these components are reusable UI components (e.g., list, table), and some are application components. The router cares about application components, or, to be more specific, about their arrangements. Let’s call such component arrangements router states. A router state defines what is visible on the screen.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000006","sortNo":6,"contentFormatId":"1","contentTxt":"The router configuration defines all the potential router states an application can be in. Let’s look at an example.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000007","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000008","sortNo":8,"contentFormatId":"1","contentTxt":"which can be depicted as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000009","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000010","sortNo":10,"contentFormatId":"1","contentTxt":"An outlet is the location where a component will be placed. If a node has multiple children of the same color, i.e., of the same outlet type, only one of them can be active at a time. Consequently, the team and summary components cannot be displayed together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000011","sortNo":11,"contentFormatId":"1","contentTxt":"A router state is a subtree of the configuration tree. For instance, the example below has the summary component activated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000012","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000013","sortNo":13,"contentFormatId":"1","contentTxt":"The router’s primary job is to manage navigations between states, which includes updating the component tree. A navigation is essentially the act of transitioning from one activated subtree to another. Say we perform a navigation, and this is the result:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000014","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Because the summary is no longer active, the router will remove it. Instead, it will instantiate the details component and display it inside the team component, with the chat component visible on the side.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000016","sortNo":16,"contentFormatId":"1","contentTxt":"That’s it. The router simply allows us to express all the potential states in which our application can be, and provides a mechanism for navigating from one state to another.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000017","sortNo":17,"contentFormatId":"1","contentTxt":"So now we’ve learned what routers do in general. It’s time to talk about the Angular router.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000018","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000019","sortNo":19,"contentFormatId":"1","contentTxt":"The Angular router takes a URL, parses it into a URL tree, recognizes router states, instantiates all the needed components, and, finally, manages navigation. Let’s look at each one of these operations in detail.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000020","sortNo":20,"contentFormatId":"1","contentTxt":"<strong>URL PARSING AND SERIALIZATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000021","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000022","sortNo":22,"contentFormatId":"1","contentTxt":"The URL bar provides a huge advantage for web applications over native applications. It allows you to reference states, bookmark them, and share them with your friends. In a well-behaved web application, any application state transition results in a URL change, and any URL change results in a state transition. In other words, a URL is a serialized router state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000023","sortNo":23,"contentFormatId":"1","contentTxt":"The first thing the router does is parse the URL string into a URL tree. The router does not need to know anything about your application or its components to do that. In other words, the parse operation is application-independent. To get a feel of how this works, let’s look at a few examples.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000024","sortNo":24,"contentFormatId":"1","contentTxt":"Let’s start with a simple URL consisting of three segments.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000025","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000026","sortNo":26,"contentFormatId":"1","contentTxt":"As you can see, a URL tree consists of URL segments. And each URL segment contains its parameters and its outlet name.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000027","sortNo":27,"contentFormatId":"1","contentTxt":"Now look at this example, where the first segment has the extra parameter set to true.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000028","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000029","sortNo":29,"contentFormatId":"1","contentTxt":"Finally, let’s see the result when the team segment has two children instead of one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000030","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000031","sortNo":31,"contentFormatId":"1","contentTxt":"As you can see, the router uses parenthesis to serialize nodes with multiple children, the colon syntax to specify the outlet, and the ’;parameter=value’ syntax (e.g., open=true) to specify route specific parameters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000032","sortNo":32,"contentFormatId":"1","contentTxt":"There are a couple of reasons why the router provides the URL tree instead of just giving us the URL string. First, the URL tree is a richer data structure, with more affordances to facilitate common operations. Second, it enables us to provide our own custom URL serialization strategy.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000033","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000034","sortNo":34,"contentFormatId":"1","contentTxt":"<strong>ACCESSING THE CURRENT URL</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000035","sortNo":35,"contentFormatId":"1","contentTxt":"You can get the current URL from the router service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000036","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000037","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>STORING URLS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000038","sortNo":38,"contentFormatId":"1","contentTxt":"URL trees and URL segments are immutable, so it is safe to store them. This is particularly handy for implementing interesting navigation and undo patterns.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000039","sortNo":39,"contentFormatId":"1","contentTxt":"<strong>ROUTER STATE RECOGNITION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000040","sortNo":40,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000041","sortNo":41,"contentFormatId":"1","contentTxt":"Since the parsing of the URL does not require any knowledge about the application, the produced URL tree does not represent the logical structure of the application. A router state does. To create it, the router uses the provided configuration and matches it against a URL tree. Again, let’s look at a few examples.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000042","sortNo":42,"contentFormatId":"1","contentTxt":"Say this is the provided router configuration.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000043","sortNo":43,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000044","sortNo":44,"contentFormatId":"1","contentTxt":"And we are navigating to the following URL.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000045","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000046","sortNo":46,"contentFormatId":"1","contentTxt":"First, the router will parse the URL string into a URL tree. Then, it will go through the items in the configuration, one by one, trying to match them against the parsed URL tree. In this particular case, the first entry is a match. Then, it will take the children items and will carry on matching.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000047","sortNo":47,"contentFormatId":"1","contentTxt":"If it is impossible to match the whole URL, the navigation will fail. But if it works, a router state representing the future state of the application will be constructed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000048","sortNo":48,"contentFormatId":"1","contentTxt":"For this particular example it will look as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000049","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000050","sortNo":50,"contentFormatId":"1","contentTxt":"A router state consists of activated routes. And each activated route is associated with a single component. Also, note that we always have an activated route associated with the root component of the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000051","sortNo":51,"contentFormatId":"1","contentTxt":"Let’s look at one more example.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000052","sortNo":52,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000053","sortNo":53,"contentFormatId":"1","contentTxt":"Here we have two siblings with different outlet names, TeamCmp and ChatCmp, which are activated at the same time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000054","sortNo":54,"contentFormatId":"1","contentTxt":"<strong>POWERFUL MATCHING SYNTAX</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000055","sortNo":55,"contentFormatId":"1","contentTxt":"The syntax for matching is very powerful. It supports wildcards (e.g., '**'), and positional parameters (e.g., /team/:id).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000056","sortNo":56,"contentFormatId":"1","contentTxt":"<strong>COMPONENT INSTANTIATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000057","sortNo":57,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000058","sortNo":58,"contentFormatId":"1","contentTxt":"At this point, we have a router state. The router can now match this state by instantiating each component, assembling a component tree, and placing each component into the appropriate router outlet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000059","sortNo":59,"contentFormatId":"1","contentTxt":"To understand how it works, let’s look at the following example.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000060","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000061","sortNo":61,"contentFormatId":"1","contentTxt":"Say we are navigating to this URL '/team/3(aux:/chat)/details, which corresponds to the following router state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000062","sortNo":62,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000063","sortNo":63,"contentFormatId":"1","contentTxt":"First, the router will instantiate TeamCmp and place it into the primary outlet of the root component. Then, it will place a new instance of ChatCmp into the ‘aux’ outlet. Finally, it will instantiate a new instance of DetailsCmp and place it in the primary outlet of the team component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000064","sortNo":64,"contentFormatId":"1","contentTxt":"<strong>USING PARAMS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000065","sortNo":65,"contentFormatId":"1","contentTxt":"Often components rely on the state captured in the URL. For instance, the team component probably need to access the id parameter. We can get the parameters by injecting the ActivatedRoute object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000066","sortNo":66,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000067","sortNo":67,"contentFormatId":"1","contentTxt":"If we navigate from /team/3/details to /team/4/details, the params observable will emit a new map of parameters. So the team component will display Team Id: 4.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000068","sortNo":68,"contentFormatId":"1","contentTxt":"Now, say the details component also needs to react to the team id changes. This is how we can do it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000069","sortNo":69,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000070","sortNo":70,"contentFormatId":"1","contentTxt":"We have the ability to move up and down the router state tree. We also can see that every activated route has its own parameters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000071","sortNo":71,"contentFormatId":"1","contentTxt":"It is easy to imagine how much flexibility we get once we start combining multiple observables from different activated routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000072","sortNo":72,"contentFormatId":"1","contentTxt":"<strong>QUERYPARAMS AND FRAGMENT</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000073","sortNo":73,"contentFormatId":"1","contentTxt":"The router state has the following things that are not associated with a particular activated route: query parameters and fragment.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000074","sortNo":74,"contentFormatId":"1","contentTxt":"Here’s an example URL with both query (id=3) and fragment (open=true) parameters: /team?id=3#open=true.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000075","sortNo":75,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000076","sortNo":76,"contentFormatId":"1","contentTxt":"<strong>USING SNAPSHOTS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000077","sortNo":77,"contentFormatId":"1","contentTxt":"As you can see the router exposes route and query parameters as observables, which is convenient most of the time. But not always. Sometimes what we want is a snapshot of the state that we can examine at once.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000078","sortNo":78,"contentFormatId":"1","contentTxt":"This is how you can get it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000079","sortNo":79,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000080","sortNo":80,"contentFormatId":"1","contentTxt":"<strong>NAVIGATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000081","sortNo":81,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000082","sortNo":82,"contentFormatId":"1","contentTxt":"So at this point the router has parsed the URL, recognized the router state, and instantiated the components. Next, we need to be able to navigate from this router state to another one. There are two ways to accomplish this: by calling router.navigate or by using the RouterLink directive.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000083","sortNo":83,"contentFormatId":"1","contentTxt":"<strong>IMPERATIVE NAVIGATION</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000084","sortNo":84,"contentFormatId":"1","contentTxt":"To navigate imperatively, inject the Router service and call navigate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000085","sortNo":85,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000086","sortNo":86,"contentFormatId":"1","contentTxt":"This code works, but it has a problem–the navigation is absolute. This makes this component harder to reuse and test. To fix it, we just need to pass an activated route to the navigate method, as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000087","sortNo":87,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000088","sortNo":88,"contentFormatId":"1","contentTxt":"<strong>ROUTERLINK</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000089","sortNo":89,"contentFormatId":"1","contentTxt":"Another way to navigate around is by using the RouterLink directive.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000090","sortNo":90,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000091","sortNo":91,"contentFormatId":"1","contentTxt":"This directive will also update the href attribute when applied to an <a> link element, so it is SEO friendly and the right-click, open-in-new-browser-tab behavior we expect from regular links will work.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000092","sortNo":92,"contentFormatId":"1","contentTxt":"<strong>MORE ON SYNTAX</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000093","sortNo":93,"contentFormatId":"1","contentTxt":"Just to get a feel of what can be passed in to navigate and routerLink, let’s look at the following examples.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000094","sortNo":94,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000095","sortNo":95,"contentFormatId":"1","contentTxt":"<strong>NAVIGATION IS URL BASED, NOT ROUTE BASED</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000096","sortNo":96,"contentFormatId":"1","contentTxt":"Navigation is URL based, and not route based. Meaning that '../' skips one segment in the URL tree. To see why this is the case, let’s look at the following link:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000097","sortNo":97,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000098","sortNo":98,"contentFormatId":"1","contentTxt":"Let’s say the link navigates into the ChatCmp and DetailsCmp components, and we would like to load these components lazily, only when the user clicks on the link. At the same time, the href attribute of the link should be set on page load.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000099","sortNo":99,"contentFormatId":"1","contentTxt":"The route configuration of ChatCmp and DetailsCmp is not available on page load. This means that we cannot know if '../chat', this.chatId, 'details' are one, two, or three route segments. The only thing we know is that these are three separate URL segments.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000100","sortNo":100,"contentFormatId":"1","contentTxt":"This was one of the design constraints when building the router. It should allow deep linking into lazily loaded routes without knowing anything about them. And the links should have the href attribute set. That is why all the navigation in the router is URL based, not route based.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000101","sortNo":101,"contentFormatId":"1","contentTxt":"<strong>E2E EXAMPLE</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000102","sortNo":102,"contentFormatId":"1","contentTxt":"We’ve looked at all the four core operations of the Angular router. Now, let’s look at all of them in action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000103","sortNo":103,"contentFormatId":"1","contentTxt":"Say this is the router configuration of our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000104","sortNo":104,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000105","sortNo":105,"contentFormatId":"1","contentTxt":"When the browser is loading /team/3/details, the router will do the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000106","sortNo":106,"contentFormatId":"1","contentTxt":"First, it will parse this url string into a URL tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000107","sortNo":107,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000108","sortNo":108,"contentFormatId":"1","contentTxt":"Second, it will use this URL tree to construct a new router state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000109","sortNo":109,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000110","sortNo":110,"contentFormatId":"1","contentTxt":"Third, the router will instantiate the team and details components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000111","sortNo":111,"contentFormatId":"1","contentTxt":"Now, let’s say the team component has the following link in its template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000112","sortNo":112,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000113","sortNo":113,"contentFormatId":"1","contentTxt":"And say the user triggers a navigation by clicking on the link.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000114","sortNo":114,"contentFormatId":"1","contentTxt":"The router will take this array ['../', 4, 'details'] and will construct a new URL tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000115","sortNo":115,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000116","sortNo":116,"contentFormatId":"1","contentTxt":"Next it will recognize a new router state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000117","sortNo":117,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000118","sortNo":118,"contentFormatId":"1","contentTxt":"Finally, it will find that the team and details components are already in place. So it will reuse them and just push a new set of parameters into the params observable of the team component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000119","sortNo":119,"contentFormatId":"1","contentTxt":"Once this is done, the router will take the new URL tree, serialize it into a string, and update the location property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000120","sortNo":120,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000121","sortNo":121,"contentFormatId":"1","contentTxt":"<strong>SUMMARY</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000122","sortNo":122,"contentFormatId":"1","contentTxt":"We learned quite a few things today. First, we learned what routers are for. They allow us to express all the potential states in which our application can be, and give us a mechanism for navigating from one state to another. We also learned about the four core operations of the Angular router: URL parsing, state recognition, component instantiation, and navigation. Finally, we looked at an e2e example showing the router in action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606140000000123","sortNo":123,"contentFormatId":"1","contentTxt":"We haven’t touched on the following important topics: navigation guards, monitoring, debugging, error handling, and lazy loading. All of these topics will be covered in future blog posts.","contentBinary":"","contentPoster":"","contentUrl":null}]
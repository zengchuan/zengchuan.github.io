[{"id":"201604190000000030","sortNo":1,"contentFormatId":"1","contentTxt":"In RxJs we often deal with multiple streams, but the end consumer typically only subscribes to a single stream. In this article we will look at ways to combine multiple streams into a single stream.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000031","sortNo":2,"contentFormatId":"1","contentTxt":"There are many ways for RxJs streams to converge on a single stream, but in this article we will look at flatMap, forkJoin, merge and concat.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000032","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Concat</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000033","sortNo":4,"contentFormatId":"1","contentTxt":"Concat will combine two observables into a combined sequence, but the second observable will not start emitting until the first one has completed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000034","sortNo":5,"contentFormatId":"1","contentTxt":"In my sample I am concatenating two timer observables using concat.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000035","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000036","sortNo":7,"contentFormatId":"1","contentTxt":"The emitted values are very simple, but we will receive all the values from the first observable before we start receiving values from the second. Below is a diagram showing the order of emitted events. Values from the first observable are in shown in green and values from the second observable are in blue.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000037","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000038","sortNo":9,"contentFormatId":"1","contentTxt":"<strong>Merge</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000039","sortNo":10,"contentFormatId":"1","contentTxt":"Merge is similar to concat, but it will interleave the emitted values instead of completing the first observable before starting the second one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000040","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000041","sortNo":12,"contentFormatId":"1","contentTxt":"In the diagram you can see the values from both observables interleaved with alternate green and blue boxes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000042","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000043","sortNo":14,"contentFormatId":"1","contentTxt":"<strong>forkJoin</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000044","sortNo":15,"contentFormatId":"1","contentTxt":"We use forkJoin to execute observables in parallel. One common use case of this is making multiple http requests in parallel. In my sample I am forkJoining two very simple observables, but the key point is that the subscriber won't receive any values until both observables have completed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000045","sortNo":16,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000046","sortNo":17,"contentFormatId":"1","contentTxt":"In the diagram we see that both observables completed before we received the result.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000047","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000048","sortNo":19,"contentFormatId":"1","contentTxt":"<strong>flatMap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000049","sortNo":20,"contentFormatId":"1","contentTxt":"flatMap is how we handle dependencies between observables. My sample is contrived, but I am returning a value from the first observable that is needed by the second observable to calculate a sum.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000050","sortNo":21,"contentFormatId":"1","contentTxt":"Like I said this example is contrived, but if we compare this to promises, flatMap is how we would create the equivalent of promise chains. The code can be seen below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000051","sortNo":22,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000052","sortNo":23,"contentFormatId":"1","contentTxt":"<strong>source code:</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604190000000053","sortNo":24,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/thelgevold/angular-2-samples\">https://github.com/thelgevold/angular-2-samples</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
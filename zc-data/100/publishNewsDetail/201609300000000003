[{"id":"201609300000000152","sortNo":1,"contentFormatId":"1","contentTxt":"Testing is important to building solid, production-ready applications. Today we’ll be discussing Angular 2 Testing, but regardless of the language, framework, or application we are building, having a solid test setup is crucial to know if our applications are functioning properly. We might accidentally introduce a bug when adding functionality that we won’t ever know about until we get an angry customer email.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000153","sortNo":2,"contentFormatId":"1","contentTxt":"Often times we’ll skip testing because it takes a lot more work to write our tests than actually writing the code and who wants to write tests anyway when we know they are going to break in the first place? However testing is incredibly vital to the health of a solid application, so we introduce this short guide on how testing doesn’t need to be a painstakingly-long process. By the end of this article, you’ll see just how quick and easy it is to get started with Angular 2 testing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000154","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Getting Started with  Angular 2 Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000155","sortNo":4,"contentFormatId":"1","contentTxt":"Although testing in Angular 1 was integrated into the framework, it often came with a lot of headache and overhead. We had to set up our Angular environment for every single test. All this overhead caused a lot of extra work, especially when we were only focused on a small piece of functionality that didn’t require the entire application stack.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000156","sortNo":5,"contentFormatId":"1","contentTxt":"However, Angular 2 testing is deeply integrated in the framework with the angular2/testing  package. You can bang out tests using the TestComponentBuilder  or TestBed , but more on that shortly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000157","sortNo":6,"contentFormatId":"1","contentTxt":"With TypeScript and Angular 2, our Components  are directly exported classes and usually have some dependencies – services, pipes, and other components. With Angular 1, we often would have to manually stub these instances out and provide our own mocks for them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000158","sortNo":7,"contentFormatId":"1","contentTxt":"The magic of Angular 2, however removes the need for us to bootstrap our application when we’re writing our tests. We’ll initialize the components and inject our dependencies manually. We can _write tests just like we are calling any plain old method and checking the return value of the component’s properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000159","sortNo":8,"contentFormatId":"1","contentTxt":"<strong>A  rapid review of Dependency Injection</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000160","sortNo":9,"contentFormatId":"1","contentTxt":"The design pattern of Dependency Injection (or DI, for short) is simple and not tied to Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000161","sortNo":10,"contentFormatId":"1","contentTxt":"In a nutshell, the problem is all applications require dependency management, from low-level c applications up through our front-end applications, we’re dependent upon other libraries to build our apps.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000162","sortNo":11,"contentFormatId":"1","contentTxt":"There are different ways to handle managing dependencies in our application and dependency injection (DI) presents one possible solution.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000163","sortNo":12,"contentFormatId":"1","contentTxt":"Imagine we have a Laptop  class:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000164","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000165","sortNo":14,"contentFormatId":"1","contentTxt":"A laptop instance is responsible for creating its own keyboard, mouse, and access to the WIFI instance (using a Singleton to get access to the Wifi object).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000166","sortNo":15,"contentFormatId":"1","contentTxt":"Everything is tucked neatly away in the Laptop class, right? Well… what if we want to write a test independent of the keyboard? What if the keyboard on our laptop is broken and we want to know if the laptop still functions? How can we test against the Keyboard when it’s integrated so deeply in the Laptop class?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000167","sortNo":16,"contentFormatId":"1","contentTxt":"Umm… we can’t… well, we can, but it’s a LOT of extra work (for good reason). Plus, setting up our tests like this can make for brittle tests and can often lead to more problems than solutions. This type of code is bad for testing and maintainability.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000168","sortNo":17,"contentFormatId":"1","contentTxt":"Wouldn’t it be so much easier if the Laptop class didn’t know anything about instantiating its dependencies, but instead were _handed_ the right ones?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000169","sortNo":18,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000170","sortNo":19,"contentFormatId":"1","contentTxt":"The Laptop class doesn’t know anything about how to access its own dependencies – they are _injected_ through the constructor() function. Say hello to dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000171","sortNo":20,"contentFormatId":"1","contentTxt":"Setting up mocks and testing this class is as simple as:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000172","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000173","sortNo":22,"contentFormatId":"1","contentTxt":"<strong>Angular 2 Testing Tools</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000174","sortNo":23,"contentFormatId":"1","contentTxt":"<strong>Jasmine</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000175","sortNo":24,"contentFormatId":"1","contentTxt":"Jasmine allows us to write tests the way we want expect our apps to _behave._ It is a behaviour-driven development (BDD, for short )framework built for testing JavaScript code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000176","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Karma</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000177","sortNo":26,"contentFormatId":"1","contentTxt":"Karma runs in the background while you develop your application (and write tests). We don’t need to worry about setting it up if we start off your application with the [Angular QuickStart] bootstrap (the karma files in there already set up karma file).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000178","sortNo":27,"contentFormatId":"1","contentTxt":"<strong>Protractor</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000179","sortNo":28,"contentFormatId":"1","contentTxt":"Protractor is used to write end-to-end tests (e2e). End-to-end tests are useful to mock a real user using our application as they are designed for us to pretend we are actually running the through the application in a browser, just like a real user. We’ll set up expectations and test against our assumptions about what the user sees.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000180","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>Angular 2 Testing Platform</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000181","sortNo":30,"contentFormatId":"1","contentTxt":"When we are ready to test how the classes interact with Angular and the DOM, we’ll use the Angular Testing Platform.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000182","sortNo":31,"contentFormatId":"1","contentTxt":"Although this isn’t the only type of test we’ll be writing, as we’ll want to write isolated unit tests as well, it’s the easiest and quickest way to test a live Component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000183","sortNo":32,"contentFormatId":"1","contentTxt":"The Angular Testing Platform allows us to examine an instance of a class without any dependence on Angular or injected values.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000184","sortNo":33,"contentFormatId":"1","contentTxt":"Armed with the knowledge of the available tools for Angular 2 testing, let’s put them to use!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000185","sortNo":34,"contentFormatId":"1","contentTxt":"<strong>Where’s My Car – The Angular Test</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000186","sortNo":35,"contentFormatId":"1","contentTxt":"Let’s start off creating a small test for a simple Angular component, the CarComponent. Here’s what the component looks like.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000187","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000188","sortNo":37,"contentFormatId":"1","contentTxt":"Let’s see how to initialize the component for testing. We want to use a mocked version of CarService because we are isolating the CarComponent to make the code more modular and independent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000189","sortNo":38,"contentFormatId":"1","contentTxt":"Let’s implement our spec file. First, let’s import everything we need to get started with the testing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000190","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000191","sortNo":40,"contentFormatId":"1","contentTxt":"Now let’s focus on the tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000192","sortNo":41,"contentFormatId":"1","contentTxt":"We’ll need an instance of the CarComponent as well as a fixture instance (we’ll get to this shortly). Let’s set these up in the spec file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000193","sortNo":42,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000194","sortNo":43,"contentFormatId":"1","contentTxt":"Next, we’ll use the Jasmine describe() function to define the CarComponent test suite:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000195","sortNo":44,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000196","sortNo":45,"contentFormatId":"1","contentTxt":"The TestBed helper helps us create a test @NgModule. As this is the case, we can pretend the @NgModule for the test is created cleanly for every single test. We’ll pass an @NgModule-like configuration object into the configureTestingModule() function in a beforeEach() block:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000197","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000198","sortNo":47,"contentFormatId":"1","contentTxt":"Using this testbed, we can create the instance of our component by using the TestBed method createComponent():","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000199","sortNo":48,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000200","sortNo":49,"contentFormatId":"1","contentTxt":"Let’s quickly break down what’s happening above. The TestBed handles all the magic. It is preconfigured with the default providers and declarable that we need to start testing – we don’t need to import everything separately.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000201","sortNo":50,"contentFormatId":"1","contentTxt":"We configure the TestBed by passing it the component we want to test along with the dependencies of that component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000202","sortNo":51,"contentFormatId":"1","contentTxt":"Now that we have configured our TestBed, we need access to the fixture. The fixture provides all we need to perform testing on the component we’re focused on in this test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000203","sortNo":52,"contentFormatId":"1","contentTxt":"Let’s write our first test against the CarComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000204","sortNo":53,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000205","sortNo":54,"contentFormatId":"1","contentTxt":"Here, we tested our getLocation() method in three steps:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000206","sortNo":55,"contentFormatId":"1","contentTxt":"1. In our test, we call the getLocation() method on the instance of the CarComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000207","sortNo":56,"contentFormatId":"1","contentTxt":"2. In order for Angular to _see_ any changes on the inputs, we’ll manually trigger it to look for any updates and resettle any data changes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000208","sortNo":57,"contentFormatId":"1","contentTxt":"3. Finally, we get access to the DOM element our Component places on the page using debugElement.nativeElement. We then run our assertion using expect from Jasmine.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000209","sortNo":58,"contentFormatId":"1","contentTxt":"Finally, we’ll want to set up a mock CarService which allows us to control the response values and the environment we’ll run our tests within. Let’s create the MockCarService which will implement our getLocation() method the CarComponent uses:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000210","sortNo":59,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000211","sortNo":60,"contentFormatId":"1","contentTxt":"That’s it! We’re done and already testing our Angular components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000212","sortNo":61,"contentFormatId":"1","contentTxt":"<strong>The Big Picture</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000213","sortNo":62,"contentFormatId":"1","contentTxt":"When we’re writing Angular 2.x code on our next big application, using the Dependency Injection design pattern will save us tons of time and headaches.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000214","sortNo":63,"contentFormatId":"1","contentTxt":"Rule of thumb: every Angular component we’ll write should never instantiate any dependencies; instead we should pass our dependencies to it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000215","sortNo":64,"contentFormatId":"1","contentTxt":"Much more information about writing tests and making our applications modular is at Angular’s official website https://angular.io/docs/ts/latest/guide/testing.html.","contentBinary":"","contentPoster":"","contentUrl":null}]
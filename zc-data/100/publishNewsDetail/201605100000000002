[{"id":"201605100000000051","sortNo":1,"contentFormatId":"1","contentTxt":"In the first part of this article, we described the basics of the form support of Angular2. In this second part, we will deal with more advanced concepts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000052","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Improving forms</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000053","sortNo":3,"contentFormatId":"1","contentTxt":"As you can see, the form we created in the last section can be improved to be more concise and efficient to write. Here we will describe some techniques that leverage the power of Angular 2 components and directives to achieve this goal.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000054","sortNo":4,"contentFormatId":"1","contentTxt":"<strong>Bootstrap-ifying the form</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000055","sortNo":5,"contentFormatId":"1","contentTxt":"Some classes need to be applied to forms and elements to display them using the Bootstrap 3 library. They need to be set on every element to be able to leverage its form support. Attribute directives of Angular 2 could provide us a great support to apply these under the hood to all these elements. As a matter of fact, they aim to change the appearance or behavior of an element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000056","sortNo":6,"contentFormatId":"1","contentTxt":"In our case, we need to add the form-control class to the <input> / <select> / <textarea> HTML tags and form-horizontal to the form one. For this purpose, just create two directives with selectors that match these tags and leverage the ElementRef and Renderer classes to add the classes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000057","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000058","sortNo":8,"contentFormatId":"1","contentTxt":"Notice that there is no impact in the component templates that use forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000059","sortNo":9,"contentFormatId":"1","contentTxt":"<strong>Form component for fields</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000060","sortNo":10,"contentFormatId":"1","contentTxt":"As you can see there is a lot of code duplication within the form because of the use of Bootstrap. As a matter of fact, it requires a specific structure and dedicated CSS classes. In order to simplify this code, a good idea would be to modularize all this stuff into a component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000061","sortNo":11,"contentFormatId":"1","contentTxt":"That said, some parts like the definition of inputs remain specific. Of course, we want to handle field validation within the component. Let’s first define the structure of this component. We need to provide the value of the label and the field state. We simply move the HTML block for a field into the component template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000062","sortNo":12,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000063","sortNo":13,"contentFormatId":"1","contentTxt":"As you can see, the expressions regarding field validation remain the same but do not rely on the state attribute provided to the component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000064","sortNo":14,"contentFormatId":"1","contentTxt":"We use the template attribute here to see both template and component in a single snippet. You should externalize the HTML code into a file referenced using the templateUrl attribute.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000065","sortNo":15,"contentFormatId":"1","contentTxt":"The last thing to implement is to include the specific part, the form element itself. Angular 2 provides the ng-content component for this purpose. It allows you to put into the component template the HTML content provided when using the component. The template will now look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000066","sortNo":16,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000067","sortNo":17,"contentFormatId":"1","contentTxt":"We are now ready to refactor our form using this component. That way, our input automatically takes part of a Bootstrap-based form and errors are automatically displayed according to specified validations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000068","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000069","sortNo":19,"contentFormatId":"1","contentTxt":"You can see that there is some duplication here at the level of the state attribute. We need to specify it on both field component and form elements. A good approach would be to let the field component deduce the controller of the element it wraps. Angular 2 provides an elegant way to do this thanks to the ContentChild decorator. You can reference components and directives within the ng-content block.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000070","sortNo":20,"contentFormatId":"1","contentTxt":"In our case, we need to find out a directive of kind NgFormControl. To achieve this, simply add a property in the component decorated with @ContentChild, as described below. There is no need now to keep the state input.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000071","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000072","sortNo":22,"contentFormatId":"1","contentTxt":"We can now refactor our form to remove the state parameter when using the field element:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000073","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000074","sortNo":24,"contentFormatId":"1","contentTxt":"For our use case, we also need to implement an additional component to manage labels of the company.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000075","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Specific form component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000076","sortNo":26,"contentFormatId":"1","contentTxt":"In our company form, we want to be able to specify labels to identify the company sectors, like “IT”, “computer”, “maintenance”, “software”. Implementing a complex field will fit our needs and modularize its processing in a single entity.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000077","sortNo":27,"contentFormatId":"1","contentTxt":"We want to leverage the two way binding support of Angular 2 at this level to let the labels field of the company to be automatically updated when a label is added or removed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000078","sortNo":28,"contentFormatId":"1","contentTxt":"Let’s create the structure of our component to make it accept a values attribute and fire a valuesChange event. With such names, the values field can leverage the [(values)] expression to use two way binding.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000079","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000080","sortNo":30,"contentFormatId":"1","contentTxt":"We can notice the use of the @Input annotation for parameters and @Ouput for custom events of the component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000081","sortNo":31,"contentFormatId":"1","contentTxt":"The component builds a list of Bootstrap labels using the values attribute. For each element, we attach an event to delete the label from the list. Besides this list, a dedicated input is added for the label creation. Here is a simple version of the component template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000082","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000083","sortNo":33,"contentFormatId":"1","contentTxt":"All these events are attached to internal removeValue and addValue methods of the component. Each time the labels are updated the valuesChange event must be fired to update external bindings.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000084","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000085","sortNo":35,"contentFormatId":"1","contentTxt":"This component can be simply referenced within the form component and used in its associated template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000086","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000087","sortNo":37,"contentFormatId":"1","contentTxt":"This approach provides an interesting way to implement a custom form component but its main drawback is that this component doesn’t take part of the form controller. Angular 2 makes it possible to improve this component by leveraging the ngModel feature.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000088","sortNo":38,"contentFormatId":"1","contentTxt":"<strong>NgModel-compatible component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000089","sortNo":39,"contentFormatId":"1","contentTxt":"The labels component we implemented is fine since it allows you to bring some advanced form elements. Its main drawback is that it is not taken into account in the form validation. What happens if I want to ensure that the list of tags isn’t empty?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000090","sortNo":40,"contentFormatId":"1","contentTxt":"We previously discussed that Angular 2 provides two way binding and validation for native form elements like inputs, selects and textarea. Angular 2 is extendable and allows you to bring this feature into custom components. That way such components can take part in the validation of the form. This means that if the validation fails for the component, the whole form will be invalid.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000091","sortNo":41,"contentFormatId":"1","contentTxt":"Let’s start to adapt the custom component implemented in the previous section. At this level, the only thing to do is to the input property labels since corresponding value will now be provided by ngModel itself. A new method must be added to allow you to set this value directly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000092","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000093","sortNo":43,"contentFormatId":"1","contentTxt":"NgModel","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000094","sortNo":44,"contentFormatId":"1","contentTxt":"The value accessor corresponds to a directive that will be attached to the custom component itself. This way we will be able to detect the labelsChange event and trigger the registered onChange callback. For information the writeValue method is called when the ngModel is updated programmatically. This makes it possible to call the host (i.e. the component attached on) to set this new value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000095","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000096","sortNo":46,"contentFormatId":"1","contentTxt":"The remaining task involves registering this class within the providers of the component to make the class take part in the ngModel processing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000097","sortNo":47,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000098","sortNo":48,"contentFormatId":"1","contentTxt":"We can now use both ngModel and ngFormControl directives on our custom component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000099","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000100","sortNo":50,"contentFormatId":"1","contentTxt":"Asynchronous validation for fields","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000101","sortNo":51,"contentFormatId":"1","contentTxt":"We previously saw a simple custom validator to validate zip codes. Validations can be a bit more advanced and require an exchange with the server. Imagine we want to ensure that the name of the company is unique. For this, we will trigger a HTTP request that looks for a company with the same name. If an empty result is received, we know that the name is unique.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000102","sortNo":52,"contentFormatId":"1","contentTxt":"In this case, we need to exclude the current company from the check, otherwise it would appear in the results.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000103","sortNo":53,"contentFormatId":"1","contentTxt":"We will leverage the CompaniesService. So the first thing is to implement the request.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000104","sortNo":54,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000105","sortNo":55,"contentFormatId":"1","contentTxt":"Now we need to be able to reference the service from the validation function. There is no dependency injection at this level but we can leverage closures. As a matter of fact, we have access to the service instance from the component where we register validators. So we will implement a function that will accept the service as parameter and create the actual validation function. This function will have access to the service when called during the validation process.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000106","sortNo":56,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000107","sortNo":57,"contentFormatId":"1","contentTxt":"We can now implement the asynchronous validation function. Such a function leverages promises to notify Angular 2 of the success or failure of the validation. For that reason, the validation function must return this promise. In all cases, the promise must be resolved: with null in the first case and with an object containing the key of the validator in the other case. The following code describes the whole code of this validator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000108","sortNo":58,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000109","sortNo":59,"contentFormatId":"1","contentTxt":"We could stop here but we want to offer a great user experience. So we need to improve our form a little bit to display a hint about the asynchronous validation. For this we can improve our field component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000110","sortNo":60,"contentFormatId":"1","contentTxt":"Let’s start by adding a new feedback property to specify the component required to use Bootstrap feedback for the input. We also add three methods to detect the status of the feedback:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000111","sortNo":61,"contentFormatId":"1","contentTxt":"1. isFeedbackValid: the asynchronous validation is successful","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000112","sortNo":62,"contentFormatId":"1","contentTxt":"2. isFeedbackNotValid: the asynchronous validation failed","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000113","sortNo":63,"contentFormatId":"1","contentTxt":"3. isFeedbackPending: the asynchronous validation is in progress","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000114","sortNo":64,"contentFormatId":"1","contentTxt":"These methods leverage the control associated with the component by checking the valid and pending properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000115","sortNo":65,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000116","sortNo":66,"contentFormatId":"1","contentTxt":"The component template can now be updated to take these states into account to display the correct icons within the associated input element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000117","sortNo":67,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000118","sortNo":68,"contentFormatId":"1","contentTxt":"We also defined some CSS styles for the component to have an spinning icon when the validation is in progress. Here is the result:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000119","sortNo":69,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000120","sortNo":70,"contentFormatId":"1","contentTxt":"That’s all for this second part. In the next and last part, we will focus on the form submission.","contentBinary":"","contentPoster":"","contentUrl":null}]
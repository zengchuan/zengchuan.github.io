[{"id":"201601220000000166","sortNo":1,"contentFormatId":"1","contentTxt":"A couple of months ago I wrote \"Lazy Loading of Route Components in Angular 2\", where I explained how we can take advantage of the AsyncRoutes and the virtual proxy pattern in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000167","sortNo":2,"contentFormatId":"1","contentTxt":"This way we can incrementally load the entire application by only requesting the resources required for the individual views. As result we will decrease the initial load time, which will dramatically improve the user's experience.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000168","sortNo":3,"contentFormatId":"1","contentTxt":"Problem","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000169","sortNo":4,"contentFormatId":"1","contentTxt":"This strategy works great! The only things that we need to provide to the AsyncRoute definition are name, path and a loader. Inside of the loader function we can have whatever custom logic we want to. The only contract that we sign with the framework is that the loader needs to return a promise:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000170","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000171","sortNo":6,"contentFormatId":"1","contentTxt":"But what if we receive the routes definitions from a remote service and we don't have them during initialization time?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000172","sortNo":7,"contentFormatId":"1","contentTxt":"Well, in such case we need to solve the following three problems:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000173","sortNo":8,"contentFormatId":"1","contentTxt":"Referencing not registered routes inside of a template","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000174","sortNo":9,"contentFormatId":"1","contentTxt":"If we want to reference to a route which is not declared within @RouteConfig by using:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000271","sortNo":10,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000272","sortNo":11,"contentFormatId":"1","contentTxt":"We will get a runtime error. This means that we need to implement a behavior in which we can list the available at given point of time routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000273","sortNo":12,"contentFormatId":"1","contentTxt":"Updating the @RouteConfig's metadata","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000274","sortNo":13,"contentFormatId":"1","contentTxt":"This is required for consistency. Since the way we register routes in Angular 2 is by using @RouteConfig, we need to make sure that it's always up-to-date, with all the routes available.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000275","sortNo":14,"contentFormatId":"1","contentTxt":"Dynamically registering routes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000276","sortNo":15,"contentFormatId":"1","contentTxt":"We need to make the framework aware of the new route definition that we received from the remote service. For this purpose we need to play with the router's internals, in order to provide the instructions for loading the new route.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000277","sortNo":16,"contentFormatId":"1","contentTxt":"Solution","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000278","sortNo":17,"contentFormatId":"1","contentTxt":"Lets start by exploring the solution of the first problem:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000279","sortNo":18,"contentFormatId":"1","contentTxt":"Dynamically rendering the application's navigation","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000280","sortNo":19,"contentFormatId":"1","contentTxt":"We can define a component called AppNav which receives a list of objects of the type { name: \"Route name\", path: ['/Route', 'Path'] } and renders the navigation:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000281","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000282","sortNo":21,"contentFormatId":"1","contentTxt":"The component above has a single @Input called routes and uses the ROUTER_DIRECTIVES because of the routerLink directive. Once the routes property changes its template will be populated with the passed value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000283","sortNo":22,"contentFormatId":"1","contentTxt":"We can use this component in the following way:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000284","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000285","sortNo":24,"contentFormatId":"1","contentTxt":"So far so good! Now lets see how we can get the list of registered routes and pass them to the directive!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000286","sortNo":25,"contentFormatId":"1","contentTxt":"Messing around with the @RouteConfig's metadata","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000287","sortNo":26,"contentFormatId":"1","contentTxt":"Lets peek at the semantics of the @RouteConfig decorator. All it does is to add another item to the array of annotations stored as metadata associated with given component. This means that by using the Reflect API we can get all the registered routes!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000288","sortNo":27,"contentFormatId":"1","contentTxt":"In order to have better separation of concerns we can isolate the logic for configuring the dynamic routes into a separate class. Lets define a class called DynamicRouteConfigurator, which has the following API:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000289","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000290","sortNo":29,"contentFormatId":"1","contentTxt":"Now lets define a root component which uses the AppNav component and DynamicRouteConfigurator service we defined:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000291","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000292","sortNo":31,"contentFormatId":"1","contentTxt":"Now lets explore the definition of getRoutes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000293","sortNo":32,"contentFormatId":"1","contentTxt":"Getting the registered routes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000294","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000295","sortNo":34,"contentFormatId":"1","contentTxt":"Above we simply get all the annotations associated with the passed as argument component and extract the declared routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000296","sortNo":35,"contentFormatId":"1","contentTxt":"Updating the registered routes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000297","sortNo":36,"contentFormatId":"1","contentTxt":"The implementation of updateRouteConfig is quite simple as well:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000298","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000299","sortNo":38,"contentFormatId":"1","contentTxt":"We loop over all the annotations in order to find the index of the metadata added by the @RouteConfig decorator and when we find it, we update its value. Right after that we update the annotations using Reflect.defineMetadata(...).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000300","sortNo":39,"contentFormatId":"1","contentTxt":"Updating the navigation","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000301","sortNo":40,"contentFormatId":"1","contentTxt":"We already have the definition of the AppNav component! Now we can get the registered with @RouteConfig routes and render links to all of them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000302","sortNo":41,"contentFormatId":"1","contentTxt":"We can populate the list with the links to the routes using the AppNav component, by setting the appRoutes' value:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000303","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000304","sortNo":43,"contentFormatId":"1","contentTxt":"Dynamically registering new routes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000305","sortNo":44,"contentFormatId":"1","contentTxt":"Now lets try to asynchronously add another route! We can notice that the DynamicRouteConfigurator has a method called addRoute, so lets use it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000306","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000307","sortNo":46,"contentFormatId":"1","contentTxt":"All we do above is to set a timeout for 1 second, define the About route and add it to the AppCmp using the injected instance of the DynamicRouteConfigurator. As last step we update the value of the appRoutes which will be reflected by the AppNav component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000308","sortNo":47,"contentFormatId":"1","contentTxt":"Using the RouteRegistry","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000309","sortNo":48,"contentFormatId":"1","contentTxt":"Now in order to get complete clarity of the entire implementation lets take a look at the addRoute method defined within the DynamicRouteConfigurator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000310","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000311","sortNo":50,"contentFormatId":"1","contentTxt":"As first step we get all the registered routes associated with the target component by using getRoutes, later we append one additional route and we invoke the updateRouteConfig method. As last step we register the new route in order to make the framework aware of it. We register it by using the instance of the RouteRegister passed as dependency via the DI mechanism of the framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000312","sortNo":51,"contentFormatId":"1","contentTxt":"Conclusion","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601220000000313","sortNo":52,"contentFormatId":"1","contentTxt":"Another point for future improvement of the DynamicRouteConfigurator is to allow further modification of the route configuration, such as deletion of existing routes. Although the RouteRegistry allows this functionality we'll need to touch private APIs (the _routes property of the RouteRegistry instances).","contentBinary":"","contentPoster":"","contentUrl":null}]
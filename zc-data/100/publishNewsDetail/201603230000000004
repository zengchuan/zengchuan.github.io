[{"id":"201603230000000047","sortNo":1,"contentFormatId":"1","contentTxt":"In Angular 2, you can use the Rx.Subject class to create the source of an observable sequence. But, you never want to return an Rx.Subject instance to the calling context. Doing so would be somewhat akin to returning a Deferred object rather than a promise; and, it would leave the Subject open to unanticipated and corrupting usage. As such, when exposing a Subject, you'll probably want to convert it to an Observable first.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000048","sortNo":2,"contentFormatId":"1","contentTxt":"Up until now, as a newcomer to RxJS, I've been trying to do this - converting a Subject to an Observable - using the Rx.Observable.from() creation method. Unfortunately, while it appeared as if it was working (in the way that I intended), it actually was not. To demonstrate, we're going to use Rx.Observable.from() to try and convert a Subject to an Observable and then test whether or not we can call the .next() method on the result (if all goes well, we shouldn't be able to):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000049","sortNo":3,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000050","sortNo":4,"contentFormatId":"1","contentTxt":"As you can see, the getObservable() method is passing the internal Subject reference through the Rx.Observable.from() method. However, when we run this code, we get the following output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000051","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000052","sortNo":6,"contentFormatId":"1","contentTxt":"As you can see, we were able to invoke the .next() method on the returned value which means that we accidentally returned the Subject back to the calling context. In essence, the Rx.Observable.from() method didn't do anything. And, in fact, if you look at the RxJS source code, you will see that this method will simply pass-through the given object if it is already an instance of the Observable class (which, of course, Subject is by way of inheritance).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000053","sortNo":7,"contentFormatId":"1","contentTxt":"The reason that I thought this was working was because the resultant value acts like an Observable. But, that's only because Subject is already an Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000054","sortNo":8,"contentFormatId":"1","contentTxt":"So, basically, I've been wrong up until now (and will try to go back and correct some code).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000055","sortNo":9,"contentFormatId":"1","contentTxt":"To get this working in the way that we actually intended it to, we can use the Rx.Observable.prototype.asObservable() instance method. I actually saw this method a while back, but the description didn't make sense to me at the time:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000056","sortNo":10,"contentFormatId":"1","contentTxt":"Hides the identity of an observable sequence.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000057","sortNo":11,"contentFormatId":"1","contentTxt":"Why would I ever want to \"hide\" the identity of an observable? Seems like such an odd gesture. Until you remember that other classes can extend Observable. Then, it starts to make a little bit more sense. Though, I might rephrase it to be something like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000058","sortNo":12,"contentFormatId":"1","contentTxt":"(Ben's version) Casts any object that implements the observable interface into a new Observable instance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000059","sortNo":13,"contentFormatId":"1","contentTxt":"When you think about it that way, it's exactly what we want - to cast Subject (which implements Observable by way of inheritance) to Observable. So, let's give it a try:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000060","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000061","sortNo":15,"contentFormatId":"1","contentTxt":"Now, when we run the above code, we get the following output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000062","sortNo":16,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000063","sortNo":17,"contentFormatId":"1","contentTxt":"As you can see, when we tried to call .next() on the returned value, an error was thrown. This is because we successfully converted the Subject instance to an Observable instance, shielding the calling context from the Subject implementation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603230000000064","sortNo":18,"contentFormatId":"1","contentTxt":"While you can technically pass around instances of Subject, doing so allows implementation details to bleed into other parts of the application. To prevent this, it is best to convert Subjects to Observables so that the sequence is exposed in a read-only fashion. Luckily, this is quite easy to accomplish with the .asObservable() instance method inherited by the Subject class in RxJS.","contentBinary":"","contentPoster":"","contentUrl":null}]
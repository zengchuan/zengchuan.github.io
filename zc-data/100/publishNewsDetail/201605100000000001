[{"id":"201605100000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In this article, we will describe how to implement a form to update data of a Web API hosted on the APISpark platform. Today we will focus on how to update a particular element, a company, based on the REST resource that provides a PUT method to manipulate them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000002","sortNo":2,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000003","sortNo":3,"contentFormatId":"1","contentTxt":"We intentionally keep data simple in order to avoid having an overly complicated form to implement. Here is the structure of the company element:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000004","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000005","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Creating forms</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Forms are the primary way to update data within an HTML page. In this first section, we will see how to implement the structure of a form, add some styles to it using Bootstrap and add some behaviors with the Angular 2 support to make it interactive.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000007","sortNo":7,"contentFormatId":"1","contentTxt":"<strong>Form definition</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000008","sortNo":8,"contentFormatId":"1","contentTxt":"As a reminder, we will start by describing the way to create a clean form using Twitter Bootstrap 3. Notice Material also provides a modern design for HTML applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000009","sortNo":9,"contentFormatId":"1","contentTxt":"You may already know the different HTML elements to create a form like <form>, <input>, <select> and <textarea>. Bootstrap 3 provides a set of CSS classes to make raw HTML forms more beautiful and handle the positioning of form elements.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Here is a sample of such a form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000011","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Of course, such code creates a beautiful but static form. Here is what it looks like.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000013","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000014","sortNo":14,"contentFormatId":"1","contentTxt":"We will see now how Angular 2 allows you to make your forms more interactive by applying some validation and displaying field errors if any.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000015","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>Form state</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000016","sortNo":16,"contentFormatId":"1","contentTxt":"As in version 1, Angular manages a state for the form and its fields. This state allows you to check if fields, field groups or the whole form is valid or not, according to the specified validations. Angular 2 provides a very flexible way to define states and inner states for forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000017","sortNo":17,"contentFormatId":"1","contentTxt":"The first approach is completely defined within the component template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000018","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Template-driven forms</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000019","sortNo":19,"contentFormatId":"1","contentTxt":"In this case, there is nothing to define the component code. Everything can be configured within its template leveraging the NgControlName directive. This allows you to define a control against a name for a specific field. This control can be then associated with a local variable. In this case, the value of this variable must be \"ngForm\". This local variable then allows you to check the validity of the field.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000020","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000021","sortNo":21,"contentFormatId":"1","contentTxt":"If you want to attach this control into the whole form or a field group, simply create a local variable at the corresponding level. In this case, the state container will be updated according to the states of controls it contains.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000022","sortNo":22,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000023","sortNo":23,"contentFormatId":"1","contentTxt":"Defining inline controls can be limited especially if you want to define custom validations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000024","sortNo":24,"contentFormatId":"1","contentTxt":"<strong>Using existing controls</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Angular 2 also lets you create by hand controls you want to link with on form elements. Such an approach must be considered when handling field validation in isolation. As a matter of fact, it’s not linked to the whole form. So the state of the form can be valid even if the field one isn’t.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000026","sortNo":26,"contentFormatId":"1","contentTxt":"That’s the reason why Angular provides a FormBuilder class for defining the validations globally for each field of the form. As we use a group in which we define fields, when a field is invalid, the whole group is.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000027","sortNo":27,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000028","sortNo":28,"contentFormatId":"1","contentTxt":"The corresponding elements can then be referenced within the template using the FormModel and FormControl directives, as described below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000029","sortNo":29,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000030","sortNo":30,"contentFormatId":"1","contentTxt":"Now that you’ve correctly configured form and field states, you can configure validation rules based on the field controllers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000031","sortNo":31,"contentFormatId":"1","contentTxt":"<strong>Form validation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000032","sortNo":32,"contentFormatId":"1","contentTxt":"Some validators are provided out of the box by Angular 2:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000033","sortNo":33,"contentFormatId":"1","contentTxt":"1. required: the field can’t be empty","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000034","sortNo":34,"contentFormatId":"1","contentTxt":"2. minLength: the length of a field must have a minimum length","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000035","sortNo":35,"contentFormatId":"1","contentTxt":"3. maxLength: the length of a field can’t exceed a maximum length","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000036","sortNo":36,"contentFormatId":"1","contentTxt":"As you can see, the list of validators is very short but it’s really easy with Angular 2 to implement and register a custom validator since it only consists of a function. For our company form, we need to check that the user filled a valid zip code within the address, i.e. a number with five digits. We can leverage regular expressions to check this. If the value is correct, simply return null. In the contrary, return an object containing the key of the validator with a sub object, as described below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000037","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000038","sortNo":38,"contentFormatId":"1","contentTxt":"To register this validation function, you need to have created form controls by your own, as described in the second approach. If you only have this validator, just put it in the second element of the array used to configure form controls. If you have more than one validator, you need to use the compose method of the Validators class as described below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000039","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000040","sortNo":40,"contentFormatId":"1","contentTxt":"Now we have defined the validations for our fields. We can leverage the form state to display errors for fields that don’t match these rules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000041","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>Leveraging form state</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000042","sortNo":42,"contentFormatId":"1","contentTxt":"Form state enables us to provide a better user experience by notifying users about invalid fields. As stated previously, we leverage Twitter Bootstrap to make a beautiful form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000043","sortNo":43,"contentFormatId":"1","contentTxt":"If validation fails for a field, we simply need to add a has-error class to block for the field and display the error message in an area with help-block and text-danger classes, as described below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000044","sortNo":44,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Of course, this must be dynamic by leveraging the field state into expressions. For the has-error class, simply use the ngClass and ngIf directives to disable and hide the error message.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000046","sortNo":46,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000047","sortNo":47,"contentFormatId":"1","contentTxt":"The color of the input area with errors will now be changed to red, as shown below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000048","sortNo":48,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000049","sortNo":49,"contentFormatId":"1","contentTxt":"Form controls also allow you to react to updates by leveraging the power of the reactive programming model. We will tackle such concepts in other upcoming articles.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201605100000000050","sortNo":50,"contentFormatId":"1","contentTxt":"As you can see, we implemented the foundations of forms by using Bootstrap 3 and applying validations. It’s a good start but we can go further by leveraging the Angular 2 component to simplify the form, remove the code duplication and apply behaviors transparently. We will describe this in the second part of the article. Stay tuned.","contentBinary":"","contentPoster":"","contentUrl":null}]
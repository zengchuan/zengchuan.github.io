[{"id":"201610190000000043","sortNo":1,"contentFormatId":"1","contentTxt":"End to end testing is a somewhat polarized subject in software engineering. While, some argue against it with valid points, we still think they are an important tool to have under our belt. In this article, we will go over a few of the other testing ways, and dig deeper into the why, and how of end to end testing for Angular 2 applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000044","sortNo":2,"contentFormatId":"1","contentTxt":"Before we dig deep if you aren’t familiar with the different levels of testing, here’s a quick overview.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000045","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>1. Unit Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000046","sortNo":4,"contentFormatId":"1","contentTxt":"This is the smallest possible unit of testing where we focus on thoroughly testing a small part of your application. Unit tests cover one small unit and don’t bother about how multiple units work together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000047","sortNo":5,"contentFormatId":"1","contentTxt":"We use unit tests in the application because they are fast, reliable and point us in the exact direction of the bug.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000048","sortNo":6,"contentFormatId":"1","contentTxt":"<strong>2. Integration Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000049","sortNo":7,"contentFormatId":"1","contentTxt":"These tests cover multiple units. The goal here is to test 2 or more small components of the application and ensure that they integrate as expected.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000050","sortNo":8,"contentFormatId":"1","contentTxt":"Integration tests point out important bugs that would show up when multiple components run together in the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000051","sortNo":9,"contentFormatId":"1","contentTxt":"<strong>3. End to End Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000052","sortNo":10,"contentFormatId":"1","contentTxt":"The tests above usually test code directly. They don’t test how the code would perform with hundreds of different environment variables. They don’t know how a user would run the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000053","sortNo":11,"contentFormatId":"1","contentTxt":"That’s why we use end to end tests. These end to end tests simulate a production like environment. It’s as simple as testing your application from start to finish – just like a user.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000054","sortNo":12,"contentFormatId":"1","contentTxt":"We can run end to end tests on multiple browsers and find bugs that emerge in certain environments / browsers – such as… Internet Explorer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000055","sortNo":13,"contentFormatId":"1","contentTxt":"<strong>4. Manual Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000056","sortNo":14,"contentFormatId":"1","contentTxt":"Finally, we test the application manually to look for any unexpected behavior that didn’t show up in the tests above.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000057","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>End to end Testing in Your Organization</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000058","sortNo":16,"contentFormatId":"1","contentTxt":"<strong>a. What’s the Purpose of Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000059","sortNo":17,"contentFormatId":"1","contentTxt":"Sometimes we tend to forget why we write software. Is it for the fun of building great products – of course! But who really benefits from these products?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000060","sortNo":18,"contentFormatId":"1","contentTxt":"The Users!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000061","sortNo":19,"contentFormatId":"1","contentTxt":"Every step we take to improve the process of writing and shipping great software should keep the user in mind. But then why do we write tests? The user doesn’t even get to see them!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000062","sortNo":20,"contentFormatId":"1","contentTxt":"We write tests to catch bugs before a user finds them lurking around the application. Remember that as you read further…","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000063","sortNo":21,"contentFormatId":"1","contentTxt":"<strong>b. Why use end to end Testing?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000064","sortNo":22,"contentFormatId":"1","contentTxt":"As the application continues to grow, testing the website manually each time you write a new component is not feasible.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000065","sortNo":23,"contentFormatId":"1","contentTxt":"That’s why we need to automate the testing process as much as possible using end to end testing. We can then see how different parts of the application – such as client-side code, the database queries, API controllers, etc. run together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000066","sortNo":24,"contentFormatId":"1","contentTxt":"<strong>c. But Wait! End to end Testing Can Be Harmful Too!</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000067","sortNo":25,"contentFormatId":"1","contentTxt":"Even though end to end testing sounds so magical and surreal, there are downsides to this testing strategy, especially when it comes to practices like continuous delivery.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000068","sortNo":26,"contentFormatId":"1","contentTxt":"Let’s get back to thinking about the user. What do you do when an end to end test fails?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000069","sortNo":27,"contentFormatId":"1","contentTxt":"In this scenario, the only thing we know is that there is a bug. We don’t know which part of application caused the bug. We can’t isolate the function or module that created this problem.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000070","sortNo":28,"contentFormatId":"1","contentTxt":"Your user only cares about the bug being fixed. He does not care about whether you found the bug or not.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000071","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>d. How Much of Your Application Should You Cover with End to End Tests?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000072","sortNo":30,"contentFormatId":"1","contentTxt":"We know by now that end to end tests only reveal the bug. We still need to find the bug and fix it. And that is the limitation of end to end tests. Isolating bugs is much easier with unit tests. We can cover all the small parts of the application with these, and we can cover the integration with other parts of the application with integration tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000073","sortNo":31,"contentFormatId":"1","contentTxt":"This would make it very difficult for any end to end tests to fail.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000074","sortNo":32,"contentFormatId":"1","contentTxt":"So even though end to end tests are important, we need to spend a considerable amount of time focusing on unit and integration tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000075","sortNo":33,"contentFormatId":"1","contentTxt":"Using a 70:20:10 ratio for the unit, integration and end to end tests in your application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000076","sortNo":34,"contentFormatId":"1","contentTxt":"<strong>Tools for end to end Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000077","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>1. Selenium</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000078","sortNo":36,"contentFormatId":"1","contentTxt":"Selenium allows us to automate browsers – Chrome, Firefox, Opera and yes, even Internet Explorer!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000079","sortNo":37,"contentFormatId":"1","contentTxt":"But we don’t need to use selenium directly. The Angular team gives a great tool that wraps around Selenium – Protractor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000080","sortNo":38,"contentFormatId":"1","contentTxt":"<strong>2. Protractor</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000081","sortNo":39,"contentFormatId":"1","contentTxt":"Protractor is the testing framework we’ll be using for our Angular 2 applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000082","sortNo":40,"contentFormatId":"1","contentTxt":"Using protractor is as simple as installing the command line tools, creating the configuration file and running the tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000083","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>3. Jasmine</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000084","sortNo":42,"contentFormatId":"1","contentTxt":"Jasmine is the framework we’ll be using for writing tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000085","sortNo":43,"contentFormatId":"1","contentTxt":"Your First Angular 2 Test Project","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000086","sortNo":44,"contentFormatId":"1","contentTxt":"<strong>a. Run the App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000087","sortNo":45,"contentFormatId":"1","contentTxt":"Start off by cloning the git repository that accompanies this tutorial","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000088","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000089","sortNo":47,"contentFormatId":"1","contentTxt":"Once we’ve got everything setup, let’s start off the project with","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000090","sortNo":48,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000091","sortNo":49,"contentFormatId":"1","contentTxt":"just to make sure that everything is running perfectly. This command should compile the typescript files and spin up a server on http://localhost:3000.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000092","sortNo":50,"contentFormatId":"1","contentTxt":"<strong>b. Installation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000093","sortNo":51,"contentFormatId":"1","contentTxt":"Now stop playing around with Jarvis! It’s time to install the testing tools we spoke about earlier; we install protractor using:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000094","sortNo":52,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000095","sortNo":53,"contentFormatId":"1","contentTxt":"This installs two command line tools – protractor and webdriver-manager – a helper tool to quickly get an instance of Selenium Server running.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000096","sortNo":54,"contentFormatId":"1","contentTxt":"Finally, we run","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000097","sortNo":55,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000098","sortNo":56,"contentFormatId":"1","contentTxt":"to download / update to the latest version of Selenium and chromedriver.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000099","sortNo":57,"contentFormatId":"1","contentTxt":"<strong>c. Running Tests for the First Time</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000100","sortNo":58,"contentFormatId":"1","contentTxt":"We need two things to run the tests – a server running our application and an instance of a webdriver through protractor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000101","sortNo":59,"contentFormatId":"1","contentTxt":"Use the <strong>npm run pretest</strong> command to start a simple server on http://localhost:8080.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000102","sortNo":60,"contentFormatId":"1","contentTxt":"Once the server is up and running, you can run <strong>protractor protractor.config.js</strong>. Now sit back and watch protractor fire up an instance of chromedriver and run your tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000103","sortNo":61,"contentFormatId":"1","contentTxt":"<strong>d. protractor.config.json</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000104","sortNo":62,"contentFormatId":"1","contentTxt":"So what’s the configuration magic that makes the testing possible?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000105","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000106","sortNo":64,"contentFormatId":"1","contentTxt":"Let’s break down this configuration file. We need to tell protractor a couple of things.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000107","sortNo":65,"contentFormatId":"1","contentTxt":"<strong>1. How to connect to the web driver</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000108","sortNo":66,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000109","sortNo":67,"contentFormatId":"1","contentTxt":"This tells Protractor to directly connect to the webdriver (instead of connecting to a local Selenium server).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000110","sortNo":68,"contentFormatId":"1","contentTxt":"<strong>2. How to set up the browsers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000111","sortNo":69,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000112","sortNo":70,"contentFormatId":"1","contentTxt":"Simply put, the capabilities option tells protractor which browser to use. We can use multiple browsers by using the multiCapabilities option.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000113","sortNo":71,"contentFormatId":"1","contentTxt":"<strong>3. The test framework we want to use</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000114","sortNo":72,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000115","sortNo":73,"contentFormatId":"1","contentTxt":"We prefer using jasmine as the framework for writing tests, but you could choose any framework you like. Protractor allows you to define Custom Frameworks as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000116","sortNo":74,"contentFormatId":"1","contentTxt":"<strong>4. What tests to run</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000117","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000118","sortNo":76,"contentFormatId":"1","contentTxt":"These are the specs that we want protractor to run. In this case, we’ll be running all the test that we have in the e2e directory and the .e2e-spec.js suffix and extension.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000119","sortNo":77,"contentFormatId":"1","contentTxt":"Note that we aren’t mentioning the .ts (Typescript) files even though we write the tests using Typescript. That’s why we need to run the Typescript compiler tsc before we run these tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000120","sortNo":78,"contentFormatId":"1","contentTxt":"<strong>5. Any global test information</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000121","sortNo":79,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000122","sortNo":80,"contentFormatId":"1","contentTxt":"The baseUrl is the URL the webdriver will visit by default.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000123","sortNo":81,"contentFormatId":"1","contentTxt":"Protractor has many more configuration options available. You can have a look at the entire list here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000124","sortNo":82,"contentFormatId":"1","contentTxt":"<strong>e. The Spec File</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000125","sortNo":83,"contentFormatId":"1","contentTxt":"Now all we need is the actual spec file to write out these tests. Let’s quickly go over the basic tests in this application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000126","sortNo":84,"contentFormatId":"1","contentTxt":"As usual, we start with defining the suite and any setup we need before running each test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000127","sortNo":85,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000128","sortNo":86,"contentFormatId":"1","contentTxt":"Here, we’re using browser.get('') to get the baseUrl that we defined in the config file – so the page gets refreshed before each test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000129","sortNo":87,"contentFormatId":"1","contentTxt":"Let’s just add a simple test first that checks if everything is good so far by checking the title of the page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000130","sortNo":88,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000131","sortNo":89,"contentFormatId":"1","contentTxt":"Next, we’ll run a test to check if the UI has been set up properly and everything is displayed as per our expectations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000132","sortNo":90,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000133","sortNo":91,"contentFormatId":"1","contentTxt":"First, we click the Toggle Jarvis button to call Jarvis (display some text); then, we check if the new element is displayed and finally, we see if Jarvis responded as he should have with a Yes sir!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000134","sortNo":92,"contentFormatId":"1","contentTxt":"This a simple application with simple tests. As applications get more complex, you can use Protractor to fill in forms, navigate to different links and ensure that the browser behaves as it should.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000135","sortNo":93,"contentFormatId":"1","contentTxt":"As your tests start getting larger, you can split them by page or even by feature and use multiple spec files to keep the tests well organized.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000136","sortNo":94,"contentFormatId":"1","contentTxt":"<strong>Concluding Notes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000137","sortNo":95,"contentFormatId":"1","contentTxt":"Remember that we write tests only so that we can find bugs faster and improve the user’s experience.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201610190000000138","sortNo":96,"contentFormatId":"1","contentTxt":"Focus on writing solid unit tests and integration tests; use end to end tests to find those pesky environment / browser specific bugs.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201701230000000209","sortNo":1,"contentFormatId":"1","contentTxt":"One of the design goals of Angular is to make testing easy. That’s why the framework relies on dependency injection, separates the user code from the framework code, and comes with a set of tools for writing and running tests. In this article I will look at four ways to test Angular components: isolated tests, shallow tests, integration tests, and protractor tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000210","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000211","sortNo":3,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000212","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000213","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Isolated Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000214","sortNo":6,"contentFormatId":"1","contentTxt":"It is often useful to test complex components without rendering them. To see how it can be done, let’s write a test for the following component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000215","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000216","sortNo":8,"contentFormatId":"1","contentTxt":"filters.component.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000217","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000218","sortNo":10,"contentFormatId":"1","contentTxt":"There a few things in this example worth noting:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000219","sortNo":11,"contentFormatId":"1","contentTxt":"1. We are using reactive forms in the template of this component. This require us to manually create a form object in the component class, which has a nice consequence: we can test input handling without rendering the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000220","sortNo":12,"contentFormatId":"1","contentTxt":"2. We listen to all the form changes, debounce them using the RxJS debounceTime operator, and then emit a change event.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000221","sortNo":13,"contentFormatId":"1","contentTxt":"3. Finally, we inject a function to create a filters object out of the form.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000222","sortNo":14,"contentFormatId":"1","contentTxt":"Now, let’s look at the test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000223","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000224","sortNo":16,"contentFormatId":"1","contentTxt":"As you can see, testing Angular components in isolation is no different from testing any other JavaScript object. We do not use any Angular UI-specific utilities. We, however, use fakeAsync. This is a utility provided by zone.js and using it we can control time, which is handy for testing the debouncing. Also, this test does not exercise the template of this component. The template might as well be empty — the test will still pass.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000225","sortNo":17,"contentFormatId":"1","contentTxt":"<strong>Shallow Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000226","sortNo":18,"contentFormatId":"1","contentTxt":"Testing component classes without rendering their templates works in certain scenarios, but not in all of them. Sometimes we can write a meaningful test only if we render a component’s template. We can do that and still keep the test isolated. We just need to render the template without rendering the component’s children. This is what is colloquially known as shallow testing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000227","sortNo":19,"contentFormatId":"1","contentTxt":"Let’s see this approach in action.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000228","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000229","sortNo":21,"contentFormatId":"1","contentTxt":"This component simply renders a collection of TalkCmp.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000230","sortNo":22,"contentFormatId":"1","contentTxt":"Now let’s look at its test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000231","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000232","sortNo":24,"contentFormatId":"1","contentTxt":"First, look at how we configured our testing module. We only declared TalksCmp, nothing else. This means that all the elements in the template will be treated as simple DOM nodes, and only common directives (e.g., ngIf and ngFor) will be applied. This is exactly what we want. Second, passing NO_ERRORS_SCHEMA tells the compiler not to error on unknown elements and attributes, which is what we need for shallow tests. The result will create a list of talk-cmp DOM elements, which we inspected in the test. No instances of TalkCmp were created.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000233","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Integration Testing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000234","sortNo":26,"contentFormatId":"1","contentTxt":"We can also write an integration test that will exercise the whole application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000235","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000236","sortNo":28,"contentFormatId":"1","contentTxt":"Note here we are importing AppModule, which means that Angular will create all the registered provides and will compile all the registered components. The test itself is self explanatory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000237","sortNo":29,"contentFormatId":"1","contentTxt":"Even though both the shallow and integration tests render components, these tests are very different in nature. In the shallow test we mock up every single dependency of a component, and we do not render any of the component’s children. The goal is to exercise one slice of the component tree in isolation. In the integration tests we mock up only platform dependencies (e.g, location), and we use production code for the rest. Shallow tests are isolated, and, as a result, can be used to drive the design of our components. Integration tests are only used to check the correctness.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000238","sortNo":30,"contentFormatId":"1","contentTxt":"<strong>Protractor Tests</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000239","sortNo":31,"contentFormatId":"1","contentTxt":"Finally, we can always write a protractor test exercising the whole application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000240","sortNo":32,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000241","sortNo":33,"contentFormatId":"1","contentTxt":"First, we created a page object, which is a good practice for making tests more domain-centric, so they talk more about user stories and not the DOM. Second, we wrote a protractor test verifying that filtering by title works.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000242","sortNo":34,"contentFormatId":"1","contentTxt":"Both protractor tests and integration tests (as defined above), solve the same problem — they verify correctness, i.e., they verify that a particular use case have been implemented. Which ones should we use? I tend to test most of the behavior using integration tests, and use protractor only for a few smoke tests, but it is highly dependent on the culture of the team.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000243","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>Let’s Recap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000244","sortNo":36,"contentFormatId":"1","contentTxt":"In this article we looked at four ways to test Angular components: isolated tests, shallow tests, integration tests, and protractor tests. Each of them have their time and place: isolated tests are a great way to test drive your components and test complex logic. Shallow tests are isolated tests on steroids, and they should be used when writing a meaningful test requires to render a component’s template. Finally, integration and protractor tests verify that a group of components and services (i.e., the application) work together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000245","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000246","sortNo":38,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
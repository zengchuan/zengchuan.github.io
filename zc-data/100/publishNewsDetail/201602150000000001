[{"id":"201602150000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Angular 2 provides a new pattern for running asynchronous requests, called Observables. Here, we will review a few of the concepts and eventually see how to run multiple concurrent HTTP requests, with the callbacks running only after all of them have completed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Note: At the time of this writing, Angular 2 is still in beta. Some details may change between now and the final release.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000003","sortNo":3,"contentFormatId":"1","contentTxt":"About Observables and the Http service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Angular 1 developers should be familiar with using Promises to load data asynchronously. Angular 2 uses an analogous pattern called Observables. The Observable classes in Angular 2 are provided by the ReactiveX library.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000005","sortNo":5,"contentFormatId":"1","contentTxt":"The Http service in Angular 2 is the successor to Angular 1's $http. Instead of returning a Promise, its http.get() method returns an Observable object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Getting started","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000007","sortNo":7,"contentFormatId":"1","contentTxt":"To use the HTTP service and Observables, we need to add a few logistics to our index.html and Angular 2 bootstrap file.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000008","sortNo":8,"contentFormatId":"1","contentTxt":"index.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000009","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000083","sortNo":10,"contentFormatId":"1","contentTxt":"Notice the script tags that source Rx.js and http.dev.js. We will need these files in order to load the correct libraries to use Http and Observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000084","sortNo":11,"contentFormatId":"1","contentTxt":"Also notice the 'rxjs' configuration in the System.config() call. This provides the context necessary to use some of our import statements in our Typescript files.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000085","sortNo":12,"contentFormatId":"1","contentTxt":"App/boot.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000086","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000087","sortNo":14,"contentFormatId":"1","contentTxt":"Here we import HTTP_PROVIDERS and inject it as a dependency into the app. We also import 'rxjs/add/operator/map' which provides the map() method on our Observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000088","sortNo":15,"contentFormatId":"1","contentTxt":"Note: Many alpha releases of Angular 2 included the map() method automatically. This was later removed from the automatic import. The beta releases require this to be imported separately.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000089","sortNo":16,"contentFormatId":"1","contentTxt":"App/app.component.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000090","sortNo":17,"contentFormatId":"1","contentTxt":"Our demo app contains only one simple component, which contains a few elements to display some simple data. We will be loading data from a few JSON files, to simulate an API call.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000091","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000092","sortNo":19,"contentFormatId":"1","contentTxt":"Executing a single HTTP request","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000093","sortNo":20,"contentFormatId":"1","contentTxt":"We can use the HTTP service to request a single resource, by using http.get. This is similar to Angular 1. To do this, we add the following code to our app.component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000094","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000095","sortNo":22,"contentFormatId":"1","contentTxt":"We keep the constructor simple here. All it does is initialize the http variable. We'll use the ngOnInit() hook to start the data loading.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000096","sortNo":23,"contentFormatId":"1","contentTxt":"Just like Angular 1, we use http.get() to run our HTTP request. This returns an Observable object, which gives us methods like map() for configuring the data processing, and subscribe() for observing the output.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000097","sortNo":24,"contentFormatId":"1","contentTxt":"Angular doesn't yet know that we want to parse the response as JSON. We can let it know this by using the .map((res:Response) => res.json())call. This also returns an Observable, useful for method chaining.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000098","sortNo":25,"contentFormatId":"1","contentTxt":"To receive the output, we call the subscribe() method. This takes three arguments which are event handlers. They are called onNext, onError, and onCompleted. The onNext method will receive the HTTP response data. Observables support streams of data and can call this event handler multiple times. In the case of the HTTP request, however, the Observable will usually emit the whole data set in one call. The onError event handler is called if the HTTP request returns an error code such as a 404. The onCompleted event handler executes after the Observable has finished returning all its data. This is less useful in the case of the Http.get() call, because all the data we need is passed into the onNext handler.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000099","sortNo":26,"contentFormatId":"1","contentTxt":"For more information about the Observable object, see the ReactiveX documentation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000100","sortNo":27,"contentFormatId":"1","contentTxt":"In our example here, we use the onNext handler to populate the component's 'foods' variable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000101","sortNo":28,"contentFormatId":"1","contentTxt":"The error handler just logs the error to the console. The completion callback runs after the success callback is finished.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000102","sortNo":29,"contentFormatId":"1","contentTxt":"The handler functions are optional. If you don't need the error or completion handler, you may omit them. If you don't provide an error handler, however, you may end up with an uncaught Error object which will stop execution of your application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000103","sortNo":30,"contentFormatId":"1","contentTxt":"Executing multiple concurrent HTTP requests","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000104","sortNo":31,"contentFormatId":"1","contentTxt":"Many times, we need to load data from more than one source, and we need to delay the post-loading logic until all the data has loaded. ReactiveX Observables provide a method called forkJoin() to wrap multiple Observables. Its subscribe() method sets the handlers on the entire set of Observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000105","sortNo":32,"contentFormatId":"1","contentTxt":"To run the concurrent HTTP requests, let's add the following code to our component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000106","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000107","sortNo":34,"contentFormatId":"1","contentTxt":"Notice that forkJoin() takes multiple arguments of type Observable. These can be Http.get() calls or any other asynchronous operation which implements the Observable pattern. We don't subscribe to each of these Observables individually. Instead, we subscribe to the \"container\" Observable object created by forkJoin().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000108","sortNo":35,"contentFormatId":"1","contentTxt":"When using Http.get() and Observable.forkJoin() together, the onNext handler will execute only once, and only after all HTTP requests complete successfully. It will receive an array containing the combined response data from all requests. In this case, our books data will be stored in data[0] and our movies data will be stored in data[1].","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000109","sortNo":36,"contentFormatId":"1","contentTxt":"The onError handler here will run if either of the HTTP requests returns an error code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000110","sortNo":37,"contentFormatId":"1","contentTxt":"Refactoring the data loading into a Service","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000111","sortNo":38,"contentFormatId":"1","contentTxt":"Now that we have seen the entire lifetime of an Observable object, we can refactor part of the logic into a Service for reusability.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000112","sortNo":39,"contentFormatId":"1","contentTxt":"I find it useful for the Services to return an Observable, rather than the final data. This allows the component to subscribe to the Observable and either populate the local data variables or show an error message to the user.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000113","sortNo":40,"contentFormatId":"1","contentTxt":"First, we create our new Service, called DemoService:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000114","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000115","sortNo":42,"contentFormatId":"1","contentTxt":"This is the same logic that we formerly had in our component. However, notice that the methods of this service return Observable objects. In our AppComponent, we will subscribe to the onNext, onError, and onComplete callbacks.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000116","sortNo":43,"contentFormatId":"1","contentTxt":"After creating our new service, we need to inject it into the application in boot.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000117","sortNo":44,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000118","sortNo":45,"contentFormatId":"1","contentTxt":"Our refactored AppComponent","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000119","sortNo":46,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000120","sortNo":47,"contentFormatId":"1","contentTxt":"Notice that we are now injecting the DemoService into the constructor, instead of the Http object. We also need to import DemoService at the top of the file, instead of Http. We then call methods of this._demoService instead of this.http.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000121","sortNo":48,"contentFormatId":"1","contentTxt":"Also notice that we have added an error message in the template. This will be hidden unless the Observable's onError handler runs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000122","sortNo":49,"contentFormatId":"1","contentTxt":"source code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602150000000123","sortNo":50,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/kdechant/angular2-http-demo\">https://github.com/kdechant/angular2-http-demo</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
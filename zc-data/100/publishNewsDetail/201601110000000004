[{"id":"201601110000000176","sortNo":1,"contentFormatId":"1","contentTxt":"In a previous post we showed how to leverage Observables, and especially their strength of composability to ease complicated async tasks.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000177","sortNo":2,"contentFormatId":"1","contentTxt":"As a recap, we built a simple wikipedia search demo consisting of a WikipediaService to query a JSONP API.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000178","sortNo":3,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000179","sortNo":4,"contentFormatId":"1","contentTxt":"We also built an App component that uses this service and applies some Rx gymnastics to tame the user input, prevent duplicate requests and deal with out-of-order responses.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000180","sortNo":5,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000181","sortNo":6,"contentFormatId":"1","contentTxt":"Thinking ahead we can refactor our code even further and let our API design leverage from the power of Observables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000182","sortNo":7,"contentFormatId":"1","contentTxt":"Observables = Promises + Events (in a way!)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000183","sortNo":8,"contentFormatId":"1","contentTxt":"In a way Observables may be seen as the clever child of Events and Promises. Promises are first class objects that encapsulate the state of an asynchronous operation. But they are for singular operations only. A request is such an operation. You invoke a method, kicking off some async task and get a first class object that eventually will get you to the result of the operation (ignoring error handling for now).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000184","sortNo":9,"contentFormatId":"1","contentTxt":"Events on the other hand are for async operations that can continue to emit new values for an infinite duration. But Unfortunately they are traditionally not represented in a format that matches the criteria of a first class object. You can’t just pass an event of clicks around that skips every third click for instance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000185","sortNo":10,"contentFormatId":"1","contentTxt":"Well, with Observables you can. You get the power of first class objects but without the limitations of singularity.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000186","sortNo":11,"contentFormatId":"1","contentTxt":"In fact, in a modern .NET language such as F#, which embraces Observables all the way down, every IEvent<T> inherits from IObservable<T>. Angular also went down this path and made EventEmiter<T> implement Observable<T>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000187","sortNo":12,"contentFormatId":"1","contentTxt":"Smart service, dumb component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000188","sortNo":13,"contentFormatId":"1","contentTxt":"With that in mind: wouldn’t it be actually nice if we could save the component from dealing with all these edge cases? What if we just make the debounce duration configureable but let the rest of the complexity be handled by our WikipediaService?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000189","sortNo":14,"contentFormatId":"1","contentTxt":"To let code speak we can transform our WikipediaService into this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000190","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000191","sortNo":16,"contentFormatId":"1","contentTxt":"Notice that the service still exposes the previous api as rawSearch and builds a more clever search API on top of it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000192","sortNo":17,"contentFormatId":"1","contentTxt":"This dramatically simplifies our App component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000193","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601110000000194","sortNo":19,"contentFormatId":"1","contentTxt":"See what happened? We just wire together event streams like lego blocks!","contentBinary":"","contentPoster":"","contentUrl":null}]
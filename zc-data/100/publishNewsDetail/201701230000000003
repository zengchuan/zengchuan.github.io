[{"id":"201701230000000151","sortNo":1,"contentFormatId":"1","contentTxt":"This is the fourth post in the Essential Angular series, which aims to be a short, but at the same time, fairly complete overview of the key aspects of Angular. In this post I’ll cover change detection and data flow.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000152","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000153","sortNo":3,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000154","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000155","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Two Phases</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000156","sortNo":6,"contentFormatId":"1","contentTxt":"Angular separates updating the application model and reflecting the state of the model in the view into two distinct phases. The developer is responsible for updating the application model. Angular via bindings, by means of change detection, is responsible for reflecting the state of the model in the view. The framework does it automatically on every VM turn.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000157","sortNo":7,"contentFormatId":"1","contentTxt":"Event bindings, which can be added using the () syntax, can be used to capture a browser event or component output to execute some function on a component or a directive. So they often trigger the first phase.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000158","sortNo":8,"contentFormatId":"1","contentTxt":"Property bindings, which can be added using the [] syntax, should be used only for reflecting the state of the model in the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000159","sortNo":9,"contentFormatId":"1","contentTxt":"As we have learned, an Angular application consists of nested components, so it will always have a component tree. Let’s say for this app it looks as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000160","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000161","sortNo":11,"contentFormatId":"1","contentTxt":"Next, define the application model that will store the state of our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000162","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000163","sortNo":13,"contentFormatId":"1","contentTxt":"Now, imagine an event changing the model. Let’s say I watched the talk “Are we there yet”, I really liked it, and I decided to give it 9.9.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000164","sortNo":14,"contentFormatId":"1","contentTxt":"The code snippet below shows one way to do it. The `handleRate` function is called, via an event binding, when the user rates a talk.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000165","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000166","sortNo":16,"contentFormatId":"1","contentTxt":"In this example, we do not mutate the talk, and instead create a new array of new talks every time a change happens, which results in a few good properties. But it is worth noting that Angular doesn’t require us to use immutable objects, and we could just as easily write something like `talk.rating = newRating`.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000167","sortNo":17,"contentFormatId":"1","contentTxt":"All right, after `rateTalk` executes, the updated model will look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000168","sortNo":18,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000169","sortNo":19,"contentFormatId":"1","contentTxt":"At this point nothing has changed in the view. Only the model has been updated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000170","sortNo":20,"contentFormatId":"1","contentTxt":"Next, at the end of the VM turn, change detection kicks in to propagate changes in the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000171","sortNo":21,"contentFormatId":"1","contentTxt":"First, change detection goes through every component in the component tree to check if the model it depends on changed. And if it did, it will update the component. In this example, the first talk component gets updated:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000172","sortNo":22,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000173","sortNo":23,"contentFormatId":"1","contentTxt":"Then, the framework updates the DOM. In our example, the rate button gets disabled because we cannot rate the same talk twice.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000174","sortNo":24,"contentFormatId":"1","contentTxt":"Note, the framework has used change detection and property bindings to execute this phase.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000175","sortNo":25,"contentFormatId":"1","contentTxt":"In our example we are using shared state and immutable data. But even if we used local state and mutable data, it would not change the property that the application model update and the view state propagation are separated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000176","sortNo":26,"contentFormatId":"1","contentTxt":"Why?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000177","sortNo":27,"contentFormatId":"1","contentTxt":"Now, when we have understood how we had separated the two phases, let’s talk about why we did it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000178","sortNo":28,"contentFormatId":"1","contentTxt":"<strong>Predictability</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000179","sortNo":29,"contentFormatId":"1","contentTxt":"First, using change detection only for updating the view state limits the number of places where the application model can be changed. In this example it can happen only in the `rateTalk` function. A watcher cannot “automagically” update it. This makes ensuring invariants easier, which makes code easier to troubleshoot and refactor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000180","sortNo":30,"contentFormatId":"1","contentTxt":"Second, it helps us understand the view state propagation. Consider what we can say about the talk component just by looking at it in isolation. Since we use immutable data, we know that as long as we do not do talk= in the Talk component, the only way to change what the component displays is by updating the input. These are strong guarantees that allow us to think about this component in isolation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000181","sortNo":31,"contentFormatId":"1","contentTxt":"Finally, by explicitly stating what the application and the framework are responsible for, we can set different constraints on each part. For instance, it is natural to have cycles in the application model. So the framework should support it. On the other hand, html forces components to form a tree structure. We can take advantage of this and make the system more predictable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000182","sortNo":32,"contentFormatId":"1","contentTxt":"Starting with Angular 2.x it gets easier to think about components because the framework limits the number of ways it can modify the components, and those modifications are predictable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000183","sortNo":33,"contentFormatId":"1","contentTxt":"<strong>Performance</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000184","sortNo":34,"contentFormatId":"1","contentTxt":"The major benefit of the separation is that it allows us to constrain the view state propagation. This makes the system more predictable, but it also makes it a lot more performant. For example, the fact that the change detection graph in Angular can be modeled as a tree allowed us to get rid of digest TTL (multiple digest runs until no changes occur). Now the system gets stable after a single pass.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000185","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>How Does Angular Enforce It?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000186","sortNo":36,"contentFormatId":"1","contentTxt":"What happens if I try to break the separation? What if I try to change the application model inside a setter that is invoked by the change detection system?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000187","sortNo":37,"contentFormatId":"1","contentTxt":"Angular tries to make sure that the setter we define for our component only updates the view state of this component or its children, and not the application model. To do that Angular will check all bindings twice in the developer mode. First time to propagate changes, and second time to make sure there are no changes. If it finds a change during the second pass, it means that one of our setters updated the application model, the framework will throw an exception, pointing at the place where the violation happened.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000188","sortNo":38,"contentFormatId":"1","contentTxt":"<strong>Content and View Children</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000189","sortNo":39,"contentFormatId":"1","contentTxt":"Earlier I said “change detection goes through every component in the component tree to check if the model it depends on changed” without saying much about how the framework does it. In what order does it do it? Understanding this is crucial, and that’s what I’m going to cover in this section.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000190","sortNo":40,"contentFormatId":"1","contentTxt":"There are two types of children a component can have: content children and view children. To understand the difference between them, let’s look at the following example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000191","sortNo":41,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000192","sortNo":42,"contentFormatId":"1","contentTxt":"The content children of the tabs component are the three tab components. The user of the tabs component provided those. The previous and next buttons are the view children of the tabs component. The author of the tabs component provided those.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000193","sortNo":43,"contentFormatId":"1","contentTxt":"This is the order in which Angular will check the bindings:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000194","sortNo":44,"contentFormatId":"1","contentTxt":"1. It will check the bindings of the tabs component first, of which there are none.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000195","sortNo":45,"contentFormatId":"1","contentTxt":"2. It will check the three tab component, the content children of the tabs component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000196","sortNo":46,"contentFormatId":"1","contentTxt":"3. It will check the template of the tabs component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000197","sortNo":47,"contentFormatId":"1","contentTxt":"<strong>ChangeDetectionStrategy.OnPush</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000198","sortNo":48,"contentFormatId":"1","contentTxt":"If we use mutable objects that are shared among multiple components, Angular cannot know about when those components can be affected. A component can affect any other components in the system. That is why, by default, Angular does not make any assumptions about what a component depends upon. So it has be conservative and check every template of every component on every browser event. Since the framework has to do it for every component, it might become a performance problem even though the change detection in the new versions of Angular got way faster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000199","sortNo":49,"contentFormatId":"1","contentTxt":"If our model application state uses immutable objects, like in the example above, we can tell a lot more about when the talk component can change. The component can change if and only if any of its inputs changes. And we can communicate it to Angular by setting the change detection strategy to OnPush.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000200","sortNo":50,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000201","sortNo":51,"contentFormatId":"1","contentTxt":"Using this change-detection strategy restricts when Angular has to check for updates from “any time something might change” to “only when this component’s inputs have changed”. As a result, the framework can be a lot more efficient about detecting changes in TalkCmp. If no inputs change, no need to check the component’s template. In addition to depending on immutable inputs OnPush components can also have local mutable state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000202","sortNo":52,"contentFormatId":"1","contentTxt":"<strong>Let’s Recap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000203","sortNo":53,"contentFormatId":"1","contentTxt":"1. Angular separates updating the application model and updating the view.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000204","sortNo":54,"contentFormatId":"1","contentTxt":"2. Event bindings are used to update the application model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000205","sortNo":55,"contentFormatId":"1","contentTxt":"3. Change detection uses property bindings to update the view. Updating the view is unidirectional and top-down. This makes the system more predictable and performant.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000206","sortNo":56,"contentFormatId":"1","contentTxt":"4. We make the system more efficient by using the OnPush change detection strategy for the components that depend on immutable input and only have local mutable state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000207","sortNo":57,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000208","sortNo":58,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
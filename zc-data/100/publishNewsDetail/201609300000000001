[{"id":"201609300000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Animations features often are scary goals for developers. And Angular’s doctrine “… controllers should not directly modify DOM elements!” made Animation features intimidating as hell. But Angular 2 animations are not scary! Templates are closely associated/integrated with @Component. We will notice that animations following a similar pattern.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Let’s build a component that hides and shows its contents, uses fade animation effects, and allows external components to easily trigger those fade effects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Our Scenario</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Here is a simple Angular 2 component with hide and show features. This sample, however, does not have animations (yet):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000005","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000006","sortNo":6,"contentFormatId":"1","contentTxt":"This component simply publishes an @Input() isVisible property; which allows other external components to show/hide the text content… without any animations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000007","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000008","sortNo":8,"contentFormatId":"1","contentTxt":"<strong>Configure Component Animations</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000009","sortNo":9,"contentFormatId":"1","contentTxt":"We want the my-fader component to fade-in or fade-out its text content. And we want to animate those fades effects.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000010","sortNo":10,"contentFormatId":"1","contentTxt":"To start animating, let’s first add animation metadata to our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000011","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Above we show that the animations metadata property is defined in the @Component decorator. Just like template metadata property!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Since our component has a visibility property whose state can change between shown and hidden, let’s configure animations to trigger and animate during each value change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000014","sortNo":14,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Before we add more metadata, let’s talk about the syntax above. What does it mean… and why is this syntax used?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000016","sortNo":16,"contentFormatId":"1","contentTxt":"The techno-speak above is saying that when the visibilityChanged property changes and the value == shown, then the target element opacity changes to 1. And when the value changes to == hidden, the target element opacity should change to 0.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000017","sortNo":17,"contentFormatId":"1","contentTxt":"Note: The [@visibilityChanged] binding is on <div> child content element in the <my-fader> component. It is NOT on the <my-fader> element itself. In other words, the animation target in our example is actually the <div> element; not the component host element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000018","sortNo":18,"contentFormatId":"1","contentTxt":"Now, you might also wonder where visibilityChanged comes from? Because our component property is just called visibility. Hold your wild horses Mr. StageCoach, we’ll clarify that soon!” Let’s first talk about animation durations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000019","sortNo":19,"contentFormatId":"1","contentTxt":"We want to animate these changes over a time duration instead of instantly hiding/showing the content. We need to configure a transition to specify animation durations. With Angular 2 this is also suprisingly easy:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000020","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000021","sortNo":21,"contentFormatId":"1","contentTxt":"With the above transition, we added information to the animation configuration so each trigger value change will have a 500 msec transition.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000022","sortNo":22,"contentFormatId":"1","contentTxt":"So a fade-in (opacity 0 -> 1, with a duration of 500 msec) will occur when the value changes from hidden to shown. And likewise the fade-out (opacity 1 -> 0, with a duration of 500 msec) will occur when the value changes from shown to hidden. By the way, you could also have used animate('500ms') to indicate the millsecond duration explicitly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000023","sortNo":23,"contentFormatId":"1","contentTxt":"And what does the transition('* => *', ...) mean? Think of * => * as a transition from one state to another state; where * is a wildcard to mean any state value. If we wanted the fade-out to be slower than the fade-in, here is how we would configure the animation metadata:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000024","sortNo":24,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000025","sortNo":25,"contentFormatId":"1","contentTxt":"See how easy this is? This notation is so easy to understand.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000026","sortNo":26,"contentFormatId":"1","contentTxt":"<strong>The Essential Concept</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000027","sortNo":27,"contentFormatId":"1","contentTxt":"The essential take-away Animation concept is that Angular 2 Animations are triggered on component state changes. And developers should consider state changes to be equivalent to value changes in a property of the component instance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000028","sortNo":28,"contentFormatId":"1","contentTxt":"<strong>Linking Animation to the Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000029","sortNo":29,"contentFormatId":"1","contentTxt":"While we configured the Animation metadata, I am sure you are wondering:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000030","sortNo":30,"contentFormatId":"1","contentTxt":"1. How is the animation property visibilityChanged actually connected to the component?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000031","sortNo":31,"contentFormatId":"1","contentTxt":"2. How are the animations linked to the component’s properties?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000032","sortNo":32,"contentFormatId":"1","contentTxt":"Since data-binding features are already supported between the component and its template, Angular 2 uses a special template animation syntax to support triggering the animation after data-binding changes. So in the component template, we can do this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000033","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000034","sortNo":34,"contentFormatId":"1","contentTxt":"Above the @visibilityChanged is the special template animation property and it uses databinding [@visibilityChanged]=“visibility” to bind the component’s visibility property to the animation trigger property visibilityChanged.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000035","sortNo":35,"contentFormatId":"1","contentTxt":"Here is the entire component definition updated with Animation features:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000036","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000037","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>Reducing Complexity</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000038","sortNo":38,"contentFormatId":"1","contentTxt":"What if - instead of the using the extra visibility property - you just wanted to use the isVisible property directly? This would obviate ngOnChanges() and reduce the code complexity to:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000039","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000040","sortNo":40,"contentFormatId":"1","contentTxt":"I love the tersity of this code. But this will not work without another important change to the animation metadata!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000041","sortNo":41,"contentFormatId":"1","contentTxt":"Remember that the @visibilityChanged animation trigger property has defined states for the values: shown or hidden.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000042","sortNo":42,"contentFormatId":"1","contentTxt":"If you use the myFader::isVisible boolean property, then your animation state values must be changed to true and false since those are the possible values of the isVisible property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000043","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000044","sortNo":44,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Extra Bonus: The demo has some extra features. The host my-fader element now has a purple background; when you hide the my-fader content children you will see the host background. This change was added so you can visually see the differences between the host and the target animation elements.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000046","sortNo":46,"contentFormatId":"1","contentTxt":"<strong>Our Animation Workflow</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000047","sortNo":47,"contentFormatId":"1","contentTxt":"Above we have an improved the component definition; enhanced with animation features. Here is a workflow of the [animation] process:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000048","sortNo":48,"contentFormatId":"1","contentTxt":"1. the input value for isVisible changes","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000049","sortNo":49,"contentFormatId":"1","contentTxt":"2. the template databinding updates the @visibilityChanged property","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000050","sortNo":50,"contentFormatId":"1","contentTxt":"3. the animation trigger is invoked","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000051","sortNo":51,"contentFormatId":"1","contentTxt":"4. the @visibilityChanged value is used to identify the state animations and transitions","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000052","sortNo":52,"contentFormatId":"1","contentTxt":"5. the target element opacity (and other properties) change-animates for xxx msecs","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000053","sortNo":53,"contentFormatId":"1","contentTxt":"<strong>Animation Philosophy</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000054","sortNo":54,"contentFormatId":"1","contentTxt":"One of the design goals for Angular 2 Animations is to make it easy for developers to configure and use animations. The API and syntax is designed to be:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000055","sortNo":55,"contentFormatId":"1","contentTxt":"1. intuitive","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000056","sortNo":56,"contentFormatId":"1","contentTxt":"2. declarative","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000057","sortNo":57,"contentFormatId":"1","contentTxt":"3. immediately associated with the component using metadata","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000058","sortNo":58,"contentFormatId":"1","contentTxt":"The best part of Angular 2 Animation design is that the component->template->animation binding solution decouples the animation from the component internals and uses the template as the binding bridge.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000059","sortNo":59,"contentFormatId":"1","contentTxt":"The developer decides which component properties should bind to which animation triggers, then simply uses the possible component property values to set the animation state values accordingly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000060","sortNo":60,"contentFormatId":"1","contentTxt":"In most cases, you will never need to write JavaScript animation logic.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000061","sortNo":61,"contentFormatId":"1","contentTxt":"All the mechanics of preparing and managing the animations are hidden from the developer. This ‘separation of concerns’ provides HUGE benefits to allow developers to easily use Angular 2 Animations with custom architectures & custom implementations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000062","sortNo":62,"contentFormatId":"1","contentTxt":"<strong>Animations with Components Hierarchies</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000063","sortNo":63,"contentFormatId":"1","contentTxt":"Components should never be concerned with the details regarding animation of child components. Parent components can monitor and alter the public state of child components, but should never attempt to modify the internals of those components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000064","sortNo":64,"contentFormatId":"1","contentTxt":"In our examples (above), parent components can simply change the state of the child my-fader instances and then magically the contents of the my-fader instance will fadeIn or fadeOut.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000065","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000066","sortNo":66,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000067","sortNo":67,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000068","sortNo":68,"contentFormatId":"1","contentTxt":"The Angular 2 Animation engine and compiler does all the hard work preparing, managing, and running the animations. Developers use the @Component metadata to declaratively define the component styles, templates, and [now] animations. And it is the component template that serves as the bridge to link the component instance state to the animation trigger property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000069","sortNo":69,"contentFormatId":"1","contentTxt":"<strong>Thanks</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000070","sortNo":70,"contentFormatId":"1","contentTxt":"Kudos to Matias Niemelä for the amazing Animation engine in Angular 2!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609300000000071","sortNo":71,"contentFormatId":"1","contentTxt":"These core animation features [discussed above] are available in the Angular 2.0.0 release. And never fear, Matias and his team are working hard on more amazing, intuitive Animation features. So stay tuned for even MORE cool features and blogs coming soon!","contentBinary":"","contentPoster":"","contentUrl":null}]
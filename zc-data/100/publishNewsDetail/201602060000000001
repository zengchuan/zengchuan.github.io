[{"id":"201602060000000001","sortNo":1,"contentFormatId":"1","contentTxt":"In this article I'm going to explain the difference between the concepts of view children and content children in Angular 2. We will take a look at how we can pass access these two different kinds of children from their parent component. Along the content we are also going to mention what the difference between the properties providers and viewProviders of the @Component decorator is.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Composing primitives","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000003","sortNo":3,"contentFormatId":"1","contentTxt":"First of all, lets clarify the relation between the component and directive concepts in Angular 2. A typical design pattern for developing user interface is the composite pattern. It allows us to compose different primitives and treat them the same way as a single instance. In the world of functional programming we can compose functions. For instance:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000004","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000005","sortNo":5,"contentFormatId":"1","contentTxt":"The Haskell code above we compose the functions (*2) and (+1) so that to each item n in the list will be applied the following sequence of operations n -> + 1 -> * 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000006","sortNo":6,"contentFormatId":"1","contentTxt":"Composition in the UI","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000007","sortNo":7,"contentFormatId":"1","contentTxt":"Well, in the user interface it is actually quite similar. We can think of the individual component as functions. These functions can be composed together in order and as result we get more complex functions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000008","sortNo":8,"contentFormatId":"1","contentTxt":"We can illustrate this graphically by the following structural diagram:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000009","sortNo":9,"contentFormatId":"1","contentTxt":"In the figure above we have two elements:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000144","sortNo":10,"contentFormatId":"1","contentTxt":"1. Directive - A self-contained element which holds some logic, but does not contain any structure.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000145","sortNo":11,"contentFormatId":"1","contentTxt":"2. Component - An element, which specifies the Directive element and holds a list of other Directive instances (which could also be components since Component extends Directive).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000146","sortNo":12,"contentFormatId":"1","contentTxt":"This means that using the preceding abstractions we can build structures of the following form:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000147","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000148","sortNo":14,"contentFormatId":"1","contentTxt":"On the above figure we can see a hierarchical structure of components and directives. The leaf elements on the diagram are either directives or components that don't hold references.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000149","sortNo":15,"contentFormatId":"1","contentTxt":"Composition of Components in Angular 2","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000150","sortNo":16,"contentFormatId":"1","contentTxt":"Now, in order to be more specific, lets switch to the context of Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000151","sortNo":17,"contentFormatId":"1","contentTxt":"In order to better illustrate the concepts we are going to explore, lets build a simple application:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000152","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000153","sortNo":19,"contentFormatId":"1","contentTxt":"Yes, this is going to be \"Yet another MV* todo application\". Above we define a component with selector todo-app which has an inline template, and defines a set of directives that it or any of its child components is going to use.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000154","sortNo":20,"contentFormatId":"1","contentTxt":"We can use the component in the following way:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000155","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000156","sortNo":22,"contentFormatId":"1","contentTxt":"Well, this is basically an XML, so between the opening and closing tags of the todo-app element we can put some content:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000157","sortNo":23,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000158","sortNo":24,"contentFormatId":"1","contentTxt":"Basic Content Projection with ng-content","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000159","sortNo":25,"contentFormatId":"1","contentTxt":"Now lets switch back to the todo-app component's definition for a second. Notice the last element in its template: <ng-content select=\"footer\"></ng-content>. With ng-content we can grab the content between the opening and closing tag of the todo-app element and project it somewhere inside of the template! The value of the select attribute is a CSS selector, which allows us to select the content that we want to project. For instance in the example above, the footer will be injected at the bottom of the rendered todo component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000160","sortNo":26,"contentFormatId":"1","contentTxt":"We can also skip the select attribute of the ng-content element. In this case we will project the entire content passed between the opening and closing tags on the place of the ng-content element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000161","sortNo":27,"contentFormatId":"1","contentTxt":"There are two more components which are not interesting for our discussion so we are going to omit their implementation. The end result of the application will be as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000162","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000163","sortNo":29,"contentFormatId":"1","contentTxt":"ViewChildren and ContentChildren","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000164","sortNo":30,"contentFormatId":"1","contentTxt":"And yes, it was that easy! Now we are ready to define what the concepts of view children and content children are. *The children element which are located inside of its template of a component are called *view children *. On the other hand, *elements which are used between the opening and closing tags of the host element of a given component are called content children **.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000165","sortNo":31,"contentFormatId":"1","contentTxt":"This means that todo-input and todo could be considered view children of todo-app, and footer (if it is defined as Angular 2 component or directive) could be considered as a content child.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000166","sortNo":32,"contentFormatId":"1","contentTxt":"Accessing View and Content Children","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000167","sortNo":33,"contentFormatId":"1","contentTxt":"Now comes the interesting part! Lets see how we can access and manipulate these two types of children!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000168","sortNo":34,"contentFormatId":"1","contentTxt":"Playing around with View Children","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000169","sortNo":35,"contentFormatId":"1","contentTxt":"Angular 2 provides the following property decorators in the angular2/core package: @ViewChildren, @ViewChild, @ContentChildren and @ContentChild. We can use them the following way:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000170","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000171","sortNo":37,"contentFormatId":"1","contentTxt":"The example above shows how we can take advantage of @ViewChildren and @ViewChild. Basically we can decorate a property and this way query the view of an element. In the example above, we query the TodoInputCmp child component with @ViewChild and TodoCmp with @ViewChildren. We use different decorators since we have only a single input, so we can grab it with @ViewChild but we have multiple todo items rendered, so for them we need to apply the @ViewChildren decorator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000172","sortNo":38,"contentFormatId":"1","contentTxt":"Another thing to notice are the types of the inputComponent and todoComponents properties. The first property is of type TodoInputCmp. It's value can be either null if Angular haven't found such child or reference to the instance of the component's controller (in this case, reference to an instance of the TodoInputCmp class). On the other hand, since we have multiple TodoCmp instances which can be dynamically added and removed from the view, the type of the todoComponents property is QueryList<TodoCmp>. We can think of the QueryList as an observable collection, which can throw events once items are added or removed from it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000173","sortNo":39,"contentFormatId":"1","contentTxt":"Since Angular's DOM compiler will process the todo-app component before its children, during the instantiation of the todo-app component the inputComponent and todosComponen properties will not be initialized. Their values are going to be set in the ngAfterViewInit life-cycle hook.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000174","sortNo":40,"contentFormatId":"1","contentTxt":"Accessing Content Children","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000175","sortNo":41,"contentFormatId":"1","contentTxt":"Almost the same rules are valid for the element's content children, however, there are some slight differences. In order to illustrate them better, lets take a look at the root component which uses the TodoAppCmp:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000176","sortNo":42,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000177","sortNo":43,"contentFormatId":"1","contentTxt":"In the snippet above we define two more components Footer and AppCmp. Footer visualizes all of the content passed between the opening and closing tag of its host element (<footer>content to be projected</footer>). On the other hand, AppCmp uses TodoAppCmp and passes Footer between its opening and closing tags. So given our terminology from above, Footer is a content child. We can access it in the following way:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000178","sortNo":44,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000179","sortNo":45,"contentFormatId":"1","contentTxt":"As we can see from above the only two differences between accessing view children and content children are the decorators and the life-cycle hooks. For grabbing all the content children we should use @ContentChildren (or @ContentChild if there's only one child), and the children will be set on ngAfterContentInit.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000180","sortNo":46,"contentFormatId":"1","contentTxt":"viewProviders vs providers","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000181","sortNo":47,"contentFormatId":"1","contentTxt":"Alright! We're almost done with our journey! As final step lets see what the difference between providers and viewProviders is (if you're not familiar with the dependency injection mechanism of Angular 2, you can take a look at my book).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000182","sortNo":48,"contentFormatId":"1","contentTxt":"Lets peek at the declaration of the TodoAppCmp:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000183","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000184","sortNo":50,"contentFormatId":"1","contentTxt":"Inside of the @Component decorator we set the viewProviders property to an array with a single element - the TodoList service. The TodoList service holds all the todo items which are entered in the application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000185","sortNo":51,"contentFormatId":"1","contentTxt":"We inject the TodoList service in the TodoAppCmp's constructor, but we can also inject it in any other directive's (or component) constructor, which is used in the TodoAppCmp's view. This means that TodoList is accessible from: 1.TodoList 2. TodoCmp 3. TodoInputCmp","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000186","sortNo":52,"contentFormatId":"1","contentTxt":"However, if we try to inject this service in Footer component's constructor we are going to get the following runtime error:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000187","sortNo":53,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000188","sortNo":54,"contentFormatId":"1","contentTxt":"This means that providers declared in given component with viewProviders are accessible by the component itself and all of its view successors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000189","sortNo":55,"contentFormatId":"1","contentTxt":"In case we want to make the service available to Footer as well we need to change the declaration of the component's providers from viewProviders to providers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000190","sortNo":56,"contentFormatId":"1","contentTxt":"When to use viewProviders?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000191","sortNo":57,"contentFormatId":"1","contentTxt":"Why would I use viewProviders, if such providers are not accessible by the content children of the component? Suppose you're developing a third-part library, which internally uses some services. These services are part of the private API of the library and you don't want to make them accessible to the users. If such private dependencies are registered with providers and the user passes content children to any of the components exported by the public API of your library, she will get access to them. However, if you use viewProviders, the providers will not be accessible from the outside.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000192","sortNo":58,"contentFormatId":"1","contentTxt":"Summary","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000193","sortNo":59,"contentFormatId":"1","contentTxt":"In this article we took a brief look at how we can compose components and directives. We also explained what the difference between content children and view children is, as well as, how we can access these two different kinds of children.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000194","sortNo":60,"contentFormatId":"1","contentTxt":"As final step we explained the semantics between the viewProviders and providers properties of the @Component decorator. If you have further interest in the topic I recommend you the book I'm working on \"Switching to Angular 2\", which is already available in alpha!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000195","sortNo":61,"contentFormatId":"1","contentTxt":"sourcecode","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201602060000000196","sortNo":62,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/mgechev/viewchildren-contentchildren-demo\">https://github.com/mgechev/viewchildren-contentchildren-demo</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201603300000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Writing styles for large applications can be a really challenging task as styles get easily mixed up and confusing. The major issue is usually encountered when trying to structure your styles and give proper naming of individual styles.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000002","sortNo":2,"contentFormatId":"1","contentTxt":"With time, patterns were introduced to enhance style organization and most of these patterns are implemented when we make use of pre-processors like Sass and Less. The significant thing about these patterns is that they suggest organizing our styles and templates in the form of COMPONENTS.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000003","sortNo":3,"contentFormatId":"1","contentTxt":"Angular 2 is component based which means that every UI functionality is built as a component. Therefore, as component based styling is a recommended pattern, Angular 2 is just about to make writing styles a rather enjoyable experience. We will discuss different styling techniques and how to use them, but before that, we need to understand the concept of Shadow DOM and View Encapsulation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Shadow DOM and View Encapsulation","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000005","sortNo":5,"contentFormatId":"1","contentTxt":"Shadow DOM is included in the Web Components standard by W3C. Shadow DOM basically allows group of DOM implementation to be hidden inside a single element (which is the basic idea of components) and encapsulate styles to the element. This means that encapsulated styles will only be available for that group of DOM elements and nothing more.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000006","sortNo":6,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000007","sortNo":7,"contentFormatId":"1","contentTxt":"ABSTRACTION WITH SHADOW DOM","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000008","sortNo":8,"contentFormatId":"1","contentTxt":"Remember that the idea of web components and shadow DOM is relatively new and not all browsers can handle the concept. This is where one of the major advantages of Angular 2 comes in as it allows us to choose whether to implement Shadow DOM, just emulate it (default) or not use it at all. This technique of handling Shadow DOM in Angular 2 is know as View Encapsulation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000009","sortNo":9,"contentFormatId":"1","contentTxt":"The 3 states of view encapsulation are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000010","sortNo":10,"contentFormatId":"1","contentTxt":"1. None: All elements are spit out - no Shadow DOM at all.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000011","sortNo":11,"contentFormatId":"1","contentTxt":"2. Emulated: This actually tries to emulate Shadow DOM to give us the feel that we are scoping our styles. This is not a real Shadow DOM but a strategy to make all browsers smile at our code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000012","sortNo":12,"contentFormatId":"1","contentTxt":"3. Native: This is the real deal as shadow DOM is completely enabled. Older browsers can go to hell.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000013","sortNo":13,"contentFormatId":"1","contentTxt":"Setting encapsulation is quite simple and is done right inside the @component decorator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000014","sortNo":14,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000015","sortNo":15,"contentFormatId":"1","contentTxt":"Styling Techniques","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000016","sortNo":16,"contentFormatId":"1","contentTxt":"Now that we have taken some time to put Shadow DOM and View Encapsulation straight, we can go ahead to understand the different techniques of styling an Angular component. Cards are common components that we are familiar with, so permit me to use it for the illustrations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000017","sortNo":17,"contentFormatId":"1","contentTxt":"COMPONENT INLINE STYLES","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000018","sortNo":18,"contentFormatId":"1","contentTxt":"This technique is the most obvious styling technique in Angular 2. This is because it is recommended, makes sense with the concept of components in mind and found everywhere in the Angular 2 documentation. It is implemented in the @Component decorator of our component class like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000019","sortNo":19,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000020","sortNo":20,"contentFormatId":"1","contentTxt":"The expected behavior in various view encapsulation techniques are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000021","sortNo":21,"contentFormatId":"1","contentTxt":"1. None: The style is wrapped in a style tag and pushed to the head","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000022","sortNo":22,"contentFormatId":"1","contentTxt":"2. Emulated: The style is wrapped in a style tag, pushed to head and uniquely identified so it can be matched with its component's template. With that, the styles will be used for only the template in the same component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000023","sortNo":23,"contentFormatId":"1","contentTxt":"3. Native: Behaves as expected of web components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000024","sortNo":24,"contentFormatId":"1","contentTxt":"EXTERNAL STYLESHEETS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Just like our everyday method of including styles from external styles which have an extension of .css, we could also import external styles in an Angular 2 component. It is as simple as importing templates with the templateUrl property in @Component decorator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000026","sortNo":26,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000027","sortNo":27,"contentFormatId":"1","contentTxt":"he expected behavior in various view encapsulation techniques are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000028","sortNo":28,"contentFormatId":"1","contentTxt":"1. None: The style is wrapped in a style tag and pushed to the head. It is appended right after the component inline style.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000029","sortNo":29,"contentFormatId":"1","contentTxt":"2. Emulated: The style is wrapped in style tag, pushed to head and uniquely identified so it can be matched with its component's template just like component inline style. As you can see, you must have guessed wrong if you expected the style to be imported with link","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000030","sortNo":30,"contentFormatId":"1","contentTxt":"3. Native: Behaves as expected of web components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000031","sortNo":31,"contentFormatId":"1","contentTxt":"TEMPLATE INLINE STYLE","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000032","sortNo":32,"contentFormatId":"1","contentTxt":"This is achievable with two methods:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000033","sortNo":33,"contentFormatId":"1","contentTxt":"1. The styles can be wrapped in a style tag and placed before the templates:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000034","sortNo":34,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000035","sortNo":35,"contentFormatId":"1","contentTxt":"2. The style can be written as normal inline styles in the template tags:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000036","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000037","sortNo":37,"contentFormatId":"1","contentTxt":"The expected behavior in various view encapsulation techniques are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000038","sortNo":38,"contentFormatId":"1","contentTxt":"1. None: For method 1, the style is wrapped in a style tag and pushed to the head. It is appended right after the component inline and external styles. For method 2, the style just remains in the tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000039","sortNo":39,"contentFormatId":"1","contentTxt":"2. Emulated: For method 1, the style is wrapped in style tag, pushed to head and uniquely identified so it can be matched with its component's template just like component inline style. For method 2, the style still remains in the tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000040","sortNo":40,"contentFormatId":"1","contentTxt":"3. Native: Behaves as expected of web components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000047","sortNo":41,"contentFormatId":"1","contentTxt":"Style Priority","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000048","sortNo":42,"contentFormatId":"1","contentTxt":"This is the point where we need to pay attention to as it can be quite tricky. A demo is provided with Plunker so we can play with later. If you have been following the article carefully, you will realize that component styles, if any, are always appended to the head first.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000049","sortNo":43,"contentFormatId":"1","contentTxt":"Where it then becomes confusing is that the first method of template inline styles are appended before the external styles. This makes external styles to take precedence because in CSS the last is the greatest.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000050","sortNo":44,"contentFormatId":"1","contentTxt":"Conclusion","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000051","sortNo":45,"contentFormatId":"1","contentTxt":"Whatever method you choose is accepted and that is the good thing about components and Angular 2. You don't have to listen to the preaching of not using internal styles or inline styles as they are within components and will be scoped. On the other hand, we are now able to organize our code better in a modular pattern.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603300000000052","sortNo":46,"contentFormatId":"1","contentTxt":"Angular 2 is awesome, right?","contentBinary":"","contentPoster":"","contentUrl":null}]
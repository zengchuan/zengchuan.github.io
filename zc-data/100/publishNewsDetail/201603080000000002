[{"id":"201603080000000010","sortNo":1,"contentFormatId":"1","contentTxt":"Shadow DOM has long been a talking point on the web, and the Polymer project pushes the proof of concept quite nicely, however, adoption of “raw” Web Components (Shadow DOM is part of the spec) is low. Instead, frameworks have provided “better” ways to achieve results and develop applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000011","sortNo":2,"contentFormatId":"1","contentTxt":"Angular 2 isn’t ignorant to Web Components at all, and provides us the powerful ability to use native Shadow DOM when we choose. We also have the choice to emulate Shadow DOM through Angular 2, achieving somewhat encapsulated Components and styling. If you need an overview on Web Components and Shadow DOM, I’d check out my article on it!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000012","sortNo":3,"contentFormatId":"1","contentTxt":"Problem we’re solving","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000013","sortNo":4,"contentFormatId":"1","contentTxt":"The problem in the way we create web applications lies in the “global-like” architecture that HTML, CSS and JavaScript gives us, for instance an .active {} class will be painted to all DOM elements containing the class name active, such as <div class=\"active\"></div>. The same applies to JavaScript, the code we write is lexically scoped, and usually we create forms of global Objects (such as window.angular in Angular 1.x to hook into Angular from any JavaScript scope).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000014","sortNo":5,"contentFormatId":"1","contentTxt":"When it comes to Shadow DOM, the tables are turned, as Shadow DOM creates DOM inside DOM, combining multiple DOM trees into a single hierarchy. These chunks of isolated DOM act as a “shield” around all these global entities such as CSS and JavaScript logic and are locally scoped to one another.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000015","sortNo":6,"contentFormatId":"1","contentTxt":"Let’s see how Shadow DOM is applied in Angular 2 using the styles property to add styles to Components, and the encapsulation property to manage how we want Angular 2 to contain our Components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000016","sortNo":7,"contentFormatId":"1","contentTxt":"Style property","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000017","sortNo":8,"contentFormatId":"1","contentTxt":"Let’s setup a basic Component and add some styles to understand what happens when Angular 2 bootstraps our application:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000018","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000019","sortNo":10,"contentFormatId":"1","contentTxt":"This gives us a Component with a class name .test, which you can see the styles above are giving it 10px of padding.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000089","sortNo":11,"contentFormatId":"1","contentTxt":"Global CSS","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000090","sortNo":12,"contentFormatId":"1","contentTxt":"Next, let’s create some global HTML and CSS and add it to the Plunker. This will use the same .test class as the Component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000091","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000092","sortNo":14,"contentFormatId":"1","contentTxt":"As you can see from adding this, our AppComponent with the <input> inside also inherits the green global styling. This is because of how Angular 2’s default ViewEncapsulation mode.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000093","sortNo":15,"contentFormatId":"1","contentTxt":"Let’s dive into each ViewEncapsulation mode to see what each of them gives us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000094","sortNo":16,"contentFormatId":"1","contentTxt":"ViewEncapsulation.Emulated","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000095","sortNo":17,"contentFormatId":"1","contentTxt":"Using the Emulated property gives us emulated Shadow DOM/encapsulation which is the default behaviour for Angular 2 Components. Even though it’s a default, we’ll add it to a live example anyway to see what happens. Let’s import ViewEncapsulation from the Angular 2 core and set the encapsulation property:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000096","sortNo":18,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000097","sortNo":19,"contentFormatId":"1","contentTxt":"Adding this line doesn’t change the behaviour if we omit it, as it’s the default mode, but let’s look what this mode gives us.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000098","sortNo":20,"contentFormatId":"1","contentTxt":"Looking at the compiled DOM output, we get this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000099","sortNo":21,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000100","sortNo":22,"contentFormatId":"1","contentTxt":"What are these weird _nghost and _ngcontent attributes? Well, in Web Components, the “host” element is the root (declared in the HTML) element, and the rest inside is purely the content of that contained element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000101","sortNo":23,"contentFormatId":"1","contentTxt":"We also get this as the painted CSS:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000102","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000103","sortNo":25,"contentFormatId":"1","contentTxt":"Woah! What’s happening here, we have two classes called .test, however one has this weird [_ngcontent-cmy-1] suffix. Well my friends, this for one is an attribute selector in CSS, and secondly this is emulating encapsulated styles, as Angular is generating unique content keys per Component that get mapped across to the CSS properties. This is powerful!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000104","sortNo":26,"contentFormatId":"1","contentTxt":"What does this mean?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000105","sortNo":27,"contentFormatId":"1","contentTxt":"It means that CSS we write globally will inherit, however styles defined using the same class inside the Component will be locally scoped to that Component only.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000106","sortNo":28,"contentFormatId":"1","contentTxt":"ViewEncapsulation.Native","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000107","sortNo":29,"contentFormatId":"1","contentTxt":"This is where native technology takes over, using the Native property will use Shadow DOM! Let’s switch out the property name from the previous example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000108","sortNo":30,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000109","sortNo":31,"contentFormatId":"1","contentTxt":"Let’s see what this renders out (Please check that you’re using a Browser that supports Shadow DOM [Chrome/FireFox]).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000110","sortNo":32,"contentFormatId":"1","contentTxt":"The compiled DOM output:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000111","sortNo":33,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000112","sortNo":34,"contentFormatId":"1","contentTxt":"Note that everything inside ？ #shadow-root is Shadow DOM, it’s fully scoped to itself and a separate DOM tree altogether. This is exactly why styles aren’t inheriting!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000113","sortNo":35,"contentFormatId":"1","contentTxt":"What does this mean?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000114","sortNo":36,"contentFormatId":"1","contentTxt":"It means that CSS we write globally will not inherit, however styles defined using the same class inside the Component will be locally scoped to that Component only, which is exactly what’s expected with Shadow DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000115","sortNo":37,"contentFormatId":"1","contentTxt":"ViewEncapsulation.None","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000116","sortNo":38,"contentFormatId":"1","contentTxt":"We can tell Angular that we don’t want any encapsulation, not Emulated or Native by using the None property:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000117","sortNo":39,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000118","sortNo":40,"contentFormatId":"1","contentTxt":"I’ve made a change above to the .test class, adding background: red; as a property and value, which as you can see allows the styles to have zero encapsulation, allowing them to flow out of the Component and into the “global” CSS scope.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000119","sortNo":41,"contentFormatId":"1","contentTxt":"What does this mean?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000120","sortNo":42,"contentFormatId":"1","contentTxt":"It means that CSS we write globally will inherit, however styles defined using the same class inside the Component will override existing styling.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000121","sortNo":43,"contentFormatId":"1","contentTxt":"Web Component footsteps","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000122","sortNo":44,"contentFormatId":"1","contentTxt":"Angular 2 moves even closer to the Web Components spec through the use of the :host {} selector, both with Native or Emulated styles. A quick example of using the :host {} selector:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000123","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000124","sortNo":46,"contentFormatId":"1","contentTxt":"Notice how the red background now spans the full element using the :host selector. Now the important thing to remember is the :host selector targets the declared element, not any of the Component’s children (such as the template).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000125","sortNo":47,"contentFormatId":"1","contentTxt":"What does this mean?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603080000000126","sortNo":48,"contentFormatId":"1","contentTxt":"It means we can use the :host selector to style the declared element, in this case the :host is the same element as Angular 2 annotated above in the ViewEncapsulation.Emulated overview as <my-app _nghost-cmy-1=\"\">. Note the _nghost-* attribute, in Native mode this attribute is removed and we use native Shadow DOM, in which case just <my-app> refers to the host element and therefore is targeted by the :host {} selector.","contentBinary":"","contentPoster":"","contentUrl":null}]
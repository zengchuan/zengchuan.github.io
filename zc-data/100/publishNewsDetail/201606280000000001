[{"id":"201606280000000001","sortNo":1,"contentFormatId":"1","contentTxt":"Progressive Web Applications help us build native-like web apps, thanks to amazing tools such as Service Workers, IndexDB, App Shell etc. Once the browser downloads all the static assets required by our app, the active Service Worker can cache all of them locally.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000002","sortNo":2,"contentFormatId":"1","contentTxt":"This way the user may experience slowdown during the initial page load, but once the page has been successfully loaded for first time, each next time the load will be instant!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000003","sortNo":3,"contentFormatId":"1","contentTxt":"In order to help developers take advantage of the technologies behind the PWA as easy as possible, the Angular team is working on the Angular mobile-toolkit. However, a big concern for developing high-performance Angular 2 is the framework size itself. For instance, a simple non-optimized “Hello world!” Angular 2 application, bundled with browserify is 1.6MB! This is suicidal when your users are supposed to download it via an unreliable 3G connection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000005","sortNo":5,"contentFormatId":"1","contentTxt":"This is main reason Angular is (was) criticized for. During the keynote of ng-conf, Brad Green (manager of the Angular team) mentioned that the core team managed to drop the size of the “Hello world!” app to less than 50K!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000006","sortNo":6,"contentFormatId":"1","contentTxt":"In this blog post we’ll explain all the steps we need to go through in order to achieve such results!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000007","sortNo":7,"contentFormatId":"1","contentTxt":"<strong>Sample Application</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000008","sortNo":8,"contentFormatId":"1","contentTxt":"In order to get a better understanding of the optimizations explained below, lets first describe the sample application that we’re going to apply them on.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Our app is going to consist the following two files:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000010","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000011","sortNo":11,"contentFormatId":"1","contentTxt":"..and","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000012","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000013","sortNo":13,"contentFormatId":"1","contentTxt":"In app.component.ts we have a single component with a template which is going to render the text \"Hello world!\". main.ts is responsible for bootstrapping the application, using the bootstrap method exported by the @angular/platform-browser-dynamic package.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000014","sortNo":14,"contentFormatId":"1","contentTxt":"Our index.html page looks like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000015","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000016","sortNo":16,"contentFormatId":"1","contentTxt":"And here’s the directory layout:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000017","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000018","sortNo":18,"contentFormatId":"1","contentTxt":"dist is where the output is going to live (i.e. application bundles), we’re using typings and npm in order to manage, respectively, the ambient TypeScript type definitions and the dependencies of our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000019","sortNo":19,"contentFormatId":"1","contentTxt":"<strong>Step 1 - Minification and Compression</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000020","sortNo":20,"contentFormatId":"1","contentTxt":"The two most obvious optimizations that we can apply are minification and compression. You can find the example explained in this section in my GitHub profile. I’d recommend you to clone the repository and run:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000021","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000022","sortNo":22,"contentFormatId":"1","contentTxt":"Now we can explore the build process by taking a look at package.json:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000023","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000024","sortNo":24,"contentFormatId":"1","contentTxt":"We have a simple clean script which removes the dist directory. In order to install all the required typings once the npm install command completes its execution, we have typings install as postinstall script.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000025","sortNo":25,"contentFormatId":"1","contentTxt":"Our build script first cleans the dist directory and after that compiles our application by using the TypeScript compiler. This will produce two files - main.js and app.component.js, in the dist directory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000026","sortNo":26,"contentFormatId":"1","contentTxt":"By using SystemJS we can already run them in the browser, but since we want to reduce the number of HTTP requests made by the browser in the process of loading the app, we can create a single bundle. This is what we do in build_prod:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000027","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000028","sortNo":28,"contentFormatId":"1","contentTxt":"In the script above, first we use the TypeScript compiler. Once the app has been compiled, all we need to do is to create a “standalone” bundle with entry point the dist/main.js file, and output the bundles content to bundle.js within the dist directory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000029","sortNo":29,"contentFormatId":"1","contentTxt":"In order to try the app you can use:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000030","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000031","sortNo":31,"contentFormatId":"1","contentTxt":"<strong>Size Analysis</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000032","sortNo":32,"contentFormatId":"1","contentTxt":"Now lets see what the bundle size is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000033","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000034","sortNo":34,"contentFormatId":"1","contentTxt":"Wow…so we reached the disastrous point we described above! However, the bundle contains a bunch of useless content such as:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000035","sortNo":35,"contentFormatId":"1","contentTxt":"1. Unused functions, variables…","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000036","sortNo":36,"contentFormatId":"1","contentTxt":"2. A lot of whitespace.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000037","sortNo":37,"contentFormatId":"1","contentTxt":"3. Comments.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000038","sortNo":38,"contentFormatId":"1","contentTxt":"4. Non-mangled variables.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000039","sortNo":39,"contentFormatId":"1","contentTxt":"In order to reduce the size of the bundle we can now use the minify script:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000040","sortNo":40,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000041","sortNo":41,"contentFormatId":"1","contentTxt":"It takes the bundle.js file, and optimizes it. The output is now produced in dist/bundle.min.js, and its size is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000042","sortNo":42,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000043","sortNo":43,"contentFormatId":"1","contentTxt":"So, we reduced the size of the bundle to 702K only by applying a simple minification!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000044","sortNo":44,"contentFormatId":"1","contentTxt":"<strong>Compression of the Application</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Most HTTP servers support compression of the content, with gzip. The requested by the browser resources are compressed by the web server and sent through the network. Responsibility of the client is to decompress them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000046","sortNo":46,"contentFormatId":"1","contentTxt":"Lets find out what the size of the compressed bundle is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000047","sortNo":47,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000048","sortNo":48,"contentFormatId":"1","contentTxt":"We reduced the size of the bundle with another ~78% only by applying compression! But we can do even better!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000049","sortNo":49,"contentFormatId":"1","contentTxt":"<strong>Step 2 - Tree-Shaking</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000050","sortNo":50,"contentFormatId":"1","contentTxt":"In this section we’ll use very important property of the ES2015 modules - they are tree-shakable!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000051","sortNo":51,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000052","sortNo":52,"contentFormatId":"1","contentTxt":"What does tree-shaking means:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000053","sortNo":53,"contentFormatId":"1","contentTxt":"Tree-shaking is excluding unused exports from bundles.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000054","sortNo":54,"contentFormatId":"1","contentTxt":"Because the ES2015 modules are static, by performing a static code analysis over them we can decide which exports are used and which are not used in our application. In contrast, CommonJS modules are not always tree-shakable because of the dynamic nature of their format. For instance:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000055","sortNo":55,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000056","sortNo":56,"contentFormatId":"1","contentTxt":"It is impossible to guess which algorithm will be chosen by the user by performing a static code analysis.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000057","sortNo":57,"contentFormatId":"1","contentTxt":"With ES2015 we can do something like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000058","sortNo":58,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000059","sortNo":59,"contentFormatId":"1","contentTxt":"In this way, we will be able to perform tree-shaking and remove the ./graphs module from the final bundle because since we’re not using Graphs anywhere. On the other hand, we need to import all sorting algorithms because we have a level of non-determinism - we’re not sure what the input of the user is going to be so we can’t get rid of anything from Algorithms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000060","sortNo":60,"contentFormatId":"1","contentTxt":"<strong>Applying Tree-Shaking with Rollup</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000061","sortNo":61,"contentFormatId":"1","contentTxt":"Rollup.js is a module bundler which is optimized for ES2015 modules. It is a great, pluggable tool which allows us to perform tree-shaking over ES2015 and CommonJS (in most cases) by using a plugin.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000062","sortNo":62,"contentFormatId":"1","contentTxt":"We’re going to integrate Rollup in the example above, trying to achieve even smaller bundle size! The example from this section is available here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000063","sortNo":63,"contentFormatId":"1","contentTxt":"Now, lets take a look at the scripts section in our package.json in order to explore the build process:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000064","sortNo":64,"contentFormatId":"1","contentTxt":"We have the same clean, typings, serve, postinstall, minify and build scripts like above. The new things here are rollup, es5, build_prod.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000065","sortNo":65,"contentFormatId":"1","contentTxt":"rollup is responsible for bundling our app and perform tree-shaking in the process.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000066","sortNo":66,"contentFormatId":"1","contentTxt":"TypeScript supports ES2015 modules, which means that we can apply tree-shaking directly over our non-transpiled app. This is further simplified by the TypeScript plugin for Rollup which allows us to perform the transpilation as the part of the bundling. This would work great if the dependencies of our application were distributed as TypeScript as well. However, Angular 2 is distributed as ES5 and ES2015 (within the esm directory), and RxJS is distributed as ES5 and ES2015 (in the rxjs-es package).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000067","sortNo":67,"contentFormatId":"1","contentTxt":"Since we can’t apply tree-shaking directly over the original TypeScript files of our app, we’ll first need to transpile it to TypeScript, after that create an ES2015 bundle by using rollup, and in the end transpile it to ES5.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000068","sortNo":68,"contentFormatId":"1","contentTxt":"Because of these changes in the flow of the build process, there’s a very important difference between the tsconfig.json presented in the example above, and the one used in this section:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000069","sortNo":69,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000070","sortNo":70,"contentFormatId":"1","contentTxt":"Our target version here is es2015 in order to transpile the TypeScript application to an ES2015 one, with ES2015 modules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000071","sortNo":71,"contentFormatId":"1","contentTxt":"Now we can explore the rollup script:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000072","sortNo":72,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000073","sortNo":73,"contentFormatId":"1","contentTxt":"Above we tell rollup to bundle the modules as IIFE (Immediately-Invoked Function Expression), use the configuration file provided in the root of the project (rollup.config.js) and output the bundle as bundle.es2015.js in dist.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000074","sortNo":74,"contentFormatId":"1","contentTxt":"Now lets take a look at the rollup.config.js file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000075","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000076","sortNo":76,"contentFormatId":"1","contentTxt":"Great thing about this configuration file is that it is pure JavaScript! We export the configuration object, and declare inside of it the entry point of the application, the module name (required if we use IIFE bundling), we also declare that we want to have sourceMaps, and the set of plugins that we want to use.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000077","sortNo":77,"contentFormatId":"1","contentTxt":"We use the nodeResovle plugin for rollup in order to hint the bundler that we want to use node-like module resolution. Once the bundler finds import like @angular/core, for instance, it’ll go to node_modules/@angular/core and read the package.json file there. Once it finds property called main:jsnext, the bundler will use the file set as its value. If such property is not found, the bundler will use the file pointed by main.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000078","sortNo":78,"contentFormatId":"1","contentTxt":"A problem comes that RxJS is distributed as ES5 by default. In order to deal with this problem, for bundling the required RxJS operations we’ll use the package rxjs-es, which is already available in package.json. After installing this module, we need to make sure that the module bundler will use rxjs-es instead of rxjs from node_modules. This is exactly what the purpose of the rollupNG2 plugin is - to translate all the rxjs/* imports to rxjs-es/* ones.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000079","sortNo":79,"contentFormatId":"1","contentTxt":"Alright, now if we run:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000080","sortNo":80,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000081","sortNo":81,"contentFormatId":"1","contentTxt":"We’ll get the bundle bundle.es2015.js. Now lets transpile this bundle to ES5.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000082","sortNo":82,"contentFormatId":"1","contentTxt":"This can be easily achieved by using the es5 script:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000083","sortNo":83,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000084","sortNo":84,"contentFormatId":"1","contentTxt":"We use the TypeScript compiler and output the ES5 bundle to dist/bundle.js (note that this script may throw an error for Duplicate identifier _subscribe, which is not problematic at this point).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000085","sortNo":85,"contentFormatId":"1","contentTxt":"In order to get our final optimized, bundle we need to invoke npm run minify. To verify that the application still works use:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000086","sortNo":86,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000087","sortNo":87,"contentFormatId":"1","contentTxt":"<strong>Size Analysis</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000088","sortNo":88,"contentFormatId":"1","contentTxt":"Lets find out what the size of our ES5 bundle is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000089","sortNo":89,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000090","sortNo":90,"contentFormatId":"1","contentTxt":"Great! This is 200K smaller than the previous section! Now lets see what the bundle size will be after minification:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000091","sortNo":91,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000092","sortNo":92,"contentFormatId":"1","contentTxt":"702K to 484K…not bad at all! After gzipping we get:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000093","sortNo":93,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000094","sortNo":94,"contentFormatId":"1","contentTxt":"About 25% reduction of the bundle size! But I’m sure we can do even better!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000095","sortNo":95,"contentFormatId":"1","contentTxt":"Credits: Igor Minar published similar experiments in the official Angular 2 repository. They can be found here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000096","sortNo":96,"contentFormatId":"1","contentTxt":"<strong>Using ngc</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000097","sortNo":97,"contentFormatId":"1","contentTxt":"As static code analysis enthusast, I’m following the progress around the Angular compiler (ngc).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000098","sortNo":98,"contentFormatId":"1","contentTxt":"The core idea of ngc is to process the templates of the components in our applications and generate VM friendly, tree-shakable code. This can happen either run-time or build-time, but since in run-time compilation the application is already loaded in the browser we can’t take advantage of tree-shaking. The project is located here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000099","sortNo":99,"contentFormatId":"1","contentTxt":"Although in the previous example we already applied decent tree-shaking we still can do better! Why? Well, having an HTML template rollup is not completely sure what parts of Angular we can get rid of from the final bundle since HTML is not something that rollup can analyze at all. That’s why we can:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000100","sortNo":100,"contentFormatId":"1","contentTxt":"1. Compile our application (including templates) to TypeScript with ngc.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000101","sortNo":101,"contentFormatId":"1","contentTxt":"2. Perform tree-shaking with rollup (this way we will get at least as small bundle as above).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000102","sortNo":102,"contentFormatId":"1","contentTxt":"3. Transpile the bundle to ES5.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000103","sortNo":103,"contentFormatId":"1","contentTxt":"4. Minify the bundle.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000104","sortNo":104,"contentFormatId":"1","contentTxt":"5. Gzip it!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000105","sortNo":105,"contentFormatId":"1","contentTxt":"Alright, lets begin! The code explained in the paragraphs below can be found here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000106","sortNo":106,"contentFormatId":"1","contentTxt":"Lets take a look at the scripts in package.json:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000107","sortNo":107,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000108","sortNo":108,"contentFormatId":"1","contentTxt":"build_prod just confirms the order into which the individual actions need to be performed. Lets take a look at the clean method, since it looks quite complex this time:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000109","sortNo":109,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000110","sortNo":110,"contentFormatId":"1","contentTxt":"What we do here is to remove the dist directory, all files which match app/*.ngfactory.ts and also everything except main-ngc.ts from the compiled directory. ngc produces *.ngfactory.ts files. Since they are artifacts from the build process we’d want to remove them before the next build. But why we remove everything except main-ngc.ts from the compiled directory? Lets take a look at the file’s content:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000111","sortNo":111,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000112","sortNo":112,"contentFormatId":"1","contentTxt":"This is what the process of bootstrapping a precompiled app at the moment of writing is. Notice that we bootstrap the app by using AppComponentNgFactory, and import it from app.component.ngfactory, i.e. a generated by ngc file. So, once we compile our app with ngc, we want to move everything in the compiled directory, and after that invoke the TypeScript compiler, in order to make it produce ES2015 code. That is why our tsconfig.json is slightly changed as well:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000113","sortNo":113,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000114","sortNo":114,"contentFormatId":"1","contentTxt":"We are using compiled/main-ngc.ts as entry file. Also notice that we have two tsconfig files: one for ngc and one for tsc.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000115","sortNo":115,"contentFormatId":"1","contentTxt":"Alright…now lets run npm run ngc. Once the scripts completes its execution, here’s the directory structure of the app:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000116","sortNo":116,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000117","sortNo":117,"contentFormatId":"1","contentTxt":"Now we can transpile the application to ES2015:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000118","sortNo":118,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000119","sortNo":119,"contentFormatId":"1","contentTxt":"Notice that the postinstall script is quite complex as well. This is due to this bug introduced in @angular/compiler-cli by RC.3","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000120","sortNo":120,"contentFormatId":"1","contentTxt":"At this point we already have the ES2015 version of our app located in dist. The only steps left are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000121","sortNo":121,"contentFormatId":"1","contentTxt":"1. Tree-shaking.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000122","sortNo":122,"contentFormatId":"1","contentTxt":"2. Transpilation from ES2015 to ES5.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000123","sortNo":123,"contentFormatId":"1","contentTxt":"3. Minification.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000124","sortNo":124,"contentFormatId":"1","contentTxt":"4. Gzipping.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000125","sortNo":125,"contentFormatId":"1","contentTxt":"This is process we’re already familiar with so lets invoke the individual scripts one by one without providing further explanation:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000126","sortNo":126,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000127","sortNo":127,"contentFormatId":"1","contentTxt":"In order to make sure that everything works you can use:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000128","sortNo":128,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000129","sortNo":129,"contentFormatId":"1","contentTxt":"<strong>Size Analysis</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000130","sortNo":130,"contentFormatId":"1","contentTxt":"Lets see how big is our precompiled, tree-shaked app!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000131","sortNo":131,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000132","sortNo":132,"contentFormatId":"1","contentTxt":"The application got more that twice smaller that it was without ngc!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000133","sortNo":133,"contentFormatId":"1","contentTxt":"If we gzip it, we’ll get the following results:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000134","sortNo":134,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000135","sortNo":135,"contentFormatId":"1","contentTxt":"The final result is 49K!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000136","sortNo":136,"contentFormatId":"1","contentTxt":"Credits: Rob Wormald who did experiments with ngc here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000137","sortNo":137,"contentFormatId":"1","contentTxt":"<strong>Conclusion</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000138","sortNo":138,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000139","sortNo":139,"contentFormatId":"1","contentTxt":"As we can see from the chart above, by applying a set of optimizations over our production bundle we can reduce the size of our application up to 33 times!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000140","sortNo":140,"contentFormatId":"1","contentTxt":"This is thanks to a couple of techniques:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000141","sortNo":141,"contentFormatId":"1","contentTxt":"1. Optimization by performing static-code analysis, more specifically tree-shaking.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000142","sortNo":142,"contentFormatId":"1","contentTxt":"2. Minification (including mangling).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000143","sortNo":143,"contentFormatId":"1","contentTxt":"3. Compression with gzip.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000144","sortNo":144,"contentFormatId":"1","contentTxt":"Definitely there’s some overhead at first, before being able to get all the things going on in this process. Luckily, in the end, all this is going to happen automatically with tools like angular-cli, and angular2-seed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000145","sortNo":145,"contentFormatId":"1","contentTxt":"As a matter of fact, we are already planning to add automated production build, which performs all the listed steps above in angular2-seed. This is definitely going to happen in near future, once we make sure that all tools explained above are mature enough.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201606280000000146","sortNo":146,"contentFormatId":"1","contentTxt":"By then, we can easily reduce the bundle size to ~150K only by applying minification and compression!","contentBinary":"","contentPoster":"","contentUrl":null}]
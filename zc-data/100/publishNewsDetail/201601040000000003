[{"id":"201601040000000150","sortNo":1,"contentFormatId":"1","contentTxt":"Before we take a look at actual code, let’s first understand the concept behind the new DI in Angular 2. The following graphic illustrates required components in the new DI system:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000151","sortNo":2,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000152","sortNo":3,"contentFormatId":"1","contentTxt":"The DI in Angular 2 basically consists of three things:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000153","sortNo":4,"contentFormatId":"1","contentTxt":"1. Injector - The injector object that exposes APIs to us to create instances of dependencies.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000154","sortNo":5,"contentFormatId":"1","contentTxt":"2. Provider - A provider is like a recipe that tells the injector how to create an instance of a dependency. A provider takes a token and maps that to a factory function that creates an object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000155","sortNo":6,"contentFormatId":"1","contentTxt":"3. Dependency - A dependency is the type of which an object should be created.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000267","sortNo":7,"contentFormatId":"1","contentTxt":"Okay, now that we have an idea of what the concept looks like, lets see how this is translated to code. We stick with our Car class and it’s dependencies. Here’s how we can use Angular 2’s DI to get an instance of Car:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000268","sortNo":8,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000269","sortNo":9,"contentFormatId":"1","contentTxt":"We import Injector from Angular 2 which exposes some static APIs to create injectors. resolveAndCreate() is basically a factory function that creates an injector and takes a list of providers. We’ll explore how those classes are supposed to be providers in a second, but for now we focus on injector.get(). See how we ask for an instance of Car in the last line? How does our injector know, which dependencies need to be created in order to instantiate a car? A look at our Car class will explain…","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000270","sortNo":10,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000271","sortNo":11,"contentFormatId":"1","contentTxt":"We import something called Inject from the framework and apply it as decorator to our constructor parameters. If you don’t know what decorators are, you might want to read our articles on the difference between decorators and annotations and how to write Angular 2 code in ES5.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000272","sortNo":12,"contentFormatId":"1","contentTxt":"The Inject decorator attaches meta data to our Car class, that is then consumed by the DI system afterwards. So basically what we’re doing here, is that we tell the DI that the first constructor parameter should be an instance of type Engine, the second of type Tires and the third of type Doors. We can rewrite this code to TypeScript, which feels a bit more natural:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000273","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000274","sortNo":14,"contentFormatId":"1","contentTxt":"Nice, our class declares it’s own dependencies and the DI can read that information to instantiate whatever is needed to create an object of Car. But how does the injector know how to create such an object? This is where the providers come into play. Remember the resolveAndCreate() method in which we passed a list of classes?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000275","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000276","sortNo":16,"contentFormatId":"1","contentTxt":"Again, you might wonder how this list of classes is supposed to be a list of providers. Well, it turns out that this is actually a shorthand syntax. If we translate this to the longer, more verbose, syntax, things might become a bit more clear.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000277","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000278","sortNo":18,"contentFormatId":"1","contentTxt":"We have a function provide() that maps a token to a configuration object. The token can either be a type or a string. If you read those providers now, it’s much easier to understand what’s happening. We provide an instance of type Car via the class Car, type Engine via the class Engine and so on and so forth. This is the recipe mechanism we were talking about earlier. So with the providers we not only let the injector know which dependencies are used across the application, we also configure how objects of these dependencies are created.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000279","sortNo":19,"contentFormatId":"1","contentTxt":"Now the next question comes up: When do we want to use the longer instead of the shorthand syntax? There’s no reason to write provide(Foo, {useClass: Foo}) if we could just stick with Foo, right? Yes, that’s correct. That’s why we started with the shorthand syntax in the first place. However, the longer syntax enables us to do something very very powerful. Take a look at the next code snippet.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000280","sortNo":20,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000281","sortNo":21,"contentFormatId":"1","contentTxt":"Right. We can map a token to pretty much what ever we want. Here we’re mapping the token Engine to the class OtherEngine. Which means, when we now ask for an object of type Engine, we get an instance of class OtherEngine.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000282","sortNo":22,"contentFormatId":"1","contentTxt":"This is super powerful, because this allows us not only to prevent name collisions, we can also create a type as interface and bind it to a concrete implementation. In addition to that, we can swap out the actual dependency for a token in a single place without touching any other code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000283","sortNo":23,"contentFormatId":"1","contentTxt":"Angular 2’s DI introduces a couple of other provider recipes which we explore in the next section.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000284","sortNo":24,"contentFormatId":"1","contentTxt":"Other provider configurations","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000285","sortNo":25,"contentFormatId":"1","contentTxt":"Sometimes, we don’t want to get an instance of a class, but rather just a single value of something or a factory function where more configuration is needed. That’s why the provider mechanism of Angular 2’s DI comes with more than just one recipe. Lets take a quick look at them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000286","sortNo":26,"contentFormatId":"1","contentTxt":"Providing values","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000287","sortNo":27,"contentFormatId":"1","contentTxt":"We can provide a simple value using {useValue: value}","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000288","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000289","sortNo":29,"contentFormatId":"1","contentTxt":"This comes in handy when we want to provide simple configuration values.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000290","sortNo":30,"contentFormatId":"1","contentTxt":"Providing aliases","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000291","sortNo":31,"contentFormatId":"1","contentTxt":"We can map an alias token to another token like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000292","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000293","sortNo":33,"contentFormatId":"1","contentTxt":"Providing factories","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000294","sortNo":34,"contentFormatId":"1","contentTxt":"Yes, our beloved factories.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000295","sortNo":35,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000296","sortNo":36,"contentFormatId":"1","contentTxt":"Of course, a factory might have its own dependencies. Passing dependencies to factories is as easy as adding a list of tokens to the factory:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000297","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000298","sortNo":38,"contentFormatId":"1","contentTxt":"Optional Dependencies","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000299","sortNo":39,"contentFormatId":"1","contentTxt":"The @Optional decorator lets us declare dependencies as optional. This comes in handy if, for example, our application expects a third-party library, and in case it’s not available, it can fallback.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000300","sortNo":40,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000301","sortNo":41,"contentFormatId":"1","contentTxt":"As you can see, Angular 2’s DI solves pretty much all issues we have with Angular 1’s DI. But there’s still one thing we haven’t talked about yet. Does the new DI still create singletons? The answer is yes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000302","sortNo":42,"contentFormatId":"1","contentTxt":"Transient Dependencies and Child Injectors","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000303","sortNo":43,"contentFormatId":"1","contentTxt":"If we need a transient dependency, something that we want a new instance every time we ask for a dependency, we have two options:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000304","sortNo":44,"contentFormatId":"1","contentTxt":"Factories can return instances of classes. Those won’t be singletons. Note that in the following code we’re creating a factory.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000305","sortNo":45,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000306","sortNo":46,"contentFormatId":"1","contentTxt":"We can create a child injector using Injector.resolveAndCreateChild(). A child injector introduces its own bindings and an instance of an object will be different from the parent injector’s instance.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000307","sortNo":47,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000308","sortNo":48,"contentFormatId":"1","contentTxt":"Child injectors are even more interesting. It turns out that a child injector will look up a token binding on it’s parent injector if no binding for the given token is registered on the child injector. The following graphic visualises what happens:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000309","sortNo":49,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000310","sortNo":50,"contentFormatId":"1","contentTxt":"The graphic shows three injectors where two of them are child injectors. Each injector gets its own configuration of providers. Now, if we ask the second child injector for an instance of type Car, the car object will be created by that child injector. However, the engine will be created by the first child injector and the tires and doors will be created by the outer most parent injector. It kind of works like a prototype chain.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000311","sortNo":51,"contentFormatId":"1","contentTxt":"We can even configure the visibility of dependencies, and also until where a child injector should look things up. However, this will be covered in another article.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000312","sortNo":52,"contentFormatId":"1","contentTxt":"How is it used in Angular 2 then?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000313","sortNo":53,"contentFormatId":"1","contentTxt":"Now that we’ve learned how the DI in Angular 2 works, you might wonder how it is used in the framework itself. Do we have to create injectors manually when we build Angular 2 components? Luckily, the Angular team spent a lot of energy and time to find a nice API that hides all the injector machinery when building components in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000314","sortNo":54,"contentFormatId":"1","contentTxt":"Lets take a look at the following simple Angular 2 component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000315","sortNo":55,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000316","sortNo":56,"contentFormatId":"1","contentTxt":"Nothing special here. If this is entirely new to you, you might want to read our article on building a zippy component in Angular 2. Lets say we want to extend this component by using a NameService that is used in the component’s constructor. Such a service could look something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000317","sortNo":57,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000318","sortNo":58,"contentFormatId":"1","contentTxt":"Again, nothing special here. We just create a class. Now, to make it available in our application as an injectable, we need to pass some provider configurations to our application’s injector. But how do we do that? We haven’t even created one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000319","sortNo":59,"contentFormatId":"1","contentTxt":"bootstrap() takes care of creating a root injector for our application when it’s bootstrapped. It takes a list of providers as second argument which will be passed straight to the injector when it is created. In other words, here’s what we need to to:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000320","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000321","sortNo":61,"contentFormatId":"1","contentTxt":"That’s it. Now, to actually inject it, we just use the tools we’ve already learned about - @Inject decorators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000322","sortNo":62,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000323","sortNo":63,"contentFormatId":"1","contentTxt":"Or, if we prefer TypeScript, we can just add type annotations to our constructor:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000324","sortNo":64,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000325","sortNo":65,"contentFormatId":"1","contentTxt":"Awesome! All of a sudden, we don’t have any Angular machinery at all anymore. But there’s one last thing: What if we want a different binding configuration in a specific component?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000326","sortNo":66,"contentFormatId":"1","contentTxt":"Lets say we have NameService as application wide injectable for the type NameService, but one particular component should get a different one? This is where the @Component annotations’ providers property comes in. It allows us to add providers to a specific component (and its child components).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000327","sortNo":67,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000328","sortNo":68,"contentFormatId":"1","contentTxt":"To make things clear: providers doesn’t configure the instances that will be injected. It configures a child injector that is created for that component. As mentioned earlier, we can also configure the visibility of our bindings, to be even more specific which component can inject what. E.g. the viewProviders property allows to make dependencies only available to a component’s view, but not its children. We're going to cover that in another article. Dependency injection host and visibility are covered in this article.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000329","sortNo":69,"contentFormatId":"1","contentTxt":"Conclusion","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201601040000000330","sortNo":70,"contentFormatId":"1","contentTxt":"The new dependency injection system in Angular solves all the problems that we have with the current DI in Angular 1. No name collisions anymore. It’s an isolated component of the framework that can be used as standalone system, without Angular 2 itself.","contentBinary":"","contentPoster":"","contentUrl":null}]
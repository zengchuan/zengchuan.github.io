[{"id":"201607180000000001","sortNo":1,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000002","sortNo":2,"contentFormatId":"1","contentTxt":"In this blog post I will talk about the three core concepts of Angular 2: components, dependency injection, and bindings.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Let’s Build an App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000004","sortNo":4,"contentFormatId":"1","contentTxt":"Let’s say we want to build this application, which is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000005","sortNo":5,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000006","sortNo":6,"contentFormatId":"1","contentTxt":"<strong>Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000007","sortNo":7,"contentFormatId":"1","contentTxt":"To build an Angular 2 application you define a set of components, for every UI element, screen, and route. An application will always have a root component that contains all other components. In other words, every Angular 2 application will have a component tree, which for this application may look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000008","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Application is the root component. The Filters component has the speaker input and the filter button. TalkList is the list you see at the bottom. And TalkCmp is an item in that list.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000010","sortNo":10,"contentFormatId":"1","contentTxt":"To understand what constitutes a component in Angular 2, let’s look closer at TalkCmp.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000011","sortNo":11,"contentFormatId":"1","contentTxt":"TalkCmp.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000012","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000013","sortNo":13,"contentFormatId":"1","contentTxt":"talk_cmp.html","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000014","sortNo":14,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000015","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>Input and Output Properties</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000016","sortNo":16,"contentFormatId":"1","contentTxt":"A component has input and output properties, which can be defined in the component decorator or using property decorators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000017","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000018","sortNo":18,"contentFormatId":"1","contentTxt":"Data flows into a component via input properties. Data flows out of a component via output properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000019","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000020","sortNo":20,"contentFormatId":"1","contentTxt":"Input and output properties are the public API of a component. You use them when you instantiate a component in your application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000021","sortNo":21,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000022","sortNo":22,"contentFormatId":"1","contentTxt":"You can set input properties using property bindings, through square brackets. You can subscribe to output properties using event bindings, through parenthesis.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000023","sortNo":23,"contentFormatId":"1","contentTxt":"A component has a template, which describes how the component is rendered on the page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000024","sortNo":24,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000025","sortNo":25,"contentFormatId":"1","contentTxt":"talk_cmp.html","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000026","sortNo":26,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000027","sortNo":27,"contentFormatId":"1","contentTxt":"Angular needs to know two things to render the template: the list of directives that can be used in its template, and the template itself. You can define the template externally, using the templateUrl, as in the example above, or inline.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000028","sortNo":28,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000029","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>Lifecycle</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000030","sortNo":30,"contentFormatId":"1","contentTxt":"Components have a well-defined lifecycle, which you can tap into. The TalkCmp component does not subscribe to any lifecycle events, but some other components can. For instance, this component will be notified when its input properties change.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000031","sortNo":31,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000032","sortNo":32,"contentFormatId":"1","contentTxt":"<strong>Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000033","sortNo":33,"contentFormatId":"1","contentTxt":"A component can contain a list of providers the component and its children may inject.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000034","sortNo":34,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000035","sortNo":35,"contentFormatId":"1","contentTxt":"In this example, we have the backend and the logger services declared in the root component, which makes them available in the whole application. The talks component injects the backend service. I will talk about dependency injection in detail in the second part of this article. For now, just remember that components configures dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000036","sortNo":36,"contentFormatId":"1","contentTxt":"<strong>Host Element</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000037","sortNo":37,"contentFormatId":"1","contentTxt":"To turn an Angular component into something rendered in the DOM you have to associate an Angular component with a DOM element. We call such elements host elements.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000038","sortNo":38,"contentFormatId":"1","contentTxt":"A component can interact with its host DOM element in the following ways:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000039","sortNo":39,"contentFormatId":"1","contentTxt":"1. It can listen to its events.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000040","sortNo":40,"contentFormatId":"1","contentTxt":"2. It can update its properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000041","sortNo":41,"contentFormatId":"1","contentTxt":"3. It can invoke methods on it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000042","sortNo":42,"contentFormatId":"1","contentTxt":"The component, for instance, listens to the input event using hostListeners, trims the value, and then stores it in a field. Angular will sync up the stored value with the DOM.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000043","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000044","sortNo":44,"contentFormatId":"1","contentTxt":"Note, I don’t actually interact with the DOM directly. Angular 2 aims to provide a higher-level API, so the native platform, the DOM, will just reflect the state of the Angular application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000045","sortNo":45,"contentFormatId":"1","contentTxt":"This is useful for a couple of reasons:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000046","sortNo":46,"contentFormatId":"1","contentTxt":"1. It makes components easier to refactor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000047","sortNo":47,"contentFormatId":"1","contentTxt":"2. It allows unit testing most of the behavior of an application without touching the DOM. Such tests are easier to write and understand. In addition, they are significantly faster.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000048","sortNo":48,"contentFormatId":"1","contentTxt":"3. It allows running Angular applications in a web worker.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000049","sortNo":49,"contentFormatId":"1","contentTxt":"4. It allows running Angular applications outside of the browser completely, on other platforms, for instance using NativeScript.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000050","sortNo":50,"contentFormatId":"1","contentTxt":"Sometimes you just need to interact with the DOM directly. Angular 2 provides such APIs, but our hope is that you will rarely need to use them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000051","sortNo":51,"contentFormatId":"1","contentTxt":"Components are Self-Describing","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000052","sortNo":52,"contentFormatId":"1","contentTxt":"What I have listed constitutes a component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000053","sortNo":53,"contentFormatId":"1","contentTxt":"1. A component knows how to interact with its host element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000054","sortNo":54,"contentFormatId":"1","contentTxt":"2. A component knows how to render itself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000055","sortNo":55,"contentFormatId":"1","contentTxt":"3. A component configures dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000056","sortNo":56,"contentFormatId":"1","contentTxt":"4. A component has a well-defined public API of input and output properties.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000057","sortNo":57,"contentFormatId":"1","contentTxt":"All of these make components in Angular 2 self-describing, so they contain all the information needed to instantiate them. This is extremely important.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000058","sortNo":58,"contentFormatId":"1","contentTxt":"This means that any component can be bootstrapped as an application. It does not have to be special in any way. Moreover, any component can be loaded into a router outlet. As a result, you can write a component that can be bootstrapped as an application, loaded as a route, or used in some other component directly. This results in less API to learn. And it also makes components more reusable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000059","sortNo":59,"contentFormatId":"1","contentTxt":"<strong>What About Directives?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000060","sortNo":60,"contentFormatId":"1","contentTxt":"If you are familiar with Angular 1, you must be wondering “What happened to directives?”.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000061","sortNo":61,"contentFormatId":"1","contentTxt":"Actually directives are still here in Angular 2. The component is just the most important type of a directive, but not the only one. A component is a directive with a template. But you can still write decorator-style directives, which do not have templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000062","sortNo":62,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000063","sortNo":63,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000064","sortNo":64,"contentFormatId":"1","contentTxt":"Components are fundamental building blocks of Angular 2 applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000065","sortNo":65,"contentFormatId":"1","contentTxt":"1. They have well-defined inputs and outputs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000066","sortNo":66,"contentFormatId":"1","contentTxt":"2. They have well-defined lifecycle.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000067","sortNo":67,"contentFormatId":"1","contentTxt":"3. They are self-describing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000068","sortNo":68,"contentFormatId":"1","contentTxt":"<strong>Dependency Injection</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000069","sortNo":69,"contentFormatId":"1","contentTxt":"Let’s switch gears and talk about another cornerstone of Angular — dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000070","sortNo":70,"contentFormatId":"1","contentTxt":"The idea behind dependency injection is very simple. If you have a component that depends on a service. You do not create that service yourself. Instead, you request one in the constructor, and the framework will provide you one. By doing so you can depend on interfaces rather than concrete types. This leads to more decoupled code, which enables testability, and other great things.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000071","sortNo":71,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000072","sortNo":72,"contentFormatId":"1","contentTxt":"Angular 2 comes with a dependency injection module. To see how it can be used, let’s look at the following component, which renders a list of talks using the for directive:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000073","sortNo":73,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000074","sortNo":74,"contentFormatId":"1","contentTxt":"talks.html","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000075","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000076","sortNo":76,"contentFormatId":"1","contentTxt":"Let’s mock up a simple service that will give us the data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000077","sortNo":77,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000078","sortNo":78,"contentFormatId":"1","contentTxt":"How can we use this service? One approach is to create an instance of this service in our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000079","sortNo":79,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000080","sortNo":80,"contentFormatId":"1","contentTxt":"This is fine for a demo app, but not good for real applications. In a real application TalksAppBackend won’t just return an array of objects, it will make http requests to get the data. This means that the unit tests for this component will make real http requests — not a great idea. This problem is caused by the fact that we have coupled TalkList to TalksAppBackend and its new operator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000081","sortNo":81,"contentFormatId":"1","contentTxt":"We can solve this problem by injecting an instance TalksAppBackend into the constructor, so we can easily replace it in tests, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000082","sortNo":82,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000083","sortNo":83,"contentFormatId":"1","contentTxt":"This tells Angular that TalksList depend on TalksAppBackend. Now, we need to tell Angular how to create one, and we can do it by adding the providers property to this component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000084","sortNo":84,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000085","sortNo":85,"contentFormatId":"1","contentTxt":"The TalksAppBackend service has to be specified in the TalkList component or its ancestor. So if you prefer to write your apps in the Angular 1 style, you can configure all providers in the root component. That will make them available for any component in the system.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000086","sortNo":86,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000087","sortNo":87,"contentFormatId":"1","contentTxt":"<strong>Single API</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000088","sortNo":88,"contentFormatId":"1","contentTxt":"Both Angular 1 and Angular 2 come with dependency injection modules. But in Angular 1 we have several APIs for injecting dependencies into directives: some objects are injected by position (e.g., element), some by name. It is a little bit confusing. Angular 2 provides a single API for injecting dependencies. All of them injected into the component’s constructor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000089","sortNo":89,"contentFormatId":"1","contentTxt":"For instance, this component injects an instance of TalksAppBackend (which is likely to be a singleton), and an ElementRef, which is unique for every component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000090","sortNo":90,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000091","sortNo":91,"contentFormatId":"1","contentTxt":"So we use the same API to inject global and local dependencies into the component. Moreover, a component can inject other components using the same API:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000092","sortNo":92,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000093","sortNo":93,"contentFormatId":"1","contentTxt":"Dependency injection is one of those features you don’t see the benefits of right away. But the bigger your application grows, the more important it gets.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000094","sortNo":94,"contentFormatId":"1","contentTxt":"1. It allows you to depend on interfaces, not concrete types.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000095","sortNo":95,"contentFormatId":"1","contentTxt":"2. This results in more decoupled code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000096","sortNo":96,"contentFormatId":"1","contentTxt":"3. This improves testability.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000097","sortNo":97,"contentFormatId":"1","contentTxt":"4. Angular 2 has one API for injecting dependencies into components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000098","sortNo":98,"contentFormatId":"1","contentTxt":"<strong>Property Bindings</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000099","sortNo":99,"contentFormatId":"1","contentTxt":"Angular uses property bindings to automatically sync up the component tree with the model, and the DOM with the component tree. To understand why this is important, let’s look at this application one more time.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000100","sortNo":100,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000101","sortNo":101,"contentFormatId":"1","contentTxt":"We know that this application will have a component tree. In addition to the tree, it will also have a model. Let’s say it is simple JavaScript object that looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000102","sortNo":102,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000103","sortNo":103,"contentFormatId":"1","contentTxt":"Now, imagine an event changes the model. Say I watched this talk, I really liked it, and I gave it 9.9.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000104","sortNo":104,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000105","sortNo":105,"contentFormatId":"1","contentTxt":"If I had to find all the places that might depend on the new value and manually update them, that would be tedious and error-prone. I want the application to reflect this change automatically. That is what property bindings are for.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000106","sortNo":106,"contentFormatId":"1","contentTxt":"At the end of the VM turn, Angular will check every component in the component tree. More specifically, it will check every property binding (every square bracket, every pair of curly braces), and will update the components. It will also update the DOM to match the state of the component tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000107","sortNo":107,"contentFormatId":"1","contentTxt":"Only the input properties of a component can be updated using property bindings.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000108","sortNo":108,"contentFormatId":"1","contentTxt":"<strong>Zones</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000109","sortNo":109,"contentFormatId":"1","contentTxt":"In Angular 1 you have to tell the framework that it needs to run this check by doing scope.$apply. You don’t need to worry about it in Angular 2. Angular 2 uses Zones to know when this check is required. This means that you do not need to call scope.$apply to integrate with third-party libraries.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000110","sortNo":110,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000111","sortNo":111,"contentFormatId":"1","contentTxt":"1. Angular uses property bindings to sync up the component tree with the model, and the DOM with the component tree.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000112","sortNo":112,"contentFormatId":"1","contentTxt":"2. Angular uses zones to know when to do it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000113","sortNo":113,"contentFormatId":"1","contentTxt":"<strong>Let’s Recap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000114","sortNo":114,"contentFormatId":"1","contentTxt":"Directives, and in particular components, are the most important part of Angular. They are the fundamental building blocks of Angular 2 applications. They are self-describing. They describe their public API, which is inputs and outputs. They describe their private API, which is lifecycle hooks, and how they interact with the host element. Some components will depend on other components and services. The dependency injection module will provide those. It will construct the component tree, which is the core of any Angular 2 application. Finally, property bindings and zones is what makes Angular 2 applications interactive.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000115","sortNo":115,"contentFormatId":"1","contentTxt":"These are the building blocks that form the core of Angular 2. Understanding them is enough to get started with Angular 2, but building a real application will require more than that. That is why we’ve also been working on a set of modules built on top of the core to enable great development experience. These include","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000116","sortNo":116,"contentFormatId":"1","contentTxt":"1. A form-handling or input-handling module","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000117","sortNo":117,"contentFormatId":"1","contentTxt":"2. An http client","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000118","sortNo":118,"contentFormatId":"1","contentTxt":"3. A powerful router","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000119","sortNo":119,"contentFormatId":"1","contentTxt":"4. Support for animations","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000120","sortNo":120,"contentFormatId":"1","contentTxt":"5. A suite of UI components, called material components","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000121","sortNo":121,"contentFormatId":"1","contentTxt":"6. Tools for writing unit, e2e, and performance tests","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607180000000122","sortNo":122,"contentFormatId":"1","contentTxt":"All of them are in pretty good shape, and ready to be used for building apps.","contentBinary":"","contentPoster":"","contentUrl":null}]
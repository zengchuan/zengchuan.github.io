[{"id":"201603160000000002","sortNo":1,"contentFormatId":"1","contentTxt":"Forms are part of almost every web application out there. Angular strives for making working with forms a breeze. While there are a couple of built-in validators provided by the framework, we often need to add some custom validation capabilities to our application’s form, in order to fulfill our needs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000003","sortNo":2,"contentFormatId":"1","contentTxt":"We can easily extend the browser vocabulary with additional custom validators and in this article we are going to explore how to do that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000004","sortNo":3,"contentFormatId":"1","contentTxt":"Built-in Validators","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000005","sortNo":4,"contentFormatId":"1","contentTxt":"Angular comes with a subset of built-in validators out of the box. We can apply them either declaratively as directives on elements in our DOM, in case we’re building a template-driven form, or imperatively using the Control and ControlGroup or FormBuilder APIs, in case we’re building a model-driven form. If you don’t know what it’s all about with template-driven and model-driven forms, don’t worry, we’ll have an article to each of those soon.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000006","sortNo":5,"contentFormatId":"1","contentTxt":"The supported built-in validators, at the time of writing this article, are:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000007","sortNo":6,"contentFormatId":"1","contentTxt":"1. required - Requires a form control to have a non-empty value","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000008","sortNo":7,"contentFormatId":"1","contentTxt":"2. minlength - Requires a form control to have a value of a minimum length","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000009","sortNo":8,"contentFormatId":"1","contentTxt":"3. maxlength - Requires a form control to have a value of a maximum length","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000010","sortNo":9,"contentFormatId":"1","contentTxt":"4. pattern - Requires a form control’s value to match a given regex","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000011","sortNo":10,"contentFormatId":"1","contentTxt":"As mentioned earlier, validators can be applied by simply using their corresponding directives. The following form shows how the built-in validators are applied to dedicated form controls:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000145","sortNo":11,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000146","sortNo":12,"contentFormatId":"1","contentTxt":"Or, if our form is model-driven we’d either build it using Control and ControlGroup APIs:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000147","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000148","sortNo":14,"contentFormatId":"1","contentTxt":"Or use the less verbose FormBuilder API that does the same work for us:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000149","sortNo":15,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000150","sortNo":16,"contentFormatId":"1","contentTxt":"We would still need to associate a form model with a form in the DOM using the [ngFormModel] directive likes this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000151","sortNo":17,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000152","sortNo":18,"contentFormatId":"1","contentTxt":"Observing these two to three different methods of creating a form, we might wonder how it is done that we can use the validator methods imperatively in our component code, and apply them as directives to input controls declaratively in our HTML code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000153","sortNo":19,"contentFormatId":"1","contentTxt":"It turns out there’s really not such a big magic involved, so let’s build our own custom email validator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000154","sortNo":20,"contentFormatId":"1","contentTxt":"Building a custom validator","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000155","sortNo":21,"contentFormatId":"1","contentTxt":"In it’s simplest form, a validator is really just a function that takes a Control and returns either null when it’s valid, or and error object if it’s not. A TypeScript interface for such a validator looks something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000156","sortNo":22,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000157","sortNo":23,"contentFormatId":"1","contentTxt":"Let’s implement a validator function validateEmail which implements that interface. All we need to do is to define a function that takes a Control, checks if it’s value matches the regex of an email address, and if not, returns an error object, or null in case the value is valid.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000158","sortNo":24,"contentFormatId":"1","contentTxt":"Here’s what such an implementation could look like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000159","sortNo":25,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000160","sortNo":26,"contentFormatId":"1","contentTxt":"Pretty straight forward right? We import Control from angular2/common to have the type information the the function’s signature and simply test a regular expression with the Control’s value. That’s it. That’s a validator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000161","sortNo":27,"contentFormatId":"1","contentTxt":"But how do we apply them to other form controls? Well, we’ve seen how Validators.required and the other validators are added to the new Control() calls. Control() takes an initial value, a synchronous validator and an asynchronous validator. Which means, we do exactly the same with our custom validators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000162","sortNo":28,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000163","sortNo":29,"contentFormatId":"1","contentTxt":"Don’t forget to import validateEmail accordinlgy, if necessary. Okay cool, now we know how to add our custom validator to a form control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000164","sortNo":30,"contentFormatId":"1","contentTxt":"However, what if we want to combine multiple validators on a single control? Let’s say our email field is required and needs to match the shape of an email address. Since Controls only take single synchronous and a single asynchronous validator, we need to use Validators.compose([validator1, validator2]) to compose mutliple validators into one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000165","sortNo":31,"contentFormatId":"1","contentTxt":"Here’s what it looks like if we’d combine the required validator with our custom one:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000166","sortNo":32,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000167","sortNo":33,"contentFormatId":"1","contentTxt":"Building custom validator directives","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000168","sortNo":34,"contentFormatId":"1","contentTxt":"Now that we’re able to add our custom validator to our form controls imperatively when building model-driven forms, we might also enable our validator to be used in template driven forms. In other words: We need a directive. The validator should be usable like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000169","sortNo":35,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000170","sortNo":36,"contentFormatId":"1","contentTxt":"validateEmail is applied as an attribute to the <input> DOM element, which already gives us an idea what we need to do. We need to build a directive with a matching selector so it will be executed on all input controls where the directive is applied. Let’s start off with that.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000171","sortNo":37,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000172","sortNo":38,"contentFormatId":"1","contentTxt":"We import the @Directive decorator form angular2/core and use it on a new EmailValidator class. If you’re familiar with the @Component() decorator that this is probably not new to you. In fact, @Directive is a superset of @Component which is why most of the configuration properties are available.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000173","sortNo":39,"contentFormatId":"1","contentTxt":"Okay, technically we could already make this directive execute in our app, all we need to do is to add it as a directives dependency to the component where it’s used:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000174","sortNo":40,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000175","sortNo":41,"contentFormatId":"1","contentTxt":"Even though this works, there’s nothing our directive does at the moment. What we want to do is to make sure that our custom validator is executed when Angular compiles this directive. How do we get there?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000176","sortNo":42,"contentFormatId":"1","contentTxt":"Angular has an internal mechanism to execute validators on a form control. It maintains a multi provider for a dependency token called NG_VALIDATORS. If you’ve read our article on multi providers in Angular 2, you know that Angular injects multiple values for a single token that is used for a multi provider. If you haven’t, we highly recommend checking it out as the rest of this article is based on it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000177","sortNo":43,"contentFormatId":"1","contentTxt":"It turns out that all built-in validators are already added to the NG_VALIDATORS token. So whenever Angular instantiates a form control and performs validation, it basically injects the dependency for the NG_VALIDATORS token, which is a list of all validators, and executes them one by one on that form control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000178","sortNo":44,"contentFormatId":"1","contentTxt":"Since multi providers can be extended by adding more multi providers to a token, we can consider NG_VALIDATORS as a hook to add our own validators.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000179","sortNo":45,"contentFormatId":"1","contentTxt":"Let’s add our validator to the NG_VALIDATORS via our new directive:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000180","sortNo":46,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000181","sortNo":47,"contentFormatId":"1","contentTxt":"Again, if you’ve read our article on multi providers, this should look very familiar to you. We basically add a new value to the NG_VALIDATORS token by taking advantage of multi providers. Angular will pick our validator up by injecting what it gets for NG_VALIDATOR, and performs validation on a form control. Awesome, we can now use our validator for model-driven and for template-driven forms!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000182","sortNo":48,"contentFormatId":"1","contentTxt":"Custom Validators with dependencies","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000183","sortNo":49,"contentFormatId":"1","contentTxt":"Sometimes, a custom validator has dependencies so we need a way to inject them. Let’s say our email validator needs an EmailBlackList service, to check if the given control value is not only a valid email address but also not on our email black list (in an ideal world, we’d build a separate validator for checking against an email black list, but we use that as a motivation for now to have a dependency).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000184","sortNo":50,"contentFormatId":"1","contentTxt":"The not-so-nice way","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000185","sortNo":51,"contentFormatId":"1","contentTxt":"One way to handle this is to create a factory function that returns our validateEmail function, which then uses an instance of EmailBlackList service. Here’s what such a factory function could look like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000186","sortNo":52,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000187","sortNo":53,"contentFormatId":"1","contentTxt":"This would allow us to register our custom validator via dependency injection like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000188","sortNo":54,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000189","sortNo":55,"contentFormatId":"1","contentTxt":"We can’t use useValue as provider recipe anymore, because we don’t want to return the factory function, but rather what the factory function returns. And since our factory function has a dependency itself, we need to have access to dependency tokens, which is why we use useFactory and deps. If this is entirely new to you, you might want to read our article on Dependency Injection in Angular 2 before we move on.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000190","sortNo":56,"contentFormatId":"1","contentTxt":"Even though this would work, it’s quite a lot of work and also very verbose. We can do better here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000191","sortNo":57,"contentFormatId":"1","contentTxt":"The better way","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000192","sortNo":58,"contentFormatId":"1","contentTxt":"Wouldn’t it be nice if we could use constructor injection as we’re used to it in Angular 2? Yes, and guess what, Angular has us covered. It turns out that a validator can also be a class as long as it implements a validate(c: Control) method. Why is that nice? Well, we can inject our dependency using constructor injection and don’t have to setup a provider factory as we did before.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000193","sortNo":59,"contentFormatId":"1","contentTxt":"Here’s what our EmailValidator class would look like when we apply this pattern to it:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000194","sortNo":60,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000195","sortNo":61,"contentFormatId":"1","contentTxt":"However, we now need to adjust the provider for NG_VALIDATORS, because we want to use an instance of EmailValidator to be used for validation, not the factory function. This seems easy to fix, because we know that we create instances of classes for dependency injection using the useClass recipe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000196","sortNo":62,"contentFormatId":"1","contentTxt":"However, we already added EmailValidator to the directives property of our component, which is a provider with the useClass recipe. We want to make sure that we get the exact same instance of EmailValidator on our form control, even though, we define a new provider for it. Luckily we have the useExisting recipe for that. useExisting defines an alias token for but returns the same instance as the original token:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000197","sortNo":63,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000198","sortNo":64,"contentFormatId":"1","contentTxt":"Yikes! This won’t work . We’re referencing a token (EmailValidator) which is undefined at the point we’re using it because the class definition itself happens later in the code. That’s where forwardRef() comes into play.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000199","sortNo":65,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000200","sortNo":66,"contentFormatId":"1","contentTxt":"If you don’t know what forwardRef() does, you might want to read our article on Forward References in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000201","sortNo":67,"contentFormatId":"1","contentTxt":"Here’s the full code for our custom email validator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000202","sortNo":68,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201603160000000203","sortNo":69,"contentFormatId":"1","contentTxt":"You might notice that we’ve extended the selector, so that our validator not only works with ngControl but also with ngModel and ngFormControl directives. If you’re interested in more articles on forms in Angular 2, make sure to subscribe to our blog as we have more in the pipe which will be published soon!","contentBinary":"","contentPoster":"","contentUrl":null}]
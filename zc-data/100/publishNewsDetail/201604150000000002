[{"id":"201604150000000054","sortNo":1,"contentFormatId":"1","contentTxt":"Recently there where announcements that made clear that the Angular 2 final release is just around the corner. This might be as early as mid-May during Google IO !","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000055","sortNo":2,"contentFormatId":"1","contentTxt":"But thats still several months into the future, and there are many projects that will start between now and then. A question that gets asked a lot these days is: should I use Angular 2 or just stick to Angular 1?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000056","sortNo":3,"contentFormatId":"1","contentTxt":"Angular 2 is currently in Beta, and being in Beta means the following according to the official announcement:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000057","sortNo":4,"contentFormatId":"1","contentTxt":"Beta means we're now confident that most developers can be successful building large applications using Angular 2","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000058","sortNo":5,"contentFormatId":"1","contentTxt":"This was about 3 months ago. So the answer is yes, we should definitely use Angular 2 for projects starting today. But how?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000059","sortNo":6,"contentFormatId":"1","contentTxt":"Lets answer this and several other questions while going through the following topics:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000060","sortNo":7,"contentFormatId":"1","contentTxt":"<strong>Current status of the Angular 2 composing parts</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000061","sortNo":8,"contentFormatId":"1","contentTxt":"The Angular 2 core functionality which includes Components, Directives, Forms, Pipes, Dependency Injection and HTTP has been stable for several months and ready to go. The router is expected to have some API changes to improve developer ergonomics, but the main functionality is already available.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000062","sortNo":9,"contentFormatId":"1","contentTxt":"There are still some hoops to jump through, but those are the exception and not the rule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000063","sortNo":10,"contentFormatId":"1","contentTxt":"So what is preventing us from using Angular 2 in production? There are several perceived reasons, one of them could be that the tooling around it is a work in progress.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000064","sortNo":11,"contentFormatId":"1","contentTxt":"<strong>The current state of the angular-cli</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000065","sortNo":12,"contentFormatId":"1","contentTxt":"On the long term, one of the great advantages of Angular 2 is that we will have an opinionated way to setup and build a project, via the Angular Command Line Interface (CLI).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000066","sortNo":13,"contentFormatId":"1","contentTxt":"This tool will provide us with a way to scaffold projects and a standard build pipeline. The build will internally be based on brocolli and the CLI itself is based on the popular ember-cli.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000067","sortNo":14,"contentFormatId":"1","contentTxt":"But most importantly, we will have a build system officially endorsed by the Angular 2 team that will take us from development to production.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000068","sortNo":15,"contentFormatId":"1","contentTxt":"The problem is that the angular-cli although already working and being used to build the Angular 2 Material widget library, is currently according to the the docs:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000069","sortNo":16,"contentFormatId":"1","contentTxt":"So its clear that on the long term we want our Angular 2 projects to be built using angular-cli, but that solution is still in its early stages.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000070","sortNo":17,"contentFormatId":"1","contentTxt":"Also related to the toolchain, there are more questions regarding how to setup our project.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000071","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Is there a recommended package manager and module loader ?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000072","sortNo":19,"contentFormatId":"1","contentTxt":"For one, which package manager and module loader should we choose? The Angular team mentioned recently in the Adventures in Angular podcast that they would be standing behind one package manager and one module loader.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000073","sortNo":20,"contentFormatId":"1","contentTxt":"Its was not mentioned which ones at that stage, but we can guess via the documentation and the contents of the project's google drive that:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000074","sortNo":21,"contentFormatId":"1","contentTxt":"1. Package manager: The package manager is npm, based on the existence of proposal documents for making npm more friendly for frontend development, and the fact that almost everything can be found in npm these days","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000075","sortNo":22,"contentFormatId":"1","contentTxt":"2. Module Loader: both the quick start tutorial and the initial version of angular-cli use SystemJs, this will likelly be the module loader of choice for building Angular 2 apps.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000076","sortNo":23,"contentFormatId":"1","contentTxt":"Its important to bear in mind that this does not mean that the framework will not work in other package managers or module loaders, by the contrary all of them will be supported.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000077","sortNo":24,"contentFormatId":"1","contentTxt":"Besides the toolchain, there seems to be another main point that is being worked on: the overall bundle size.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000078","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Is the bundle size a real concern?</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000079","sortNo":26,"contentFormatId":"1","contentTxt":"The current 115KB compressed and minified size of the main Angular 2 bundle might not be a concern depending on the type of application you are building:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000080","sortNo":27,"contentFormatId":"1","contentTxt":"1. are you doing mobile development? If not the bundle size might not be much of a concern. Many pages that we surf everyday on the Internet load way more Javascript than that","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000081","sortNo":28,"contentFormatId":"1","contentTxt":"2. are you building an enterprise application that will run only on a company LAN? You probably have a very fast server connection, making the bundle size even less of a concern","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000082","sortNo":29,"contentFormatId":"1","contentTxt":"3. are you going to production in less than 2 months? By then the size of the bundle issue (if its an issue at all for your project) should have been fixed","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000083","sortNo":30,"contentFormatId":"1","contentTxt":"4. are you building a productivity single page app? One extra second of initial load time might not be an issue. For example users are used to wait over 5 seconds for Gmail to open","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000084","sortNo":31,"contentFormatId":"1","contentTxt":"Let's go back to the meaning of Beta, it means we should be able to run an application in production. Given this and all of the above, can we come up with a strategy to do so?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000085","sortNo":32,"contentFormatId":"1","contentTxt":"<strong>A strategy for running Angular 2 in production in the next few months</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000086","sortNo":33,"contentFormatId":"1","contentTxt":"One way to do it is to choose a lightweight toolchain that can be put in place quickly but still is sufficient to put an app in production. At the same time we want to make sure that such toolchain can be easily replaced in a couple of months once angular-cli lands.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000087","sortNo":34,"contentFormatId":"1","contentTxt":"Once angular-cli is ready, we will then have all the functionality necessary to compile templates in a build step instead of at startup time. With that the compiler part of Angular will not need to be shipped to the browser and the bundle size will be drastically reduced.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000088","sortNo":35,"contentFormatId":"1","contentTxt":"What we want to avoid is to make a large investment in a complex toolchain that we already know upfront that will be obsolete in a matter of months.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000089","sortNo":36,"contentFormatId":"1","contentTxt":"So let's start choosing our toolchain and development practices, with an eye towards the present, but keeping it future-proof regarding a future migration to angular-cli.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000090","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>Package Manager and Module Loader</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000091","sortNo":38,"contentFormatId":"1","contentTxt":"Lets start with the simplest choices: its better to use npm as our package manager and SystemJs as module loader, as that seems to be the path of least friction.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000092","sortNo":39,"contentFormatId":"1","contentTxt":"Note that other package managers and module loaders would also work, but this is the choice that will likely be easier to migrate to angular-cli, and its the combination that angular-cli currently uses.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000093","sortNo":40,"contentFormatId":"1","contentTxt":"<strong>How to load Angular 2</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000094","sortNo":41,"contentFormatId":"1","contentTxt":"For loading Angular in the app itself, a very straightforward way to do so is to simply use a CDN to get your scripts loaded. This gives the following immediate benefits:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000095","sortNo":42,"contentFormatId":"1","contentTxt":"1. it allows the development to start right now","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000096","sortNo":43,"contentFormatId":"1","contentTxt":"2. it makes for a simpler initial build","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000097","sortNo":44,"contentFormatId":"1","contentTxt":"3. its easy to go back later once angular-cli is available and refactor this","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000098","sortNo":45,"contentFormatId":"1","contentTxt":"4. its actually a viable option to use in production (for many applications) as we will see next","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000099","sortNo":46,"contentFormatId":"1","contentTxt":"<strong>Where to load Angular from</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000100","sortNo":47,"contentFormatId":"1","contentTxt":"The Cloudflare sponsored Content Delivery Network CdnJs serves for free most scripts needed to run Angular 2, as well as many others. In fact all script needed by Angular are available there except:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000101","sortNo":48,"contentFormatId":"1","contentTxt":"1. the beta version of Rxjs","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000102","sortNo":49,"contentFormatId":"1","contentTxt":"2. The IE11 compatibility shims (soon to be included in the main bundle)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000103","sortNo":50,"contentFormatId":"1","contentTxt":"But those can be taken as well from the npm CDN. Lets now measure some load times. Lets take for example the following script tags:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000104","sortNo":51,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000105","sortNo":52,"contentFormatId":"1","contentTxt":"As we can see, everything is being loaded from CdnJs, a couple of scripts, and soon everything will be available in CdnJs. We could load everything from npm CDN as well, but sometimes the load times from the npm CDN are much longer, so its better to use Cloudflare as much as possible, like we are doing here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000106","sortNo":53,"contentFormatId":"1","contentTxt":"You can easily get 300ms of total script load time for all the scripts needed to run Angular 2, including RxJs. This is with the browser cache turned off:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000107","sortNo":54,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000108","sortNo":55,"contentFormatId":"1","contentTxt":"These are pretty acceptable timings ! We can actually run many productivity or enterprise desktop-like apps using this setup, with no problem at all.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000109","sortNo":56,"contentFormatId":"1","contentTxt":"But what about other things, like how should we handle our HTML or CSS in a way that its future proof and easy to migrate to angular-cli?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000110","sortNo":57,"contentFormatId":"1","contentTxt":"<strong>How to handle HTML templates</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000111","sortNo":58,"contentFormatId":"1","contentTxt":"The main concern about HTML templates is that we want to make sure that we won't have to load them in separate HTTP requests in production, as this really slows down a lot the application startup.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000112","sortNo":59,"contentFormatId":"1","contentTxt":"In Angular 1 we would use a build step to pre-populate the template cache using plugins like gulp-ng-html2js.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000113","sortNo":60,"contentFormatId":"1","contentTxt":"A feature will be available soon called Template Transforms (read more in this talk), that will allow to build an ecosystem of tooling around templates. But right now, we have two ways to include templates in a component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000114","sortNo":61,"contentFormatId":"1","contentTxt":"1. inline templates: This consists on adding templates as inline strings directly in the component code. It has the advantage that at runtime there is no extra HTTP request, but this method might not scale well for large templates","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000115","sortNo":62,"contentFormatId":"1","contentTxt":"2. external templates: Templates can also be placed in external html files. This is cleaner and scales better specially in a team with designers and several developers editing the same code. But this will result in an extra HTTP request per template","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000116","sortNo":63,"contentFormatId":"1","contentTxt":"As we can see none of the two solutions is ideal. Lets see if we can come up with a better way, but first let's see how templates will be handled in the future.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000117","sortNo":64,"contentFormatId":"1","contentTxt":"<strong>The solution for importing templates in the future</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000118","sortNo":65,"contentFormatId":"1","contentTxt":"What we need is a mechanism to import a file in Typescript as a string. This already exists in SystemJs itself, but we are only using it to load scripts in the browser and not during Typescript compilation. It also exists in Webpack, via the text loader.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000119","sortNo":66,"contentFormatId":"1","contentTxt":"For out setup the ideal would be something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000120","sortNo":67,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000121","sortNo":68,"contentFormatId":"1","contentTxt":"And then we could use the template as a variable and pass it on to the component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000122","sortNo":69,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000123","sortNo":70,"contentFormatId":"1","contentTxt":"This functionality will be available in future versions of Typescript, see for example this Github issue. So there is no indication that importing templates will be handled by angular-cli, this will simply be a new feature language of Typescript (although angular-cli might provide an alternative, its currently not clear).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000124","sortNo":71,"contentFormatId":"1","contentTxt":"But what can we do while this is not available?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000125","sortNo":72,"contentFormatId":"1","contentTxt":"<strong>A way of handling HTML templates</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000126","sortNo":73,"contentFormatId":"1","contentTxt":"If the template of the component is small, the option remains to keep it inline. If the template gets too big, its possible to externalize it in a separate Typescript file that exports a single string. In practice this looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000127","sortNo":74,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000128","sortNo":75,"contentFormatId":"1","contentTxt":"Notice that the syntax highlighting and the autocompletion is still available even inside embedded strings. This is automatically the case in Webstorm. If by some reason Html is not detected, its possible to so manually using Alt + Enter inside the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000129","sortNo":76,"contentFormatId":"1","contentTxt":"The template (named test.html.ts) can then be imported via the following syntax, and simply used as a string:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000130","sortNo":77,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000131","sortNo":78,"contentFormatId":"1","contentTxt":"This has the following advantages:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000132","sortNo":79,"contentFormatId":"1","contentTxt":"1. this does not cause an extra HTTP request","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000133","sortNo":80,"contentFormatId":"1","contentTxt":"2. The template is an external file, this scales better for larger teams and projects","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000134","sortNo":81,"contentFormatId":"1","contentTxt":"3. Most of the IDE Html tooling works correctly in the external file","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000135","sortNo":82,"contentFormatId":"1","contentTxt":"4. this file can be easily migrated to a plain HTML file once Typescript \"import file as string\" functionlaity is in place","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000136","sortNo":83,"contentFormatId":"1","contentTxt":"There is another important aspect of how to use the application in production: how to bundle our Javascript?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000137","sortNo":84,"contentFormatId":"1","contentTxt":"<strong>A simple way to bundle an Angular 2 application</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000138","sortNo":85,"contentFormatId":"1","contentTxt":"It might seem something trivial, but once we have our plain Javascript files in a build output directory, how do we prepare a bundle? We need to concatenate the files in the right order and this soon proves cumbersome.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000139","sortNo":86,"contentFormatId":"1","contentTxt":"Luckily since Typescript 1.8 there is a simple way: we can configure the compiler to output the compilation result to a single file instead of separate files. For that, we just need to adapt our tsconfig.json:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000140","sortNo":87,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000141","sortNo":88,"contentFormatId":"1","contentTxt":"Notice the value of the outfile property, its a new compiler feature. With it its possible to generate SystemsJs and AMD bundles (currently CommonJs is not yet supported).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000142","sortNo":89,"contentFormatId":"1","contentTxt":"In our case this does not pose an issue, as we are using SystemJs. What we have with this is an output bundle of our whole application containing all the templates embedded inside it and ready to be loaded by SystemJs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000143","sortNo":90,"contentFormatId":"1","contentTxt":"It would be just a matter of adding a simple gulp build to minify the file, cache bust the file name and inject it on our index.html.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000144","sortNo":91,"contentFormatId":"1","contentTxt":"But there are still a couple of loose strings to tie, and the biggest one is: how should we handle CSS in our application?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000145","sortNo":92,"contentFormatId":"1","contentTxt":"<strong>How to handle CSS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000146","sortNo":93,"contentFormatId":"1","contentTxt":"Shadow DOM is not available in all browsers, but we can still import styles at the component level using emulated mode. This will encapsulate the styles to make them affect only the component by prefixing the style with a high specificity selector. Have a look at this example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000147","sortNo":94,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000148","sortNo":95,"contentFormatId":"1","contentTxt":"The problem is that without the appropriate tooling for generating source maps, this currently cannot be debugged (but it will be so in the future).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000149","sortNo":96,"contentFormatId":"1","contentTxt":"<strong>A solution for handling CSS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000150","sortNo":97,"contentFormatId":"1","contentTxt":"One manageable way to manage a project with a large amount of CSS is to simply include it externally as a link tag, this has always worked and nothing in Angular 2 prevents us for using it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000151","sortNo":98,"contentFormatId":"1","contentTxt":"But to keep it manageable, a solid choice is to use Sass like the Angular 2 Material (the new Angular 2 widget library) project is currently doing, and like the Angular 1 version of the material design widgets is doing too.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000152","sortNo":99,"contentFormatId":"1","contentTxt":"The current version of angular-cli has Sass support, and the Angular 2 material alpha is already using angular-cli to handle their Sass/Css.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000153","sortNo":100,"contentFormatId":"1","contentTxt":"There is a large chance that if you ever use Angular 2 material in the near future (note: the components can be used one by one), you might have to customize Sass files to adapt the widgets to your application theme.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000154","sortNo":101,"contentFormatId":"1","contentTxt":"The most future-proof path of handling Css is to adopt the same pre-processor as the official component suite: Sass.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000155","sortNo":102,"contentFormatId":"1","contentTxt":"<strong>Using Sass in a reasonable way</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000156","sortNo":103,"contentFormatId":"1","contentTxt":"Sass is very powerful and there has been a movement (PostCSS) to instead componetize each extension to CSS separately in a plugin architecture. So for example, if we want a feature like Css file imports, variables or nested styles we can add those one by one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000157","sortNo":104,"contentFormatId":"1","contentTxt":"One alternative is to simply use Sass but not abuse its many powerful features. For example, don't nest styles too deeply just for grouping them under a single component, it creates very long selectors. If inside another component you want to override the styles, you have to create a very long selector, with all the maintenance issues that it brings.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000158","sortNo":105,"contentFormatId":"1","contentTxt":"<strong>Doing CSS in a structured way</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000159","sortNo":106,"contentFormatId":"1","contentTxt":"Complementing the use of Sass with a good CSS structuring methodology like Smacss is a good solution. The two are not exclusive, by the contrary its very convenient to implement Smacss using Sass.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000160","sortNo":107,"contentFormatId":"1","contentTxt":"<strong>Using Sass integrated with Angular 2</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000161","sortNo":108,"contentFormatId":"1","contentTxt":"Its clear that further down the line it will be possible to use Sass easily with Angular, by simply importing .scss files in our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000162","sortNo":109,"contentFormatId":"1","contentTxt":"Then a build step will transform the Sass into CSS and generate the appropriate source mappings that will allow to take advantage of the emulated encapsulated mode in a debuggable way.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000163","sortNo":110,"contentFormatId":"1","contentTxt":"But right now, a simple Sass build should get us going, knowing that in the future it will be easy to migrate it to the angular-cli pipeline.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000164","sortNo":111,"contentFormatId":"1","contentTxt":"<strong>How to handle internationalization</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000165","sortNo":112,"contentFormatId":"1","contentTxt":"The final release of Angular will contain a working i18n solution, with an extended set of features. And that is the advised solution for i18n in the long term.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000166","sortNo":113,"contentFormatId":"1","contentTxt":"We are not sure what the i18n solution will look like, but the translations will very likelly be applied in a build step and multiple versions of the application will be generated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000167","sortNo":114,"contentFormatId":"1","contentTxt":"But if you really need to write an application its better to add translations from the beginning using a version of ng-translate for Angular 2: ng2-translate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000168","sortNo":115,"contentFormatId":"1","contentTxt":"This has the same set of features that ng-translate has, which has been used to translate a very large number of applications in Angular 1. ng2-translate will cover the large majority of the needs of your application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000169","sortNo":116,"contentFormatId":"1","contentTxt":"<strong>Conclusions</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000170","sortNo":117,"contentFormatId":"1","contentTxt":"With a couple of simple methods presented above, its totally possible to start developing an application and also have it running in production today.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604150000000171","sortNo":118,"contentFormatId":"1","contentTxt":"By making our choices having in mind what the future will look like, its feasible to setup a build and development methods that suits our immediate needs, but still does not prevent us from easily migrating to angular-cli in the near future.","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201611170000000126","sortNo":1,"contentFormatId":"1","contentTxt":"Setting model values in Angular 2 can be done in a few different ways, however with reactive forms things are extremely easy to do with the new form APIs. In this post we’ll dig a little deeper as to the differences between patchValue and setValue in Angular 2 forms.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000127","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Reactive Form Setup</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000128","sortNo":3,"contentFormatId":"1","contentTxt":"For this, let’s assume we’re setting up some kind of event feedback form that first accepts our user credentials followed by the event title and location. For us to create a new event form is easy as FormBuilder will initialise specific values, but how would we set a form value should this component also be reused for displaying data already created and stored in the database.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000129","sortNo":4,"contentFormatId":"1","contentTxt":"First, assume the following form setup, in real life it would likely involve more form controls to get all the feedback for your particular event, however we’re merely diving into the APIs here to understand how to apply them to anything FormControl related. If you’ve not used FormControl, FormBuilder and friends before I’d highly recommend checking out the aforementioned reactive forms article to understand what’s happening below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000130","sortNo":5,"contentFormatId":"1","contentTxt":"Have a skim of the code and then we’ll progress below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000131","sortNo":6,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000132","sortNo":7,"contentFormatId":"1","contentTxt":"The usual suspects are present here, and we’re also introducing the SurveyService to provide the saveSurvey method inside the submit callback. So this is great, however let’s assume we have the following routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000133","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000134","sortNo":9,"contentFormatId":"1","contentTxt":"Specifically, the child route of /event contains this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000135","sortNo":10,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000136","sortNo":11,"contentFormatId":"1","contentTxt":"This will allow us to essentially achieve a URL such as this (with a unique id hash):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000137","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000138","sortNo":13,"contentFormatId":"1","contentTxt":"If you’ve used firebase before these keys will likely look somewhat familar. So let’s assume we just hit the above route, and want to update the form’s value. This can be done with a route resolve, however for these purposes - we’re not going to use one as we’ll be using an observable which will allow us to subscribe to route param changes and fetch new data and render it out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000139","sortNo":14,"contentFormatId":"1","contentTxt":"So let’s introduce the router code to the initial component. First we’ll import this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000140","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000141","sortNo":16,"contentFormatId":"1","contentTxt":"We’re importing Observable and adding switchMap to ensure it’s available. From here we can inject the ActivatedRoute inside the constructor:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000142","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000143","sortNo":18,"contentFormatId":"1","contentTxt":"Now we can jump back inside ngOnInit and add a subscription:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000144","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000145","sortNo":20,"contentFormatId":"1","contentTxt":"So anytime the route params change, we can use our getSurvey method, pass in the current param in the URL (the unique :id) and go fetch that unique Object. In this case, I’ve been using AngularFire2 which returns a FirebaseObjectObservable, therefore I can pipe it through switchMap and get the data through the subscribe.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000146","sortNo":21,"contentFormatId":"1","contentTxt":"The next question: patchValue or setValue? Before using an API I’ve gotten into the good habit of looking through the source code, so let’s quickly run over the difference between the two:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000147","sortNo":22,"contentFormatId":"1","contentTxt":"<strong>patchValue</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000148","sortNo":23,"contentFormatId":"1","contentTxt":"We’ll start with patchValue and then move onto setValue. Firstly “patch” sounds a bit off-putting, like it’s an API name that I shouldn’t really be using - but that’s not the case! Using patchValue has some benefits over setValue, and vice versa. These will become apparent after digging into the source…","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000149","sortNo":24,"contentFormatId":"1","contentTxt":"There are actually two things happening when updating a FormGroup versus FormControl, as patchValue has two implementations which we’ll look at below.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000150","sortNo":25,"contentFormatId":"1","contentTxt":"So, the source code for the FormGroup implementation:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000151","sortNo":26,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000152","sortNo":27,"contentFormatId":"1","contentTxt":"All this patchValue really is, is just a wrapper to loop child controls and invoke the actual patchValue method. This is really the piece you need to be interested in:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000153","sortNo":28,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000154","sortNo":29,"contentFormatId":"1","contentTxt":"Firstly, Object.keys() will return a new Array collection of Object keys, for example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000155","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000156","sortNo":31,"contentFormatId":"1","contentTxt":"The forEach block that follows simply iterates over the FormGroup keys and does a hash lookup using the name (each string key) as a reference inside the current FormGroup instance’s controls property. If it exists, it will then call .patchValue() on the current this.controls[name], which you might be wondering how does it call patchValue on a single control as we’re actually calling it from the FormGroup level. It’s just a wrapper to loop and invoke model updates the child FormControl instances.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000157","sortNo":32,"contentFormatId":"1","contentTxt":"Let’s loop back around before we get lost to understand the cycle here. Assume our initial FormGroup:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000158","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000159","sortNo":34,"contentFormatId":"1","contentTxt":"All we have here is really in Object representation is:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000160","sortNo":35,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000161","sortNo":36,"contentFormatId":"1","contentTxt":"So to update these model values we can reference our FormGroup instance, this.form and use patchValue() with some data:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000162","sortNo":37,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000163","sortNo":38,"contentFormatId":"1","contentTxt":"This will then perform the above loop, and update our FormControl instances, simple!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000164","sortNo":39,"contentFormatId":"1","contentTxt":"So, now we’re caught up on the full cycle let’s look at the FormControl specific implementation:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000165","sortNo":40,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000166","sortNo":41,"contentFormatId":"1","contentTxt":"Ignoring all the function arguments and types, all it does is call setValue, which - sets the value.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000167","sortNo":42,"contentFormatId":"1","contentTxt":"So, why use patchValue? I came across the use case for this when I was also using firebase. I actually get $exists() {} and $key returned as public Object properties from the API response, to which when I pass this straight from the API, patchValue throws no error:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000168","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000169","sortNo":44,"contentFormatId":"1","contentTxt":"It throws no errors due to the if check inside the Object.keys loop. Some might say it’s a safe $apply, just kidding. It’ll allow you to set values that exist and it will ignore ones that do not exist in the current iterated control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000170","sortNo":45,"contentFormatId":"1","contentTxt":"<strong>setValue</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000171","sortNo":46,"contentFormatId":"1","contentTxt":"So now we’ve checked patchValue, we’ll look into setValue. You may have guessed by now, that it’s a “more safe” way to do things. It’ll error for props that do not exist.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000172","sortNo":47,"contentFormatId":"1","contentTxt":"The FormGroup implementation for setValue:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000173","sortNo":48,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000174","sortNo":49,"contentFormatId":"1","contentTxt":"Just like before, we have the Object.keys iteration, however before the loop the values are all checked a _checkAllValuesPresent method is called:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000175","sortNo":50,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000176","sortNo":51,"contentFormatId":"1","contentTxt":"This just iterates over each child control and ensures that the name also exists on the Object by a lookup with value[name]. If the control value does not exist on the Object you’re trying to setValue, it will throw an error.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000177","sortNo":52,"contentFormatId":"1","contentTxt":"Providing your FormControl exists, Angular moves onto the Object.keys loop, however will first check that the control is missing for that value also via _throwIfControlMissing:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000178","sortNo":53,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000179","sortNo":54,"contentFormatId":"1","contentTxt":"First it’ll check if the this.controls even exists, and then it’ll ensure - i.e. the FormControl instances inside FormGroup - and then it’ll check if the name passed in even exists on the said FormControl. If it doesn’t - you’re getting an error thrown at you.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000180","sortNo":55,"contentFormatId":"1","contentTxt":"If you’ve reached this far, the following gets invoked and your value is set:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000181","sortNo":56,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000182","sortNo":57,"contentFormatId":"1","contentTxt":"Finally, we’ll check the source code of the individual FormControl’s implementation of setValue:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000183","sortNo":58,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000184","sortNo":59,"contentFormatId":"1","contentTxt":"This function alone doesn’t tell you anything of what’s happening internally as the changeFn are dependent from elsewhere, depending on what code is using the setValue internally. For instance, here’s how a changeFn gets set via a public method (note the .push(fn) being the changeFn):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000185","sortNo":60,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000186","sortNo":61,"contentFormatId":"1","contentTxt":"This will be from various other places from within the source code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000187","sortNo":62,"contentFormatId":"1","contentTxt":"Looping back round again to updating our FormGroup, we can make a quick setValue call like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000188","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000189","sortNo":64,"contentFormatId":"1","contentTxt":"This would then update the this.form perfectly without errors, however when we invoke this next piece, the errors are thrown:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000190","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000191","sortNo":66,"contentFormatId":"1","contentTxt":"Hopefully this answered a few questions on the differences between the two implementations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000192","sortNo":67,"contentFormatId":"1","contentTxt":"<strong>FormControl patchValue / setValue</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000193","sortNo":68,"contentFormatId":"1","contentTxt":"By diving through the source code we’ve also learned that you can call these methods directly to update particular FormControl instances, for example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201611170000000194","sortNo":69,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null}]
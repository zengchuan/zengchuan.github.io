[{"id":"201609220000000068","sortNo":1,"contentFormatId":"1","contentTxt":"The @NgModule is a new decorator that has recently been added in Angular 2. NgModule defines an Angular Module, which (from the official docs) are defined as \"Angular Modules help organize an application into cohesive blocks of functionality.\"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000069","sortNo":2,"contentFormatId":"1","contentTxt":"This post is the third in a series that introduce @NgModule and its role in creating Angular 2 apps. In this post I'll discuss some motivations for creating feature modules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000070","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Features</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000071","sortNo":4,"contentFormatId":"1","contentTxt":"Often our apps have discrete sets of related functionality. Customers, orders, administration, and login/logout are all examples of areas of our apps that, when linked together, make our app. Basically, we break down our app into smaller pieces. Let's refer to these pieces as features.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000072","sortNo":5,"contentFormatId":"1","contentTxt":"It makes sense that some of these features have functionality that is not intended to be exposed outside of the feature. We also may want to add a feature to the app as a whole unit at a later time. Or maybe the feature is there and we want to lazy load it when the user decides it is time to visit the feature.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000073","sortNo":6,"contentFormatId":"1","contentTxt":"These are all reasons why we might want to divide our app into feature areas. Many technologies have this concept in different forms. Angular 2 addresses this with @NgModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000074","sortNo":7,"contentFormatId":"1","contentTxt":"<strong>Identifying Features</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000075","sortNo":8,"contentFormatId":"1","contentTxt":"Let's revisit where we last left our app by looking at its root module. Notice that we have various components in our declarations. This could easily grow to a long list in even a medium sized app. But also notice that many of these declarations can be logically grouped together. These are candidates for features.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000076","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000077","sortNo":10,"contentFormatId":"1","contentTxt":"We identify features by first looking for sets of components, pipes, directives, and services that related to each other. Then if these are not used by other places, it becomes a stronger case for a feature module. Let's examine each.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000078","sortNo":11,"contentFormatId":"1","contentTxt":"Our root module makes sense for our AppComponent and NavComponent. These are needed everywhere in our app visually and for logic. They are also needed as soon as our app is loaded. If we had a lot of declarations that fit this description of NavComponent we might consider creating another feature too, for navigation. But with only one, we can leave it in the root module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000079","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Shared Features</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000080","sortNo":13,"contentFormatId":"1","contentTxt":"Our ButtonComponent and DateComponent are widgets that we will use in many places across our app. We want to make multiple instances of them and for these to be available everywhere. We could leave these in the root module, just like we did for the NavComponent. However, these are slightly different in that we intend to use these many times over, with multiple instances appearing the a component. We very likely will have many other widgets, so this list will grow. These shared components are a logical place to create a SharedModule as a feature module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000081","sortNo":14,"contentFormatId":"1","contentTxt":"Let's create a new @NgModule for this feature.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000082","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000083","sortNo":16,"contentFormatId":"1","contentTxt":"Notice the @SharedModule declares the components and also exports them. Exporting them allows others to use those components, which we intend to do in our app's templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000084","sortNo":17,"contentFormatId":"1","contentTxt":"We modify the root module to no longer declare these shared components and instead we import the SharedModule. This becomes very useful when our app grows to have 5, 10 or more shared components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000085","sortNo":18,"contentFormatId":"1","contentTxt":"Our components in the root module can still use DateComponent and ButtonComponent in their templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000086","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000087","sortNo":20,"contentFormatId":"1","contentTxt":"<strong>Characters Feature</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000088","sortNo":21,"contentFormatId":"1","contentTxt":"We have another opportunity for creating a feature by grouping the characters. It is likely we will have more than two components plus some pipes or directives too. Sometimes in our apps we'll identify these features are areas of an app where we route to. This is a very discrete feature area that we'll make into a CharactersModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000089","sortNo":22,"contentFormatId":"1","contentTxt":"We already had routing for our characters in our root module's app.routing.ts. Let's move that to our new CharactersModule. We'll create a folder for our feature module and a new file app/characters/characters.routing.ts. We'll also remove these routes from the app.routing.ts. Effectively, we're just moving the route setup for this feature area where it belongs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000090","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000091","sortNo":24,"contentFormatId":"1","contentTxt":"Notice we use the forChild() function here and not the forRoot(). When we create feature modules, we always use forChild() as the forRoot() function is reserved for the app's root module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000092","sortNo":25,"contentFormatId":"1","contentTxt":"Now that we moved routing, let's create the feature module in app/characters/characters.module.ts. Notice it is pretty small as it imports the CharactersRoutingModule routing module we just created and declares the routedComponents. These are just a convention I like to use to grab a set of the routed components, instead of having to re-import each component, one by one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000093","sortNo":26,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000094","sortNo":27,"contentFormatId":"1","contentTxt":"Our character feature's component want to use the shared features including the ButtonComponent. Modules do no inherit each other, so even though the CharactersModule is going to be imported by the AppModule (which imports the SharedModule already), the CharactersModule cannot access the shared features ... unless we import SharedModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000095","sortNo":28,"contentFormatId":"1","contentTxt":"Don't worry though, if we forget to import the SharedModule Angular will throw an error telling us it does not recognize the ButtonComponent's template (e.g. my-button) when it sees it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000096","sortNo":29,"contentFormatId":"1","contentTxt":"Now we refactor our app's root module to import the feature and we remove the individual declarations of its components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000097","sortNo":30,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000098","sortNo":31,"contentFormatId":"1","contentTxt":"<strong>Feature Module Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000099","sortNo":32,"contentFormatId":"1","contentTxt":"Our app needs have changed a little and we need a service to gather a list of characters and get a single character for the CharacterListComponent and CharactersDetailComponent. We have to decide which module to put the service and where to provide it. Let's think about how we should approach this.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000100","sortNo":33,"contentFormatId":"1","contentTxt":"We will only use our service by these two components. Therefore, it makes sense that we place our new CharactersService in the CharactersModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000101","sortNo":34,"contentFormatId":"1","contentTxt":"Now we have to decide where to provide the service. We can either provide it in a component or in its module. If we provide it in a component, we'll need to do this in each component that uses it (for our example). Our list and detail components are separated and not in a parent-child association. If we had a parent component (which we could create) such as CharacterLandingComponent that had the other two as children, we could provide it there and the child components would be able to access it. This is due to how Angular's injectors work. Angular injectors are hierarchical and exist at each component level. Clearly, this is a lot to think about :)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000102","sortNo":35,"contentFormatId":"1","contentTxt":"There is an easier way and one with more possibilities.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000103","sortNo":36,"contentFormatId":"1","contentTxt":"If we provide the CharactersService in the CharactersModule, it is accessible to all components in this module. The caveat to be aware of is that there is no module level injector ... but there is one available at the root module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000104","sortNo":37,"contentFormatId":"1","contentTxt":"We'll provide the service in our eagerly module, thus making it available everywhere. We may not use it elsewhere, but it is available if needed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000105","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000106","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000107","sortNo":40,"contentFormatId":"1","contentTxt":"We'll touch on providers more later. There is a great section in the Angular docs about this topic here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000108","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>Next</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000109","sortNo":42,"contentFormatId":"1","contentTxt":"We learned how to make 2 different kinds of feature modules. We created a SharedModule which offers shared features that we'll expect to use in lots of places with multiple instances. This is ideal for widgets or pipes. We also created a feature module for characters, which we route to and eagerly load.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201609220000000110","sortNo":43,"contentFormatId":"1","contentTxt":"In the upcoming posts we'll explore how to reuse services across the app's modules and how to lazily load our modules.","contentBinary":"","contentPoster":"","contentUrl":null}]
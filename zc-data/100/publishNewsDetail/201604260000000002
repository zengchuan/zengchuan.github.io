[{"id":"201604260000000028","sortNo":1,"contentFormatId":"1","contentTxt":"In part 1 of this series we defined a QuoteComponent that displays a random quote on a web page. We showed how to use Angular 2's testing utilities to mock out QuoteService and test the QuoteComponent's presentation logic in isolation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000029","sortNo":2,"contentFormatId":"1","contentTxt":"In this post, I'll do the opposite: I'll isolate the QuoteService and show how to unit test the code at your application's service level. By the end of this post, you should have all the tools you need to test a non-trivial Angular 2 application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000030","sortNo":3,"contentFormatId":"1","contentTxt":"For reference, here's the component again:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000031","sortNo":4,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000032","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Testing QuoteService</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000033","sortNo":6,"contentFormatId":"1","contentTxt":"Consider the following implementation of QuoteService:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000034","sortNo":7,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000035","sortNo":8,"contentFormatId":"1","contentTxt":"This service uses a random number generator to pick a quote at random from a hard-coded list in quote.data.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000036","sortNo":9,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000037","sortNo":10,"contentFormatId":"1","contentTxt":"How would we get this under test?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000038","sortNo":11,"contentFormatId":"1","contentTxt":"<strong>Angular 2 Testing Tools</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000039","sortNo":12,"contentFormatId":"1","contentTxt":"First, we can access the tools provided by the angular2/testing package:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000040","sortNo":13,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000041","sortNo":14,"contentFormatId":"1","contentTxt":"In effect, Angular 2 gives us a modified version of the excellent jasmine testing framework.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000042","sortNo":15,"contentFormatId":"1","contentTxt":"You should remember these tools from part 1 of this series, but briefly:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000043","sortNo":16,"contentFormatId":"1","contentTxt":"1. describe: the describe function creates a set of related tests.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000044","sortNo":17,"contentFormatId":"1","contentTxt":"2. it: the it function defines a particular unit test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000045","sortNo":18,"contentFormatId":"1","contentTxt":"3. inject allows you to invoke Angular 2's dependency injector to instantiate the services being used.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000046","sortNo":19,"contentFormatId":"1","contentTxt":"4. beforeEachProviders allows you to override the dependency injector to supply stubs or mocks for the parts of the system you're not explicitly testing right now.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000047","sortNo":20,"contentFormatId":"1","contentTxt":"5. expect allows us to check that conditions have been met, throwing errors if they have not been.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000048","sortNo":21,"contentFormatId":"1","contentTxt":"<strong>Isolate the Unit under Test</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000049","sortNo":22,"contentFormatId":"1","contentTxt":"Next, we need to isolate the unit under test (in this case QuoteService). We'll do this by replacing RandomNumberService and QUOTE_DATA with stubs or mocks.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000050","sortNo":23,"contentFormatId":"1","contentTxt":"Once again, we use our old friends provide and beforeEachProviders to do this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000051","sortNo":24,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000052","sortNo":25,"contentFormatId":"1","contentTxt":"Since QUOTE_DATA is just a list of hard-coded records, we can replace it with some data that's tailored to the behaviour we want to test. This is done using provide's useValue option: whenever Angular 2's dependency injector is asked for QUOTE_DATA, it will use our test data instead.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000053","sortNo":26,"contentFormatId":"1","contentTxt":"The RandomNumberService, on the other hand, can be stubbed out with an empty class that we'll manipulate later. Think of this as partial typings for the bits of RandomNumberService that we care about in this test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000054","sortNo":27,"contentFormatId":"1","contentTxt":"Unlike a mock, a stub does not result in in complex mocking logic being shared across different test suites; we'll leave it up to each specific test to supply the relevant implementation of this simple service.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000055","sortNo":28,"contentFormatId":"1","contentTxt":"Whether to use a stub or a mock is largely a matter of taste; I tend to prefer stubs where possible because they decouple tests from each other and are in many cases easier to reason about.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000056","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>Set up an Actual Test</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000057","sortNo":30,"contentFormatId":"1","contentTxt":"Now that we've set up our test environment, we can write an actual test.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000058","sortNo":31,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000059","sortNo":32,"contentFormatId":"1","contentTxt":"This is a good example of stub-based unit testing: I'm beginning with an empty stub for RandomNumberService and swapping in the minimum implementation for a meaningful test. This way I don't have to maintain a complex mock object in addition to the real one.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000060","sortNo":33,"contentFormatId":"1","contentTxt":"I verify behaviour using Jasmine's createSpy, which creates an instrumented, fake implementation of the pick method.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000061","sortNo":34,"contentFormatId":"1","contentTxt":"I personally find that this is a very clean, readable, and flexible testing style.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000062","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>Putting it all Together</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000063","sortNo":36,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000064","sortNo":37,"contentFormatId":"1","contentTxt":"<strong>Asynchronous Service Calls</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000065","sortNo":38,"contentFormatId":"1","contentTxt":"The example above is nice and simple. However in the real world, we're more likely to get the quote data from a remote API than from a hard-coded list.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000066","sortNo":39,"contentFormatId":"1","contentTxt":"Let's walk through the same exercise, but this time with an implementation that gets quotes from http://quotesondesign.com/.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000067","sortNo":40,"contentFormatId":"1","contentTxt":"First we'll beef up the QuoteComponent to handle async data using Observables and the built-in asyncPipe from Angular 2:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000068","sortNo":41,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000069","sortNo":42,"contentFormatId":"1","contentTxt":"Next, we'll provide an HTTP-capable implementation of quote service:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000070","sortNo":43,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000071","sortNo":44,"contentFormatId":"1","contentTxt":"This implementation is straightforward: it uses Angular 2's http service to hit QuotesOnDesign's JSON endpoint, and then converts the response data to the IQuote interface used by our QuoteComponent.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000072","sortNo":45,"contentFormatId":"1","contentTxt":"However, this example has two aspects that complicate testing:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000073","sortNo":46,"contentFormatId":"1","contentTxt":"1. It returns data asynchronously using an Observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000074","sortNo":47,"contentFormatId":"1","contentTxt":"2. It relies on Angular 2's HTTP infrastructure, which is difficult to isolate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000075","sortNo":48,"contentFormatId":"1","contentTxt":"Fortunately, Angular 2 gives us the tools to handle these cases as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000076","sortNo":49,"contentFormatId":"1","contentTxt":"<strong>Handling Asynchronicity</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000077","sortNo":50,"contentFormatId":"1","contentTxt":"We'll import a new helper from angular2/testing called fakeAsync. This is a simple wrapper function that places your test in the \"async zone\": this causes asynchronous code to run in a synchronous way via the magic of zone.js.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000078","sortNo":51,"contentFormatId":"1","contentTxt":"<strong>Mocking out the HTTP Backend</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000079","sortNo":52,"contentFormatId":"1","contentTxt":"The new implementation of QuoteService relies on the http service provided by Angular 2. However, because this is a unit test, we don't want to actually make HTTP calls - we need to be able to control the environment in which our tests run.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000080","sortNo":53,"contentFormatId":"1","contentTxt":"We could use a stub implementation of HTTP as we did above; and in some cases that's appropriate. However HTTP is a fairly complex interface. In this case, it's easier to use some mocks that Angular 2 has already made available to us:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000081","sortNo":54,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000082","sortNo":55,"contentFormatId":"1","contentTxt":"Supplying these to Angular 2's dependency injector allows us to intercept outgoing HTTP calls and perform expectations them:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000083","sortNo":56,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000084","sortNo":57,"contentFormatId":"1","contentTxt":"It also allows us to supply controlled response data:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000085","sortNo":58,"contentFormatId":"2","contentTxt":null,"contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000086","sortNo":59,"contentFormatId":"1","contentTxt":"<strong>Wrap-up</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000087","sortNo":60,"contentFormatId":"1","contentTxt":"Angular 2 provides a great set of tools for testing everything from your UI components down to your HTTP services. Between parts one and two of this series, you should be equipped to handle most scenarios you may encounter when unit testing your Angular 2 apps.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000088","sortNo":61,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201604260000000089","sortNo":62,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/rangle/ng2-unit-testing-blog\">https://github.com/rangle/ng2-unit-testing-blog</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
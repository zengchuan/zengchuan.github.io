[{"id":"201612070000000001","sortNo":1,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000002","sortNo":2,"contentFormatId":"1","contentTxt":"I’ve heard a lot of people express frustration with building forms in Angular 2. I think in large part this derives from bad experiences with FormBuilder, FormGroup and FormControl. This blog post explores a new way of building complex forms in Angular 2, using ngModel, the ControlValueAccessor contract, and some clever validation code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000003","sortNo":3,"contentFormatId":"1","contentTxt":"<strong>Suppositions</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000004","sortNo":4,"contentFormatId":"1","contentTxt":"1. You are building complex forms that have custom validators, styling, and behaviours that make using plain <input> tags all over the place unsuitable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000005","sortNo":5,"contentFormatId":"1","contentTxt":"2. You therefore want custom form input controls that bind to ngModel and have complex validation behaviour","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000006","sortNo":6,"contentFormatId":"1","contentTxt":"3. You dislike FormBuiler, FormControl and FormGroup and find that they reduce maintainability and understandability of the code: you want to define your forms in your template only, not in code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000007","sortNo":7,"contentFormatId":"1","contentTxt":"4. You perhaps think that ngModel is only suitable for binding plain jane <input> controls to values, and that ngModel does not work for custom form components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000008","sortNo":8,"contentFormatId":"1","contentTxt":"ngModel in fact can be used to build great, template-driven forms that allow you put more focus on your data model and less focus on creating the right FormBuilder structures. You can have custom components and complex validation, too.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000009","sortNo":9,"contentFormatId":"1","contentTxt":"Therefore, we are going to build some form input controls that behave like core input elements like <select>, <input> and <textarea>, and in fact look like normal base input elements as far as the Angular forms implementation is concerned. If we follow this contract correctly, we will be able to apply any validators or bindings that you can apply to a base input control like <input>. To Angular, there will be no difference whatsoever between the standard <input> control and our custom <form-text> control. The difference will be that our custom input will also display inline validation failure messages, and will dynamically style itself based on whether the value inside is valid or invalid (i.e. we will set a red border on ourselves when we fail to validate).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000010","sortNo":10,"contentFormatId":"1","contentTxt":"Standard form element usage:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000011","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000012","sortNo":12,"contentFormatId":"1","contentTxt":"Our custom form element component usage:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000013","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000014","sortNo":14,"contentFormatId":"1","contentTxt":"But our control will, as mentioned, also render inline validation failure messages, whereas the standard <input> control will not.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000015","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>To summarize:</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000016","sortNo":16,"contentFormatId":"1","contentTxt":"1. We are going to build a custom form input with complex validators and two-way data binding with ngModel.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000017","sortNo":17,"contentFormatId":"1","contentTxt":"2. Our controls will not know ahead of time what validators will be applied to them, but they will style themselves with red borders if they fail to validate. Validators will be specified at the place that you use the control, not inside of the control itself. They will be queried through the hierarchical dependency injection system. We will ask our parent scope for them through @Inject(), not @Input().","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000018","sortNo":18,"contentFormatId":"1","contentTxt":"3. Our controls will be good citizens and will output data that is appropriate to the element. For example, a checkbox control should supply booleans to its parent, and a text input will supply strings.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000019","sortNo":19,"contentFormatId":"1","contentTxt":"<strong>Getting started with the implementation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000020","sortNo":20,"contentFormatId":"1","contentTxt":"Let’s lay out what our requirements are first. We want custom form components with clean styles and advanced functionality like:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000021","sortNo":21,"contentFormatId":"1","contentTxt":"1. The ability to apply multiple arbitrary validators to the same control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000022","sortNo":22,"contentFormatId":"1","contentTxt":"2. Red outlines and warnings when the inputs do not validate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000023","sortNo":23,"contentFormatId":"1","contentTxt":"3. Detailed list of validation errors that notify the user what is wrong with their inputs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000024","sortNo":24,"contentFormatId":"1","contentTxt":"4. Reusability in a variety of contexts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000025","sortNo":25,"contentFormatId":"1","contentTxt":"5. A single source of form structure information with no duplication (everything about the forms should be in the template, not the TypeScript code).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000026","sortNo":26,"contentFormatId":"1","contentTxt":"Our two form controls, a text input and a dropdown control, will come together to look like the image below. (The complete source code and unit tests are available at this link.)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000027","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000028","sortNo":28,"contentFormatId":"1","contentTxt":"<strong>A Form Container Element</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000029","sortNo":29,"contentFormatId":"1","contentTxt":"First, let’s create a form context which will be responsible for aggregating our form inputs into a single form instance (NgForm). When we call form.valid on this instance, it will give us the aggregate validity state of all its inputs. When we call form.value, it will collect values from every input in the form and give it back to us in the form of a simple object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000030","sortNo":30,"contentFormatId":"1","contentTxt":"The beauty of this is that we never have to tell NgForm what our inputs are. It simply will query the dependency injector and retrieve all instances of NG_VALUE_ACCESSOR and add them to our form control. Then it will automatically create and maintain a FormGroup object for us! We never have to do new FormGroup({}) at any time, but we still have access to the form property of our NgForm instance. NgForm::form is a reference to a FormGroup object that we can write code around. Beautiful!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000031","sortNo":31,"contentFormatId":"1","contentTxt":"Our custom components will have full and complete integration with the Angular forms library, and will be indistinguishable from standard basic <input> elements, at least as far as @angular/forms is concerned.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000032","sortNo":32,"contentFormatId":"1","contentTxt":"There are a couple other things we are going to manage at the <form> level:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000033","sortNo":33,"contentFormatId":"1","contentTxt":"1. We want to disable our “Submit” button if the form fails validation.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000034","sortNo":34,"contentFormatId":"1","contentTxt":"2. We want to have a form-level validation state that tells us if all of the inputs in our control are currently valid. This part will be mostly taken care of by the Angular forms library implementation, but we will at least demonstrate how to use it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000035","sortNo":35,"contentFormatId":"1","contentTxt":"3. Since we are building our form template, let’s also use this opportunity to determine what we want our contract to be for our form input controls. I often find that trying to create some code that uses my component before it has even been defined can clarify my thinking about what I want my component contract to look like. I create the ideal usage scenario of my component, and then I implement the component in such a way that it will meet that contract. This ensures that my focus remains on creating a good, sensical contract for my component, instead of focusing on the implementation details and creating a component contract that ends up being difficult to use but easy to implement.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000036","sortNo":36,"contentFormatId":"1","contentTxt":"So let’s create our entire form container now, along with usages of our nonexistent input components:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000037","sortNo":37,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000038","sortNo":38,"contentFormatId":"1","contentTxt":"First, we have the <form> element, which is the container element of all of our form inputs. The Angular forms library is smart enough to understand that all <form> elements should have an NgForm directive attached to them. It will also collect all of the input controls inside of that form and associate them with the automatically-managed FormGroup object on NgForm, such that when you ask for form.value it will give you an object that is the same shape of your form (using name attributes to determine property names). In our case, form.value will provide an object that looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000039","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000040","sortNo":40,"contentFormatId":"1","contentTxt":"This object is a great representation of our data, extracted right out of the NgForm object. But the best thing about this form template is that it requires almost no TypeScript code in order to implement it. Our entire form is delineated using template components, and even the values we get back are constructed using the shape of the form in the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000041","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>A couple more points</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000042","sortNo":42,"contentFormatId":"1","contentTxt":"Notice the required attribute on both of our form inputs. required is a basic HTML5 form validation attribute which Angular also understands. We are essentially saying that both of our inputs must have input or selection from the user in order to be considered valid. In the first input, we also use a custom validator, hexadecimal, which will validate that the user input is a valid base-16 number (af02c3f, for example). We will explain more about the custom validator directive implementation later.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000043","sortNo":43,"contentFormatId":"1","contentTxt":"In the case of our form-select input, we are projecting the options into that control from the actual usage of the control. This allows us to avoid a nasty hack like using @Input() to provide an array of all of the possible options the user can select. We just ask our parent to inject the options into form-select, and it will render them in the correct spot using <ng-content>.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000044","sortNo":44,"contentFormatId":"1","contentTxt":"Now that we have an idea of how we want to use our controls and validators, let’s start figuring out how to implement them.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000045","sortNo":45,"contentFormatId":"1","contentTxt":"<strong>NgModule</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000046","sortNo":46,"contentFormatId":"1","contentTxt":"The first thing we need to do is ensure that FormsModule is part of our imports list in our @NgModule() declaration. This ensures that the various form-related directives will be available to our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000047","sortNo":47,"contentFormatId":"1","contentTxt":"<strong>ValidationComponent</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000048","sortNo":48,"contentFormatId":"1","contentTxt":"Next let’s build a validation failure component, which will be shared amongst all of our form inputs and will be used when we have some validation failures. This component will display actual validation failure messages inline, next to the input elements themselves. We’ll call it ValidationComponent. It will print things like Please enter a value next to the control if it is empty. It will be a basic dumb component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000049","sortNo":49,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000050","sortNo":50,"contentFormatId":"1","contentTxt":"Perfect. We will come back and style this component a bit later, but this will do for now.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000051","sortNo":51,"contentFormatId":"1","contentTxt":"<strong>Implementing our first form control</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000052","sortNo":52,"contentFormatId":"1","contentTxt":"Next let us begin with our text input component, form-text (or FormTextComponent). The first thing we have to think about is the fact that our component must integrate with ngModel. Why? Because we want to be able to bind the input value of our control to a two-way ngModel directive, the same way we would bind a regular <input> element. How do we do this? In a word: ControlValueAccessor. Our component must implement the ControlValueAccessor contract. With that in mind, let us take a look at our basic component definition:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000053","sortNo":53,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000054","sortNo":54,"contentFormatId":"1","contentTxt":"1. We are telling the dependency injector that we implement ControlValueAccessor, (NG_VALUE_ACCESSOR), but we do not actually implement it. We have to add implementations for those methods and abstract them into something we can share amongst all form components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000055","sortNo":55,"contentFormatId":"1","contentTxt":"2. There is no validation happening on our input control.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000056","sortNo":56,"contentFormatId":"1","contentTxt":"So we need to remedy these problems before we can move on. The first thing we need to do is implement the ControlValueAccessor interface. But we are going to be implementing this interface on all of our input elements, so rather than copy and paste the same code into all of our form elements, we will create an abstract base class that manages the ControlValueAccessor code. We can then simply extends that base class and make use of it in all our form elements.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000057","sortNo":57,"contentFormatId":"1","contentTxt":"<strong>Common ValueAccessor abstract base</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000058","sortNo":58,"contentFormatId":"1","contentTxt":"Let’s implement this base class. First let’s take a look at ControlValueAccessor:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000059","sortNo":59,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000060","sortNo":60,"contentFormatId":"1","contentTxt":"In order to implement this interface, we are going to need to have implementations for each of these methods. But before we do, let’s understand what’s going on here. writeValue is used to update the value of our control, but it takes an argument of type any. In fact almost all of these methods just accept arguments of type any and therefore it’s a poor interface declaration. But we know what type of arguments these functions are going to take, so let’s use real type declarations in our implementation, with the magic of a TypeScript generic class definition.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000061","sortNo":61,"contentFormatId":"1","contentTxt":"The second thing to understand is that our form elements are going to bind to ngModel, and should bind values that are appropriate for the control itself. For example, a checkbox control ought to provide a boolean value tongModel (checked or not checked). A textbox control should provide a string value (the text). A number control should provide a number object to ngModel. A radio group should provide an enum type to ngModel. This ensures that the form values we get back from our controls are appropriate to the data types they are working with. Therefore our first abstract base class will be a generic <T> class that will accept a type argument that matches the data type that class will provide to ngModel. It will look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000062","sortNo":62,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000063","sortNo":63,"contentFormatId":"1","contentTxt":"We need a couple more things: validate method, and invalid and failures methods. These methods need to be implemented in such a way that they will work for any type of input control. In theory, you could also add this code to ValueAccessorBase<T>, but I chose to create another abstract base class called ElementBase<T> which extends ValueAccessorBase<T>. We will inherit our various input controls from ElementBase<T>. It is responsible for supplying validity state and methods to the derived component, whereas ValueAccessorBase is responsible for implementing the control value accessor pattern from Angular. Now once we create a control and use extends ElementBase<T>, we already have all of the state information that we need in order to render ourselves. This allows us to have zero implementation code in the actual control implementations themselves -- just templates and a constructor. Therefore our controls will be dead simple to implement and will all share the same logic relating to model changes and validity. Each element will need to know its validity state for rendering purposes, so it makes sense to put this functionality into an abstract class that can be shared amongst all form inputs component implementations.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000064","sortNo":64,"contentFormatId":"1","contentTxt":"<strong>To summarize:</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000065","sortNo":65,"contentFormatId":"1","contentTxt":"1. ValueAccessor<T>: Implements the Control Value Accessor pattern from Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000066","sortNo":66,"contentFormatId":"1","contentTxt":"2. ElementBase<T> extends ValueAccessor<T>:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000067","sortNo":67,"contentFormatId":"1","contentTxt":"(1) Provides observable values to its parent about its validity state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000068","sortNo":68,"contentFormatId":"1","contentTxt":"(2) Provides a validate method which can also be used in the control and which works off of validators injected through hierarchical dependency injection (eg. a required or minlength directive).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000069","sortNo":69,"contentFormatId":"1","contentTxt":"3. Actual @Component for input controls will extend ElementBase<T> where T is the type of data that control deals with (string for text box, boolean for checkbox, etc).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000070","sortNo":70,"contentFormatId":"1","contentTxt":"Let’s break down the ElementBase<T> implementation itself:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000071","sortNo":71,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000072","sortNo":72,"contentFormatId":"1","contentTxt":"Validate() returns an Observable of an object containing keys for any failed validators invalid is an Observable<boolean> which will be true when any of the validators attached to the control through the dependency injector are failing failures is an Observable<ValidationResult> which is an object containing a property and a message (or a boolean, for Angular-supplied validators) for each validator that is failing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000073","sortNo":73,"contentFormatId":"1","contentTxt":"With that done, we will inherit from this class in our FormTextComponent and bind our internal ngModel. Not the ngModel which the control itself will bind to in usages of <form-text>, but the internal ngModel binding we will use to bind our <input> control to our internal value state. Our internal input control, <input>, will be bound to this ngModel. value itself is defined as a getter/setter on the ValueAccessor<T> base, and it will call Angular callback functions when value is changed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000074","sortNo":74,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000075","sortNo":75,"contentFormatId":"1","contentTxt":"And:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000076","sortNo":76,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000077","sortNo":77,"contentFormatId":"1","contentTxt":"Now <form-text> can be bound to ngModel through the magic of ControlValueAccessor, and which uses ngModel internally to manage its own state. So this usage has become valid:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000078","sortNo":78,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000079","sortNo":79,"contentFormatId":"1","contentTxt":"But we still have not implemented any validation. We are calling it from ElementBase but it is not defined yet. Let’s do that. It’s just a free-standing function which itself returns a function that accepts a control argument. That nested function is responsible for doing the ultimate validation of the control. We therefore need a validate method of this signature:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000080","sortNo":80,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000081","sortNo":81,"contentFormatId":"1","contentTxt":"It will be called like this when we need to validate our controls, and it will be given validators that we acquired from the hierarchical dependency injector (i.e., we got them from the usage of our component):","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000082","sortNo":82,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000083","sortNo":83,"contentFormatId":"1","contentTxt":"Our validate method will be implemented like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000084","sortNo":84,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000085","sortNo":85,"contentFormatId":"1","contentTxt":"Essentially what we are doing here is we are accepting validators of all shapes and sizes, and producing a single asynchronous validator function. We can accept:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000086","sortNo":86,"contentFormatId":"1","contentTxt":"1. Synchronous validator objects or functions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000087","sortNo":87,"contentFormatId":"1","contentTxt":"2. Asynchronous validator objects or functions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000088","sortNo":88,"contentFormatId":"1","contentTxt":"And we will always produce an AsyncValidatorFn which we can use to collect the results of any and all validators attached to our inputs, and produce a single resulting validation object containing all validation failures in one place.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000089","sortNo":89,"contentFormatId":"1","contentTxt":"We also need the messages function below because internally, Angular validators only return boolean values, not error messages. Our validators will always return error messages, but for the built in validator directives, we need to translate them into messages ourselves. Your code should go the extra distance to produce good validation messages, unlike mine above.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000090","sortNo":90,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000091","sortNo":91,"contentFormatId":"1","contentTxt":"Let’s edit our FormTextComponent control and add support for validation. First we need to add a constructor which will query the dependency injector for all synchronous and asynchronous validators associated with our component. Therefore when someone attaches eg. required and minlength directives to our <form-text> control, we will get a copy of their instances in our control constructor. Then we can use it to determine our own validity state.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000092","sortNo":92,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000093","sortNo":93,"contentFormatId":"1","contentTxt":"Now let’s edit our template and add a style class when our component is not validating (invalid) and an instance of the <validation-messages> component we created above, which will show all validation failure messages:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000094","sortNo":94,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000095","sortNo":95,"contentFormatId":"1","contentTxt":"In a real application, you would also add model.control.touched and make it short-circuit the invalid logic in the event the control was untouched. In essence, we would not want to show validation failures until the user has interacted with the control in some way (typically by focusing the control). This way we would not show the user a big wall of red messages as soon as they load the form. But for the purposes of our example app we can skip that part.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000096","sortNo":96,"contentFormatId":"1","contentTxt":"To match those classes, we must add a style class (invalid) to our component as well:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000097","sortNo":97,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000098","sortNo":98,"contentFormatId":"1","contentTxt":"Now we have a form control which is able to accept validators, but only the usage of our component will specify the validators: the control itself doesn’t have to know about them ahead of time. For example we may want to use a required validator:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000099","sortNo":99,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000100","sortNo":100,"contentFormatId":"1","contentTxt":"<strong>Custom validator implementation</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000101","sortNo":101,"contentFormatId":"1","contentTxt":"Now that our control is able to handle validation gracefully, I will show you how to implement a custom validator directive. It’s very simple! The recipe looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000102","sortNo":102,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000103","sortNo":103,"contentFormatId":"1","contentTxt":"Note that we are returning a validation failure message, not a boolean. This allows us to display the message inside our form element - even though we don’t know ahead of time what that validator or its message will be.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000104","sortNo":104,"contentFormatId":"1","contentTxt":"<strong>Now that we have all that done, creating a new form input component is dead simple</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000105","sortNo":105,"contentFormatId":"1","contentTxt":"For example, here is a form-select component. It’s defined in a single file and is very easy to understand:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000106","sortNo":106,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000107","sortNo":107,"contentFormatId":"1","contentTxt":"That’s it! Now you have a great dropdown control you can use all over your application. It would be extremely simple to apply this style of component to also create radio groups, checkboxes, date pickers, payment forms -- just about anything you could think of. But first, maybe take a look at the existing code repository below and make sure you understand the various bits of code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000108","sortNo":108,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201612070000000109","sortNo":109,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/clbond/form-example\">https://github.com/clbond/form-example</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
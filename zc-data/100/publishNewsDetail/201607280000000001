[{"id":"201607280000000001","sortNo":1,"contentFormatId":"1","contentTxt":"<strong>Basic Routing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000002","sortNo":2,"contentFormatId":"1","contentTxt":"Router enables navigation from one view to another based on user interactions with the application.\nFollowing are the steps in implementing basic routing in Angular 2.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000003","sortNo":3,"contentFormatId":"1","contentTxt":"1. Check if you are pointing to correct/latest routing dependencies in package.json","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000004","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000005","sortNo":5,"contentFormatId":"1","contentTxt":"2. Define the route as per it's class definition","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000006","sortNo":6,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000007","sortNo":7,"contentFormatId":"1","contentTxt":"In a routes file (route/routes.ts), import all the components which you need to configure for different routing paths. Empty path means that view is loaded by default. \":\" in the path indicates dynamic parameter passed to the loaded component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000008","sortNo":8,"contentFormatId":"1","contentTxt":"Routes are made available to application via dependency injection. ProviderRouter method is called with RouterConfig as parameter so that it can be injected to the components for calling routing specific tasks.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000009","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000010","sortNo":10,"contentFormatId":"1","contentTxt":"3. Bootstrap the route provider.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000011","sortNo":11,"contentFormatId":"1","contentTxt":"In your main.ts (It can be any name. basically, it should your main file defined in systemjs.config)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000012","sortNo":12,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000013","sortNo":13,"contentFormatId":"1","contentTxt":"4. Load/display the router components based on path accessed. directive is used to tell angular where to load the component. To use import the ROUTER_DIRECTIVES.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000014","sortNo":14,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000015","sortNo":15,"contentFormatId":"1","contentTxt":"5. Link the other routes. By default, RouterOutlet will load the component for which empty path is specified in the RouterConfig. RouterLink directive is used with html anchor tag to load the components attached to routes. RouterLink generates the href attribute which is used to generate links. For Ex:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000016","sortNo":16,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000017","sortNo":17,"contentFormatId":"1","contentTxt":"Now, we are good with routing to static path. RouterLink support dynamic path also by passing extra parameters along with the path.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000018","sortNo":18,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000019","sortNo":19,"contentFormatId":"1","contentTxt":"RouterLink takes an array where first element is the path for routing and subsequent elements are for the dynamic routing parameters.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000020","sortNo":20,"contentFormatId":"1","contentTxt":"<strong>Child Routes</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000021","sortNo":21,"contentFormatId":"1","contentTxt":"Sometimes it makes sense to nest view's or routes within one another. For example on the dashboard you want several sub views, similar to tabs but implemented via the routing system, to show the users' projects, contacts, messages ets. In order to support such scenarios the router allows us to define child routes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000022","sortNo":22,"contentFormatId":"1","contentTxt":"First we adjust our RouterConfig from above and add the child routes:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000023","sortNo":23,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000024","sortNo":24,"contentFormatId":"1","contentTxt":"Now that we have our child routes defined we have to make sure those child routes can be displayed within our DashboardComponent, since that's where we have added the childs to. Previously we have learned that the components are displayed in a <router-outlet></router-outlet> tag. Similar we declare another RouterOutlet in the DashboardComponent:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000025","sortNo":25,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000026","sortNo":26,"contentFormatId":"1","contentTxt":"As you can see, we have added another RouterOutlet in which the child routes will be displayed. Usually the route with an empty path will be shown, however, we set up a redirect to the projects route, because we want that to be shown immediately when the dashboard route is loaded. That being said, we need an empty route, otherwise you'll get an error like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000027","sortNo":27,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000028","sortNo":28,"contentFormatId":"1","contentTxt":"So by adding the empty route, meaning a route with an empty path, we have defined an entry point for the router.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000029","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>ResolveData</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000030","sortNo":30,"contentFormatId":"1","contentTxt":"This example will show you how you can resolve data fetched from a service before rendering your application's view.(Uses angular/router 3.0.0-beta.2 at the time of writing)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000031","sortNo":31,"contentFormatId":"1","contentTxt":"users.service.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000032","sortNo":32,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000033","sortNo":33,"contentFormatId":"1","contentTxt":"users.resolver.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000034","sortNo":34,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000035","sortNo":35,"contentFormatId":"1","contentTxt":"users.component.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000036","sortNo":36,"contentFormatId":"1","contentTxt":"This is a page component with a list of all users. It will work similarly for User detail page component, replace data.users with data.user or whatever key defined in app.routes.ts(see below)","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000037","sortNo":37,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000038","sortNo":38,"contentFormatId":"1","contentTxt":"app.routes.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000039","sortNo":39,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000040","sortNo":40,"contentFormatId":"1","contentTxt":"app.resolver.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000041","sortNo":41,"contentFormatId":"1","contentTxt":"Optionally bundle multiple resolvers together.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000042","sortNo":42,"contentFormatId":"1","contentTxt":"IMPORTANT: Services used in resolver must be imported first or you will get a 'No provider for ..Resolver error'. Remember that these services will be available globally and you will not need to declare them in any component's providers anymore. Be sure to unsubscribe from any subscription to prevent memory leak.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000043","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000044","sortNo":44,"contentFormatId":"1","contentTxt":"main.browser.ts","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000045","sortNo":45,"contentFormatId":"1","contentTxt":"Resolvers have to be injected during bootstrapping.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201607280000000046","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null}]
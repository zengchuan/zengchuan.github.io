[{"id":"201704010000000067","sortNo":1,"contentFormatId":"1","contentTxt":"In this article, we'll explore managing state with an immutable data store in an Angular application using ngrx/store: reactive Redux for Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000068","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Managing State in Angular Apps</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000069","sortNo":3,"contentFormatId":"1","contentTxt":"State management in large, complex applications has been a headache plaguing AngularJS / Angular developers over the last few years. In AngularJS (version 1.x), state management is often addressed using a confusing mixture of services, events, and $rootScope. In Angular (versions 2+), component interaction is cleaner but can still be quite involved, encompassing many different approaches depending on the desired direction of the flow of data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000070","sortNo":4,"contentFormatId":"1","contentTxt":"Some developers are using Redux with AngularJS or Angular. Redux is a \"predictable state container for JavaScript apps\" and supports a single, immutable data store. Redux is best-known for its use with React, but it can be utilized with any view library. Egghead.io hosts an excellent free video series on Redux from its creator, Dan Abramov.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000071","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Introducing Ngrx/Store</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000072","sortNo":6,"contentFormatId":"1","contentTxt":"For our Angular application, we're going to use ngrx/store rather than Redux. What is the relationship between Redux and ngrx/store and why would we prefer one over the other?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000073","sortNo":7,"contentFormatId":"1","contentTxt":"<strong>Relationship to Redux</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000074","sortNo":8,"contentFormatId":"1","contentTxt":"Ngrx/store is an \"RxJS powered state management library for Angular applications, inspired by Redux\", authored by Rob Wormald, an Angular Developer Advocate. It shares Redux's core fundamentals but uses RxJS, which implements the observer pattern in JS and comes packaged with Angular. It follows the core principles of Redux and is specifically designed for Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000075","sortNo":9,"contentFormatId":"1","contentTxt":"Fundamental Tenets of Ngrx/Store","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000076","sortNo":10,"contentFormatId":"1","contentTxt":"<ul>\n<li>State is a single, immutable data structure.                                                            </li>\n<li>Actions describe state changes.                                                                         </li>\n<li>Pure functions called reducers take the previous state and the next action to compute the new state.    </li>\n<li>State accessed with the Store, an observable of state and an observer of actions.                       </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000077","sortNo":11,"contentFormatId":"1","contentTxt":"Let's break this down. The following is a quick (but important) overview of the basics. We'll go more indepth as we build our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000078","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Actions</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000079","sortNo":13,"contentFormatId":"1","contentTxt":"Actions are information payloads that send data from the application to the reducer, which updates the store. Actions are the only way the store receives data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000080","sortNo":14,"contentFormatId":"1","contentTxt":"In ngrx/store, the Actioninterface looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000081","sortNo":15,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000082","sortNo":16,"contentFormatId":"1","contentTxt":"The type should describe the kind of state change we want. For example, this might be something like 'ADD_TODO' or 'DECREMENT', etc. The payload is the data being sent to the store in order to update it. Actions are dispatched to the store like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000083","sortNo":17,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000084","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Reducers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000085","sortNo":19,"contentFormatId":"1","contentTxt":"Reducers specify how the state changes in response to actions. A reducer is a pure function that describes state mutations in the app by taking the previous state and the dispatched action and returning the next state as a new object, generally using Object.assign and/or spread syntax:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000086","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000087","sortNo":21,"contentFormatId":"1","contentTxt":"It's important to be mindful of purity when writing reducers. Pure functions:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000088","sortNo":22,"contentFormatId":"1","contentTxt":"<ul>\n<li>Do not mutate state outside their scope.              </li>\n<li>Have return values that depend only on their inputs.  </li>\n<li>Given the same input, always return the same output.  </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000089","sortNo":23,"contentFormatId":"1","contentTxt":"You can read more about purity here. It is the responsibility of the developer to ensure purity and state immutability in JavaScript, so make sure to be mindful when writing your reducers.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000090","sortNo":24,"contentFormatId":"1","contentTxt":"<strong>Store</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000091","sortNo":25,"contentFormatId":"1","contentTxt":"The store holds the entire immutable state of the application. The store in ngrx/store is an RxJS observable of state and an observer of actions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000092","sortNo":26,"contentFormatId":"1","contentTxt":"We can use Store to dispatch actions. We can also subscribe to observe and react to state changes over time with Store's select() method, which returns an observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000093","sortNo":27,"contentFormatId":"1","contentTxt":"<strong>Angular With Ngrx/Store: Custom Pet Tags App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000094","sortNo":28,"contentFormatId":"1","contentTxt":"Now that we're familiar with the basics of how ngrx/store works, we're going to build an Angular app that allows users to customize a name tag for their pet. Our app will have the following features:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000095","sortNo":29,"contentFormatId":"1","contentTxt":"<ul>\n<li>Users can choose tag shape, font style, text, and optional extras. </li>\n<li>Users will need to authenticate before creating a tag.             </li>\n<li>Users can see a simple preview of their tag as they build it.      </li>\n<li>When finished, users can create another tag or log out.            </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000096","sortNo":30,"contentFormatId":"1","contentTxt":"We'll create several components to compose a tag builder and a tag preview. We'll create components and routes for logging in, creating a tag, and finishing up. The state of our tag builder app will be managed with ngrx/store. We'll also use Auth0and route guards to protect our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000097","sortNo":31,"contentFormatId":"1","contentTxt":"When finished, our custom pet tags app will looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000098","sortNo":32,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000099","sortNo":33,"contentFormatId":"1","contentTxt":"Let's get started!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000100","sortNo":34,"contentFormatId":"1","contentTxt":"<strong>Angular App Setup</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000101","sortNo":35,"contentFormatId":"1","contentTxt":"<strong>Install Dependencies</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000102","sortNo":36,"contentFormatId":"1","contentTxt":"Make sure you have Node.js with npm installed (LTS download recommended).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000103","sortNo":37,"contentFormatId":"1","contentTxt":"Next, we'll install the Angular CLI for scaffolding and serving our app. Run the following command to install angular-cli globally:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000104","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000105","sortNo":39,"contentFormatId":"1","contentTxt":"This will install the latest version of the Angular CLI tool. Keep in mind that the Angular CLI just came out of beta and is now into release candidates at the time of writing. Updates are still to be expected. If you need to update your Angular CLI installation at any time, refer to the Angular CLI GitHub README here.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000106","sortNo":40,"contentFormatId":"1","contentTxt":"<strong>Create an Angular App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000107","sortNo":41,"contentFormatId":"1","contentTxt":"In a directory of your choosing, open a command prompt and create a new Angular app project:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000108","sortNo":42,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000109","sortNo":43,"contentFormatId":"1","contentTxt":"Navigate into your new /pet-tags-ngrx folder and install the necessary packages to support ngrx/store, like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000110","sortNo":44,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000111","sortNo":45,"contentFormatId":"1","contentTxt":"We now have everything we need to get started on our app.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000112","sortNo":46,"contentFormatId":"1","contentTxt":"<strong>Customize App Boilerplate</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000113","sortNo":47,"contentFormatId":"1","contentTxt":"Let's customize the generated Angular boilerplate to better suit the application we want to build.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000114","sortNo":48,"contentFormatId":"1","contentTxt":"<strong>Create a src/App/Core Folder</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000115","sortNo":49,"contentFormatId":"1","contentTxt":"First, create the following folder: src/app/core. Our app's root component and core files will live here. Move the app.component.* files into this folder.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000116","sortNo":50,"contentFormatId":"1","contentTxt":"<strong>Update App Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000117","sortNo":51,"contentFormatId":"1","contentTxt":"Next, open the src/app/app.module.ts file. We need to update the path to our app.component file since we just moved it into the src/app/core folder:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000118","sortNo":52,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000119","sortNo":53,"contentFormatId":"1","contentTxt":"<strong>Organize Assets</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000120","sortNo":54,"contentFormatId":"1","contentTxt":"Navigate to the src/assets folder.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000121","sortNo":55,"contentFormatId":"1","contentTxt":"Inside assets, add a new folder called images. Leave this empty for now; we'll add some images later. Next, move the src/styles.css file from the root folder into src/assets.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000122","sortNo":56,"contentFormatId":"1","contentTxt":"Moving styles.css requires us to make a change to .angular-cli.json. Open this file and change the styles array as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000123","sortNo":57,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000124","sortNo":58,"contentFormatId":"1","contentTxt":"<strong>Add Bootstrap CSS to Angular App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000125","sortNo":59,"contentFormatId":"1","contentTxt":"Finally, we'll add Bootstrap CSS to the index.html file in our app. This <link>tag was copied from the Bootstrap CDN. We'll only use the compiled CSS and not JS. While we're at it, let's update our app's <title> to \"Custom Pet Tags\":","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000126","sortNo":60,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000127","sortNo":61,"contentFormatId":"1","contentTxt":"<strong>Serve the App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000128","sortNo":62,"contentFormatId":"1","contentTxt":"We can serve our app on localhost and watch for changes with the following command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000129","sortNo":63,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000130","sortNo":64,"contentFormatId":"1","contentTxt":"Start the server and navigate to http://localhost:4200. The app should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000131","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000132","sortNo":66,"contentFormatId":"1","contentTxt":"<strong>App Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000133","sortNo":67,"contentFormatId":"1","contentTxt":"Now we're ready to start building out the features of our Custom Pet Tags Angular application. We'll start with the app.component.* files. This is our root component. Changes here will be minimal.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000134","sortNo":68,"contentFormatId":"1","contentTxt":"<strong>Delete App Component CSS</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000135","sortNo":69,"contentFormatId":"1","contentTxt":"Let's delete the app.component.css file. We won't need it since we'll only use Bootstrap for styling this component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000136","sortNo":70,"contentFormatId":"1","contentTxt":"<strong>App Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000137","sortNo":71,"contentFormatId":"1","contentTxt":"We also need to remove the reference to the deleted CSS file in the app.component.ts file. We can also delete the boilerplate title property from the AppComponent class. Our file should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000138","sortNo":72,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000139","sortNo":73,"contentFormatId":"1","contentTxt":"<strong>App Component Template HTML</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000140","sortNo":74,"contentFormatId":"1","contentTxt":"Now let's add some HTML to the app.component.html template. Replace the current contents of this file with the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000141","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000142","sortNo":76,"contentFormatId":"1","contentTxt":"We'll use Bootstrap styles to add a grid and a heading. Then we'll add the router-outlet directive. This is where our views will render when we change routes in our single page app. At this point, the app will throw an error until we establish routing and page components. Let's do that next.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000143","sortNo":77,"contentFormatId":"1","contentTxt":"<strong>Create Page Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000144","sortNo":78,"contentFormatId":"1","contentTxt":"As mentioned before, our app will have three routes: a homepage with a login, a page where the user can create and preview a new pet tag, and a completion page where the user can view their finished tag and log out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000145","sortNo":79,"contentFormatId":"1","contentTxt":"Let's create these page components so we can set up routing. Then we'll come back to each of them to build them out.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000146","sortNo":80,"contentFormatId":"1","contentTxt":"Execute the following commands from the root your pet-tags-ngrx project folder to generate the components:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000147","sortNo":81,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000148","sortNo":82,"contentFormatId":"1","contentTxt":"The ng g command (or its longform, ng generate) creates the necessary files and folders for Angular components, directives, pipes, and services. It also imports components in app.module.ts. We now have the scaffolding for our three page components, so let's set up routing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000149","sortNo":83,"contentFormatId":"1","contentTxt":"<strong>Create a Routing Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000150","sortNo":84,"contentFormatId":"1","contentTxt":"Let's build a separate NgModule to support routing. Create a new file in the src/app/core folder called app-routing.module.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000151","sortNo":85,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000152","sortNo":86,"contentFormatId":"1","contentTxt":"We now have our three routes: /, /create, and /complete. Page not found errors will redirect back to the homepage.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000153","sortNo":87,"contentFormatId":"1","contentTxt":"Next let's open our main app module file (app.module.ts) and add the new AppRoutingModule to imports like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000154","sortNo":88,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000155","sortNo":89,"contentFormatId":"1","contentTxt":"We now have routing set up. We should be able to navigate in the browser by entering the URLs defined in the AppRoutingModule. Our HomeComponent now renders in the router-outlet when we're on the homepage:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000156","sortNo":90,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000157","sortNo":91,"contentFormatId":"1","contentTxt":"<strong>\"home\" Page Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000158","sortNo":92,"contentFormatId":"1","contentTxt":"The HomeComponent will simply have a message and a login button for unauthenticated visitors. If a user is already logged in, they'll be sent to the /create route instead.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000159","sortNo":93,"contentFormatId":"1","contentTxt":"Note: Initially, we'll set up our components without authentication. After the primary features of our ngrx/store app are built, we'll add Auth0 authentication and a route guard.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000160","sortNo":94,"contentFormatId":"1","contentTxt":"For now, let's add a message and a placeholder button that takes the user to the /create page. Open the home.component.html template and replace the boilerplate content with the following markup:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000161","sortNo":95,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000162","sortNo":96,"contentFormatId":"1","contentTxt":"At the moment, the \"Log In\" button simply navigates to http://localhost:4200/create. Later, we'll update it to authenticate the user before going to the Create page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000163","sortNo":97,"contentFormatId":"1","contentTxt":"Our homepage now looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000164","sortNo":98,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000165","sortNo":99,"contentFormatId":"1","contentTxt":"<strong>Pet Tag Model</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000166","sortNo":100,"contentFormatId":"1","contentTxt":"Now it's time to start implementing our custom tag builder and state management. The first thing we'll do is create a model for our state. We want this model to represent the current custom pet tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000167","sortNo":101,"contentFormatId":"1","contentTxt":"Create a new file: src/app/core/pet-tag.model.ts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000168","sortNo":102,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000169","sortNo":103,"contentFormatId":"1","contentTxt":"The class declares the shape of the PetTag type. These are the required properties and type annotations for our application's custom pet tag state object.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000170","sortNo":104,"contentFormatId":"1","contentTxt":"Next we want to export a constant called initialTag. This constant declares the values in the default state object. We'll use this to initialize state as well as reset it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000171","sortNo":105,"contentFormatId":"1","contentTxt":"<strong>Pet Tag Actions</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000172","sortNo":106,"contentFormatId":"1","contentTxt":"Now we're ready to build an actions creator for our action types. Recall that actions are dispatched to a reducer to update the store. We'll declare an action for each kind of modification we want to make to the store.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000173","sortNo":107,"contentFormatId":"1","contentTxt":"Create the following file: src/app/core/pet-tag.actions.ts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000174","sortNo":108,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000175","sortNo":109,"contentFormatId":"1","contentTxt":"We're defining actions as constants. Alternatively, we could construct injectable action classes as done in the ngrx/example-app. For our small demo app, this can contribute to indirection, so we'll keep it simple.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000176","sortNo":110,"contentFormatId":"1","contentTxt":"<strong>Pet Tag Reducer</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000177","sortNo":111,"contentFormatId":"1","contentTxt":"Now let's build our reducer function that will take actions and update the store. Create a new file: src/app/core/pet-tag.reducer.ts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000178","sortNo":112,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000179","sortNo":113,"contentFormatId":"1","contentTxt":"First we import Action from ngrx/store. Then we need the PetTag model and its default state, initialTag. We also need to import the actions we created in the previous step.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000180","sortNo":114,"contentFormatId":"1","contentTxt":"Now we'll create our petTagReducer() function. The reducer accepts previous state and the dispatched action as arguments. Remember that this is a pure function: inputs determine outputs and the function does not modify global state. This means that when we return anything from the reducer, it either needs to be a new object or it can output an unmodified input (such as in the defaultcase).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000181","sortNo":115,"contentFormatId":"1","contentTxt":"We'll use Object.assign() to return new objects containing the values from source objects in most cases. The sources will be the previous state and objects containing the action payload.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000182","sortNo":116,"contentFormatId":"1","contentTxt":"The TOGGLE_CLIP and TOGGLE_GEMS actions toggle booleans that are assigned in the initialTag state. Therefore, we don't need a payload when we dispatch these actions; we can simply set the value to its opposite in these cases.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000183","sortNo":117,"contentFormatId":"1","contentTxt":"We're sending a payload with the COMPLETE action because we want to explicitly set it to true, and only do so once for each tag created. We could use a toggle for this as well, but for clarity, we'll dispatch a specific value as a payload instead.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000184","sortNo":118,"contentFormatId":"1","contentTxt":"Note: Notice that the RESET case uses the imported initialTagobject. Because initialTag is a constant, using it here does not interfere with the reducer's purity.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000185","sortNo":119,"contentFormatId":"1","contentTxt":"<strong>Import Store in App Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000186","sortNo":120,"contentFormatId":"1","contentTxt":"We now have actions and a reducer function. We need to tell our application to use the store and reducer. Open the app.module.ts file and update the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000187","sortNo":121,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000188","sortNo":122,"contentFormatId":"1","contentTxt":"We can now implement state management with Store updates in our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000189","sortNo":123,"contentFormatId":"1","contentTxt":"<strong>Building the \"create\" Page</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000190","sortNo":124,"contentFormatId":"1","contentTxt":"Our CreateComponent, which we initialized earlier for routing, is going to be a smart component. It will have several dumb child components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000191","sortNo":125,"contentFormatId":"1","contentTxt":"<strong>Smart and Dumb Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000192","sortNo":126,"contentFormatId":"1","contentTxt":"Smart components, also known as container components, are generally root level components. They contain business logic, manage state and subscriptions, and handle events. In our application, they are the routable page components. CreateComponent is a smart component and will implement the logic for our custom tag builder. It will handle events emitted by several dumb child components that make up the tag builder.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000193","sortNo":127,"contentFormatId":"1","contentTxt":"Dumb components, also known as presentational components, rely only on the data they are given by parent components. They can emit events that are then handled in the parent, but they do not utilize subscriptions or stores directly. Dumb components are modular and reusable. For example, we will use a tag preview dumb component on both the Create page and the Complete page (CreateComponent and CompleteComponent will be smart components).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000194","sortNo":128,"contentFormatId":"1","contentTxt":"<strong>\"create\" Page Features</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000195","sortNo":129,"contentFormatId":"1","contentTxt":"Our Create page will have the following features:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000196","sortNo":130,"contentFormatId":"1","contentTxt":"<ul>\n<li>Tag shape selector.                            </li>\n<li>Tag font style selector and tag text field.    </li>\n<li>Options to include a clip and add gems.        </li>\n<li>Preview of the tag's shape and text.           </li>\n<li>A \"Done\" button that finalizes the custom tag. </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000197","sortNo":131,"contentFormatId":"1","contentTxt":"<strong>\"create\" Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000198","sortNo":132,"contentFormatId":"1","contentTxt":"Let's start with the CreateComponent class. Open the create.component.tsfile:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000199","sortNo":133,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000200","sortNo":134,"contentFormatId":"1","contentTxt":"This smart component contains the logic for customizing a pet tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000201","sortNo":135,"contentFormatId":"1","contentTxt":"We'll import OnInit and OnDestroy, which will initialize and clean up our store subscription. We'll also need Observable and Subscription from RxJS and Store from ngrx/store. Our actions will be dispatched from this component, so we'll need to import most actions from the actions creator, with the exception of RESET. Finally, we'll import our PetTag model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000202","sortNo":136,"contentFormatId":"1","contentTxt":"We won't be needing any CSS for this component, so I've removed the CSS file and reference to it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000203","sortNo":137,"contentFormatId":"1","contentTxt":"In the CreateComponent class, tagState$ is a PetTag-shaped observable. In the constructor, we'll use the ngrx/store method select() to set this.tagState$ to the state observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000204","sortNo":138,"contentFormatId":"1","contentTxt":"Our ngOnInit() lifecycle hook will set up the subscription to the tagState$observable. This will set the petTag property to the state returned by the observable stream each time a new state is pushed. The done property will check for a selected shape and text. These are the two properties of a pet tag that must have truthy values in order for the tag to be \"fully customized.\" The ngOnDestroy() lifecycle hook then cleans up the subscription when the component is destroyed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000205","sortNo":139,"contentFormatId":"1","contentTxt":"Finally, we'll create the event handler functions that dispatch actions to the store. These handlers will be executed when the child dumb components emit events to update the custom tag state. Each handler uses the store.dispatch() method to send the desired action type and payload to our reducer.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000206","sortNo":140,"contentFormatId":"1","contentTxt":"Note: In a more complex app, you may wish to dispatch actions in an actions creator service that can be injected into your components. However, for our small app and for learning purposes, this is unnecessary, so we will dispatch actions directly from our smart components using constants from our actions creator, pet-tag.actions.ts.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000207","sortNo":141,"contentFormatId":"1","contentTxt":"<strong>Aside: Code Linting</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000208","sortNo":142,"contentFormatId":"1","contentTxt":"Angular's CLI comes with code linting in the form of the codelyzer package. You can lint your project at any time by running the following command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000209","sortNo":143,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000210","sortNo":144,"contentFormatId":"1","contentTxt":"Let's take the opportunity to lint our pet tags app now. If any errors are found, correct them before proceeding. It's good practice to lint periodically throughout development to maintain clean code. The linting configuration can be found at tslint.json in your project.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000211","sortNo":145,"contentFormatId":"1","contentTxt":"<strong>Tag Shape Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000212","sortNo":146,"contentFormatId":"1","contentTxt":"Now we'll build our first presentational component: TagShapeComponent. When we're finished with this component, the Create page should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000213","sortNo":147,"contentFormatId":"1","contentTxt":"Let's generate the scaffolding for this child component with the following Angular CLI command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000214","sortNo":148,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000215","sortNo":149,"contentFormatId":"1","contentTxt":"The tag shape component will display four different images with possible shapes: a bone, a rectangle, a circle, and a heart. The user can select which shape they'd like for their custom pet tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000216","sortNo":150,"contentFormatId":"1","contentTxt":"Download all four .svg images from the GitHub repository here: pet-tags-ngrx/src/assets/images/. Place them in your local pet-tags-ngrx/src/assets/images folder.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000217","sortNo":151,"contentFormatId":"1","contentTxt":"<strong>Tag Shape Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000218","sortNo":152,"contentFormatId":"1","contentTxt":"Next, open the tag-shape.component.ts file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000219","sortNo":153,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000220","sortNo":154,"contentFormatId":"1","contentTxt":"Add Output and EventEmitter to the @angular/core imports.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000221","sortNo":155,"contentFormatId":"1","contentTxt":"Our tag shape selector will use radio buttons, so we'll need a property to store the shape ngModel. The shape name options are strings, so we'll set tagShape's type annotation to string.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000222","sortNo":156,"contentFormatId":"1","contentTxt":"Next we need an @Output() decorator to emit an event when the user selects a shape. This will send the information to the parent CreateComponent. The selectShape(shape) method will emit the event with shape information. The parent can then handle this event with the selectShapeHandler() method we created earlier in CreateComponent. We'll hook this up to the parent shortly.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000223","sortNo":157,"contentFormatId":"1","contentTxt":"<strong>Tag Shape Component Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000224","sortNo":158,"contentFormatId":"1","contentTxt":"Before that, we'll add the necessary template markup for our TagShapeComponent. Modify the tag-shape.component.html file as shown:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000225","sortNo":159,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000226","sortNo":160,"contentFormatId":"1","contentTxt":"We'll create radio options for each of our four shapes along with their images. When any input is selected, we'll use the (change) event to fire our method emitting the selectShapeEvent with the tagShape as its argument.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000227","sortNo":161,"contentFormatId":"1","contentTxt":"<strong>Tag Shape Component Styles</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000228","sortNo":162,"contentFormatId":"1","contentTxt":"This component could use a little bit of styling beyond Bootstrap, so add the following to the tag-shape.component.css file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000229","sortNo":163,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000230","sortNo":164,"contentFormatId":"1","contentTxt":"Note: The :host pseudo-class selector targets the component's host element,  app-tag-shape in this case.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000231","sortNo":165,"contentFormatId":"1","contentTxt":"<strong>Add Tag Shape Component to the Create Page</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000232","sortNo":166,"contentFormatId":"1","contentTxt":"Finally, we'll implement our TagShapeComponent by adding it to the our smart CreateComponent template. Open the create.component.html file and replace the boilerplate markup with the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000233","sortNo":167,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000234","sortNo":168,"contentFormatId":"1","contentTxt":"Our parent component is now listening for the selectShapeEvent from the tag shape child and handling it by executing the selectShapeHandler() method we created in our CreateComponent class earlier. If you recall, that method dispatches the SELECT_SHAPE action to the store and looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000235","sortNo":169,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000236","sortNo":170,"contentFormatId":"1","contentTxt":"Our app now updates state when the user selects a shape for their custom pet tag!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000237","sortNo":171,"contentFormatId":"1","contentTxt":"<strong>Tag Text Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000238","sortNo":172,"contentFormatId":"1","contentTxt":"Next we'll create a child component that lets the user choose a font style and enter the text they'd like on their pet tag. Our Create page will look like this once we've added our tag text component:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000239","sortNo":173,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000240","sortNo":174,"contentFormatId":"1","contentTxt":"Generate the component scaffolding with the following command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000241","sortNo":175,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000242","sortNo":176,"contentFormatId":"1","contentTxt":"<strong>Tag Text Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000243","sortNo":177,"contentFormatId":"1","contentTxt":"Now open the tag-text.component.ts file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000244","sortNo":178,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000245","sortNo":179,"contentFormatId":"1","contentTxt":"This component works the same way as our TagShapeComponent, so it looks very similar. We'll import Output and EventEmitter and create properties for the tagTextInput and fontType based on user inputs.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000246","sortNo":180,"contentFormatId":"1","contentTxt":"Note: We aren't adding string type annotations to our properties because declaring initial values allows types to be inferred automatically.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000247","sortNo":181,"contentFormatId":"1","contentTxt":"We'll emit events when the user updates the tag text or changes the font style selection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000248","sortNo":182,"contentFormatId":"1","contentTxt":"<strong>Tag Text Component Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000249","sortNo":183,"contentFormatId":"1","contentTxt":"Our tag text component template, tag-text.component.html, should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000250","sortNo":184,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000251","sortNo":185,"contentFormatId":"1","contentTxt":"We're using a <select> element and a text input field to let the user choose options for their custom pet tag. The ngModels are updated on user input and events are emitted to the parent component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000252","sortNo":186,"contentFormatId":"1","contentTxt":"<strong>Tag Text Component Styles</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000253","sortNo":187,"contentFormatId":"1","contentTxt":"We'll add just one ruleset to tag-text.component.css:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000254","sortNo":188,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000255","sortNo":189,"contentFormatId":"1","contentTxt":"<strong>Add Tag Text Component to the Create Page</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000256","sortNo":190,"contentFormatId":"1","contentTxt":"Finally, we need to add the TagTextComponent to the Create page:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000257","sortNo":191,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000258","sortNo":192,"contentFormatId":"1","contentTxt":"Notice that we're adding an *ngIf structural directive to the <app-tag-text>element. We only want this component to appear once the user has selected a shape. This is because we're going to create a preview of the tag soon, and it doesn't make sense to show a preview unless a shape has already been selected. This prevents users from entering text or extra tag options before choosing a shape.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000259","sortNo":193,"contentFormatId":"1","contentTxt":"We'll listen for TagTextComponent to emit the selectFontEvent and addTextEvent events and handle them with the methods we added to CreateComponent earlier, which dispatch the SELECT_FONT and ADD_TEXTactions and payloads to the reducer:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000260","sortNo":194,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000261","sortNo":195,"contentFormatId":"1","contentTxt":"<strong>Tag Extras Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000262","sortNo":196,"contentFormatId":"1","contentTxt":"Now we'll let the user choose whether they want a few extras for their custom pet tag. Once we've implemented the tag extras component, our Create page will look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000263","sortNo":197,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000264","sortNo":198,"contentFormatId":"1","contentTxt":"Create the scaffolding for TagExtrasComponent with this command:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000265","sortNo":199,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000266","sortNo":200,"contentFormatId":"1","contentTxt":"<strong>Tag Extras Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000267","sortNo":201,"contentFormatId":"1","contentTxt":"Open tag-extras.component.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000268","sortNo":202,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000269","sortNo":203,"contentFormatId":"1","contentTxt":"This should look very familiar by now. \"Extras\" are options to include a tag clip or gems with our pet tag, so they are boolean values serving as ngModels for checkboxes.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000270","sortNo":204,"contentFormatId":"1","contentTxt":"<strong>Tag Extras Component Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000271","sortNo":205,"contentFormatId":"1","contentTxt":"Add the necessary markup to the tag-extras.component.html template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000272","sortNo":206,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000273","sortNo":207,"contentFormatId":"1","contentTxt":"We'll use checkboxes to let the user choose whether they'd like to add extras.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000274","sortNo":208,"contentFormatId":"1","contentTxt":"<strong>Tag Extras Component Styles</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000275","sortNo":209,"contentFormatId":"1","contentTxt":"We want to add a bottom border to our host element since this is the last component before we'll show the customized tag preview. Add the following to the tag-extras.component.css file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000276","sortNo":210,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000277","sortNo":211,"contentFormatId":"1","contentTxt":"<strong>Add Tag Extras Component to the Create Page</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000278","sortNo":212,"contentFormatId":"1","contentTxt":"Let's add the tag extras component to create.component.html like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000279","sortNo":213,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000280","sortNo":214,"contentFormatId":"1","contentTxt":"Like the tag text component, we'll only display the extras if the user has already selected a shape. The toggleClipEvent and toggleGemsEvent events are handled by the CreateComponent methods we created earlier to dispatch the TOGGLE_CLIP and TOGGLE_GEMS actions to the reducer:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000281","sortNo":215,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000282","sortNo":216,"contentFormatId":"1","contentTxt":"Since these are boolean toggles, no payloads are necessary. Recall that we set up the reducer to use the previous state to determine the next state in these cases.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000283","sortNo":217,"contentFormatId":"1","contentTxt":"<strong>Tag Preview Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000284","sortNo":218,"contentFormatId":"1","contentTxt":"Now let's create a component that shows a simple preview of the pet tag as it's being created. After we've implemented the tag preview presentational component, we'll be able to view the tag like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000285","sortNo":219,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000286","sortNo":220,"contentFormatId":"1","contentTxt":"Let's scaffold the TagPreviewComponent. This component will be a child of both the Create and Complete pages, so let's create it in the root of the app folder like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000287","sortNo":221,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000288","sortNo":222,"contentFormatId":"1","contentTxt":"<strong>Tag Preview Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000289","sortNo":223,"contentFormatId":"1","contentTxt":"Open tag-preview.component.ts and add this code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000290","sortNo":224,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000291","sortNo":225,"contentFormatId":"1","contentTxt":"TagPreviewComponent is a dumb component that takes input from the CreateComponent parent and displays it, but does not produce any outputs. Import the Input decorator and the OnChanges lifecycle hook. We also need the PetTag model so we know what shape to expect from the input.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000292","sortNo":226,"contentFormatId":"1","contentTxt":"The TagPreviewComponent class needs to implement OnChanges so we can take advantage of the ngOnChanges() method. ngOnChanges() executes each time changes to the component's inputs are detected. We'll need this in order to update our preview whenever the user modifies their custom pet tag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000293","sortNo":227,"contentFormatId":"1","contentTxt":"The @Input() petTag that we'll be receiving from the parent component is the state object, which has the shape declared by the PetTag model we defined at the beginning. For example, it might look something like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000294","sortNo":228,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000295","sortNo":229,"contentFormatId":"1","contentTxt":"We want to display this data in a user-friendly, visual way. We'll do this by showing an image of the tag with user-inputted text and notes about whether the user has chosen to include a clip or gems.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000296","sortNo":230,"contentFormatId":"1","contentTxt":"We'll set the image source as well as the tag clip and gems option text (\"Yes\" or \"No\") when changes to the input are detected. The input is provided by CreateComponent's subscription to its tagState$ store observable.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000297","sortNo":231,"contentFormatId":"1","contentTxt":"<strong>Tag Preview Component Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000298","sortNo":232,"contentFormatId":"1","contentTxt":"Open the tag-preview.component.html file and add:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000299","sortNo":233,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000300","sortNo":234,"contentFormatId":"1","contentTxt":"The preview will show if there is a shape. We'll display the appropriate shape SVG image and a shape class. We'll also display the pet tag text in the appropriate font using a class with the font value. Finally, we'll print out whether the user has chosen to include a tag clip or gems.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000301","sortNo":235,"contentFormatId":"1","contentTxt":"<strong>Tag Preview Component Styles</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000302","sortNo":236,"contentFormatId":"1","contentTxt":"Recall that there are four possible tag shapes: a bone, rectangle, circle, and heart. In order to display a nice preview with any of these shapes, we'll need some additional styling. Open the tag-preview.component.css file:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000303","sortNo":237,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000304","sortNo":238,"contentFormatId":"1","contentTxt":"After some basic styling to position the preview elements, we'll set the font sizes based on shape and the font families based on the user's selected font style.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000305","sortNo":239,"contentFormatId":"1","contentTxt":"Now our  app-tag-preview is ready to be added to the container component templates.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000306","sortNo":240,"contentFormatId":"1","contentTxt":"<strong>Add Tag Preview Component to the Create Page</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000307","sortNo":241,"contentFormatId":"1","contentTxt":"Open create.component.html and let's add the tag preview child component at the bottom:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000308","sortNo":242,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000309","sortNo":243,"contentFormatId":"1","contentTxt":"Square brackets ([...]) denote a one-way binding syntax. We already established our local petTag property in the CreateComponent's tagStateSubscription, and we're passing this to the tag preview component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000310","sortNo":244,"contentFormatId":"1","contentTxt":"Now we should be able to see live changes in the tag preview as we customize our tag:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000311","sortNo":245,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000312","sortNo":246,"contentFormatId":"1","contentTxt":"<strong>Submit Completed Tag</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000313","sortNo":247,"contentFormatId":"1","contentTxt":"Now that we have our tag builder and preview built, let's add a \"Done\" button to submit the finished tag to the Complete page. When implemented, our Create page should look like the following:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000314","sortNo":248,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000315","sortNo":249,"contentFormatId":"1","contentTxt":"We've already created a submit() method in CreateComponent that dispatches the COMPLETE action and payload to the reducer. All we need to do is create a button that calls this method in our create.component.html template:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000316","sortNo":250,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000317","sortNo":251,"contentFormatId":"1","contentTxt":"We'll disable the button if the done property is falsey. We declared done in the CreateComponent's tagStateSubscription earlier. It looks like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000318","sortNo":252,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000319","sortNo":253,"contentFormatId":"1","contentTxt":"The tag can be considered ready for submission if it has a shape and text. If the user has added these, then they will be able to click the button to submit their tag. We'll also route the user to the Complete page.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000320","sortNo":254,"contentFormatId":"1","contentTxt":"\"complete\" Page Component","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000321","sortNo":255,"contentFormatId":"1","contentTxt":"We scaffolded the Complete page when we set up the main routes for our app. Once we've implemented the component, the Complete page will look something like this after the user has created a custom pet tag:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000322","sortNo":256,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000323","sortNo":257,"contentFormatId":"1","contentTxt":"<strong>\"complete\" Component Typescript</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000324","sortNo":258,"contentFormatId":"1","contentTxt":"Now let's open the complete.component.ts smart component and implement the following code:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000325","sortNo":259,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000326","sortNo":260,"contentFormatId":"1","contentTxt":"CompleteComponent is a routable smart (container) component. We'll be managing a store subscription, so we need to import OnInit, OnDestroy, Observable, Subscription, and Store. We'll also have a link the user can click to start over and create a new tag. This will set the state back to its initial values, so we need to import the RESET action, as well as PetTag and initialTag from our model.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000327","sortNo":261,"contentFormatId":"1","contentTxt":"This component doesn't need any styling beyond Bootstrap, so we'll delete the complete.component.css file and remove the reference to it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000328","sortNo":262,"contentFormatId":"1","contentTxt":"Like in our CreateComponent smart component, we'll create a tagState$observable, tagStateSubscription, and a local petTag property. We'll also create an emptyTag property with the PetTag type. We'll set its value to initialTag.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000329","sortNo":263,"contentFormatId":"1","contentTxt":"In the constructor, we'll assign tagState$ as the store observable. Then in ngOnInit(), we'll subscribe to the observable and set the petTag property. In the ngOnDestroy() method, we'll clean up our subscribtion by unsubscribing.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000330","sortNo":264,"contentFormatId":"1","contentTxt":"Finally, our newTag() method will dispatch the RESET action. This \"resets\" the application state so that a new tag can be customized.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000331","sortNo":265,"contentFormatId":"1","contentTxt":"<strong>\"complete\" Component Template</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000332","sortNo":266,"contentFormatId":"1","contentTxt":"Our CompleteComponent's HTML template will look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000333","sortNo":267,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000334","sortNo":268,"contentFormatId":"1","contentTxt":"First we'll show a success alert that congratulates the user on creating a custom tag for their pet, grabbing the pet's name from the petTag state object's text. We'll provide a link to create another tag that executes the newTag() method and routes the visitor back to the Create page to start fresh.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000335","sortNo":269,"contentFormatId":"1","contentTxt":"Then we'll show the tag preview component and pass the petTag object to it: app-tag-preview [petTag]=\"petTag\"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000336","sortNo":270,"contentFormatId":"1","contentTxt":"Finally, we'll need to show an error message if the user manually navigates to the /complete route without having finished customizing a tag. A link should be available to take them back to the Create page. The Complete page error should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000337","sortNo":271,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000338","sortNo":272,"contentFormatId":"1","contentTxt":"We now have the primary functionality of our Custom Pet Tags application set up and working!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000339","sortNo":273,"contentFormatId":"1","contentTxt":"<strong>Authentication With Auth0</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000340","sortNo":274,"contentFormatId":"1","contentTxt":"We'll now protect our application so that only authenticated users can access it. We already set up a \"Log In\" button in our HomeComponent, but right now it just navigates to the Create page. Let's hook up the authentication functionality using Auth0.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000341","sortNo":275,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000342","sortNo":276,"contentFormatId":"1","contentTxt":"Sign Up for Auth0","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000343","sortNo":277,"contentFormatId":"1","contentTxt":"The first thing we'll need is an Auth0 account. Follow these simple steps to get started:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000344","sortNo":278,"contentFormatId":"1","contentTxt":"<ul>\n<li>Sign up for a .                                                                                                                                                                                                                                             </li>\n<li>In your Auth0 Dashboard, create a new client.                                                                                                                                                                                                               </li>\n<li>Name your new app and select \"Single Page Web Applications.\"                                                                                                                                                                                                </li>\n<li>In the Settings for your newly created app, add http://localhost:4200 to the Allowed Callback URLs and Allowed Origins (CORS).                                                                                                                              </li>\n<li>If you'd like, you can set up some social connections. You can then enable them for your app in the Client options under the Connections tab. The example shown in the screenshot above utilizes username/password database, Facebook, Google, and Twitter. </li>\n</ul>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000345","sortNo":279,"contentFormatId":"1","contentTxt":"<strong>Set Up Dependencies</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000346","sortNo":280,"contentFormatId":"1","contentTxt":"Auth0 authenticates using JSON Web Tokens. Let's install the angular2-jwt helper library using npm:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000347","sortNo":281,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000348","sortNo":282,"contentFormatId":"1","contentTxt":"We also need the Auth0 Lock library. This provides the login widget and methods. We'll include the CDN-provided script for Lock in the <head> of our index.html file, like so:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000349","sortNo":283,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000350","sortNo":284,"contentFormatId":"1","contentTxt":"<strong>Create an Auth Service</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000351","sortNo":285,"contentFormatId":"1","contentTxt":"Next we'll create a service to manage authentication. User authentication will be handled via local storage and it won't be necessary to create another store. In a more complex application, you may wish to make a user store, but for our purposes, a simple service will work just fine.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000352","sortNo":286,"contentFormatId":"1","contentTxt":"Let's create an authentication service:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000353","sortNo":287,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000354","sortNo":288,"contentFormatId":"1","contentTxt":"Our auth.service.ts file should look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000355","sortNo":289,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000356","sortNo":290,"contentFormatId":"1","contentTxt":"We'll import Router to handle redirection after login and tokenNotExpired(from angular2-jwt) to make sure our user still has a valid JWT.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000357","sortNo":291,"contentFormatId":"1","contentTxt":"To avoid TypeScript warnings, we need to declare types for Auth0Lock and localStorage. We'll be able to inject our AuthService wherever we need access to its properties and methods (ie., in other components).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000358","sortNo":292,"contentFormatId":"1","contentTxt":"In the AuthService class, we need to create a new Lock instance with our Auth0 client's ID and domain. These can be found in your Auth0 dashboard settings for the Single Page Application client you just set up. Replace [CLIENT_ID] and [CLIENT_DOMAIN] with your personalized information. We'll pass a configuration object to our Lock instance with a redirectUrl and responseType.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000359","sortNo":293,"contentFormatId":"1","contentTxt":"We'll create a property to store the user's profile information that we'll retrieve when a visitor authenticates. This has an Object type.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000360","sortNo":294,"contentFormatId":"1","contentTxt":"Because we'll be storing the user's profile and access token in local storage, the first thing we'll do in our constructor is check for an existing profile. If there's a profile in storage already, we'll set the userProfile property.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000361","sortNo":295,"contentFormatId":"1","contentTxt":"Next we need to listen to the Lock instance for the hash_parsed event. This is a low-level event that we'll use (instead of the authenticated event) in order to handle single page app redirection upon login.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000362","sortNo":296,"contentFormatId":"1","contentTxt":"If an idToken is present, we'll save it to localStorage and use it to retrieve the user's profile information. Once the profile has been successfully retrieved, we can save it to localStorage and redirect to the Create page. If there is no idToken returned, we'll reinitialize the login and log an authentication warning.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000363","sortNo":297,"contentFormatId":"1","contentTxt":"Finally, we'll implement three methods: login(), logout(), and the authenticated accessor. The login() method will simply display the Lock widget so the user can log in with Auth0. The logout() method removes the user's token and profile from local storage. The authenticated getter checks the JWT to see if it has expired and returns a boolean representing authentication status.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000364","sortNo":298,"contentFormatId":"1","contentTxt":"We're now ready to use AuthService to authenticate users in our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000365","sortNo":299,"contentFormatId":"1","contentTxt":"<strong>Provide Auth Service in App Module</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000366","sortNo":300,"contentFormatId":"1","contentTxt":"We're going to provide AuthService globally to the application in our app.module.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000367","sortNo":301,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000368","sortNo":302,"contentFormatId":"1","contentTxt":"Import AuthService in the app module and add it to the providers array. We can now inject this service elsewhere in our application.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000369","sortNo":303,"contentFormatId":"1","contentTxt":"<strong>Home Component Login</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000370","sortNo":304,"contentFormatId":"1","contentTxt":"The first thing we'll implement with AuthService is the \"Log In\" button we created on the homepage.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000371","sortNo":305,"contentFormatId":"1","contentTxt":"Open home.component.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000372","sortNo":306,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000373","sortNo":307,"contentFormatId":"1","contentTxt":"Import AuthService and Router and make them available to the constructor. auth should be public because we need to access its methods in the Home template. Using the OnInit lifecycle hook, we'll check if the user is authenticated. If so, we'll navigate to the Create page so the user can skip the login on the homepage.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000374","sortNo":308,"contentFormatId":"1","contentTxt":"Now open home.component.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000375","sortNo":309,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000376","sortNo":310,"contentFormatId":"1","contentTxt":"We'll update the \"Log In\" button so that clicking it executes the AuthServicelogin() method and shows the Auth0 Lock login box.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000377","sortNo":311,"contentFormatId":"1","contentTxt":"We now have a functioning login in our app!","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000378","sortNo":312,"contentFormatId":"1","contentTxt":"<strong>Complete Component Logout</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000379","sortNo":313,"contentFormatId":"1","contentTxt":"We also need a way for our users to log out. We'll add a \"Log Out\" button to the Complete page component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000380","sortNo":314,"contentFormatId":"1","contentTxt":"Open complete.component.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000381","sortNo":315,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000382","sortNo":316,"contentFormatId":"1","contentTxt":"We'll import AuthService and make it publicly available to the constructor so we can access its properties and methods in the HTML template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000383","sortNo":317,"contentFormatId":"1","contentTxt":"Next open complete.component.html:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000384","sortNo":318,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000385","sortNo":319,"contentFormatId":"1","contentTxt":"We'll greet the user by name and add a \"Log Out\" button to call the AuthService's logout() method and redirect the user back to the homepage.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000386","sortNo":320,"contentFormatId":"1","contentTxt":"<strong>Greet User in Create Component</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000387","sortNo":321,"contentFormatId":"1","contentTxt":"For a personal touch, we'll also greet the user by name on the Create page. Open create.component.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000388","sortNo":322,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000389","sortNo":323,"contentFormatId":"1","contentTxt":"Import the AuthService and make it publicly available in the constructor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000390","sortNo":324,"contentFormatId":"1","contentTxt":"Next open the create.component.html template and add a personalized greeting after Hello:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000391","sortNo":325,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000392","sortNo":326,"contentFormatId":"1","contentTxt":"Now our app feels more personalized.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000393","sortNo":327,"contentFormatId":"1","contentTxt":"<strong>Create a Route Guard</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000394","sortNo":328,"contentFormatId":"1","contentTxt":"We can log in and out of our app, but that doesn't offer much more than simple personalization at the moment. Any visitor can still navigate to any route they wish if they simply enter URLs manually. Let's implement a route guard so that routes are activated only for logged in users.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000395","sortNo":329,"contentFormatId":"1","contentTxt":"Create a new file in src/app/core called auth.guard.ts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000396","sortNo":330,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000397","sortNo":331,"contentFormatId":"1","contentTxt":"We need to inject the route guard in our routing module, so we need to import Injectable. We'll also need Router to redirect the user when they're not authenticated, and CanActivate to activate (or deactivate) routes based on user authentication status. We'll import AuthService to get this authentication information. That's it for imports.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000398","sortNo":332,"contentFormatId":"1","contentTxt":"The AuthGuard class implements CanActivate, a guard which determines if a route can be activated or not. We'll make AuthService and Router available privately to the constructor.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000399","sortNo":333,"contentFormatId":"1","contentTxt":"Our canActivate() method checks if the user is authenticated. If they are, the route can be activated so we'll return true. Otherwise, we'll redirect to the Home page so the user can log in and return false: the route cannot be activated.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000400","sortNo":334,"contentFormatId":"1","contentTxt":"<strong>App Routing Module With Route Guard</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000401","sortNo":335,"contentFormatId":"1","contentTxt":"Now that we've created a route guard, we need to apply it in our application. Let's open the app-routing.module.ts file and make some updates:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000402","sortNo":336,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000403","sortNo":337,"contentFormatId":"1","contentTxt":"First we need to import our AuthGuard. Then we'll add the canActivate: [ AuthGuard ] key/value to each route that we want to protect. This includes the 'create' route and the 'complete' route. Finally, we need to add AuthGuard to the providers array.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000404","sortNo":338,"contentFormatId":"1","contentTxt":"Unauthorized users can no longer access routes that require authentication. Trying to access protected routes when not logged in redirects visitors to the homepage where they'll see the \"Log In\" button.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000405","sortNo":339,"contentFormatId":"1","contentTxt":"Note: Don't forget to run ng lint if you haven't been doing so and make sure there are no issues with our code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000406","sortNo":340,"contentFormatId":"1","contentTxt":"<strong>Conclusion</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201704010000000407","sortNo":341,"contentFormatId":"1","contentTxt":"Our simple Angular + ngrx/store + Auth0 application is now complete. Try it out!","contentBinary":"","contentPoster":"","contentUrl":null}]
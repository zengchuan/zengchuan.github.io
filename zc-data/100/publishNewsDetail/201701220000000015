[{"id":"201701220000000131","sortNo":1,"contentFormatId":"1","contentTxt":"This is the second post in the Essential Angular series, which aims to be a short, but at the same time, fairly complete overview of the key aspects of Angular. In this post I’ll cover NgModules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000132","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000133","sortNo":3,"contentFormatId":"1","contentTxt":"Throughout this series I will use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000134","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000135","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Declarations, Imports, and Exports</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000136","sortNo":6,"contentFormatId":"1","contentTxt":"NgModules are the unit of compilation and distribution of Angular components and pipes. In many ways they are similar to ES6 modules, in that they have declarations, imports, and exports.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000137","sortNo":7,"contentFormatId":"1","contentTxt":"Let’s look at this example:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000138","sortNo":8,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000139","sortNo":9,"contentFormatId":"1","contentTxt":"Here we define two modules: TalksModule and AppModule. TalksModule has all the components and pipes that do actual work in the application, whereas AppModule has only AppCmp, which is a thin application shell.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000140","sortNo":10,"contentFormatId":"1","contentTxt":"TalksModule declares four components and one pipe. The four components can use each other in their templates, similar to how classes defined in an ES module can refer to each other in their methods. Also, all the components can use FormattedRatingPipe. So an NgModule is the compilation context of its components, i.e., it tells Angular how these components should be compiled. As with ES, a component can only be declared in one module.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000141","sortNo":11,"contentFormatId":"1","contentTxt":"n this example TalksModule exports only TalksCmp — the rest is private. This means that only TalksCmp is added to the compilation context of AppModule. Again this is similar to how the export keyword works in JavaScript.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000142","sortNo":12,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000143","sortNo":13,"contentFormatId":"1","contentTxt":"1. NgModules are akin to ES modules: they have declarations, imports, and exports.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000144","sortNo":14,"contentFormatId":"1","contentTxt":"2. NgModules define the compilation context of their components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000145","sortNo":15,"contentFormatId":"1","contentTxt":"<strong>Bootstrap and Entry Components</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000146","sortNo":16,"contentFormatId":"1","contentTxt":"The bootstrap property defines the components that are instantiated when a module is bootstrapped. First, Angular creates a component factory for each of the bootstrap components. And then, at runtime, it’ll use the factories to instantiate the components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000147","sortNo":17,"contentFormatId":"1","contentTxt":"To generate less code, and, as a result, to produce smaller bundles, Angular won’t generate component factories for any TalksModule’s components. The framework can see their usage statically, it can inline their instantiation, so no factories are required. This is true for any component used statically (or declaratively) in the template.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000148","sortNo":18,"contentFormatId":"1","contentTxt":"For instance, let’s look at TalkCmp:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000149","sortNo":19,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000150","sortNo":20,"contentFormatId":"1","contentTxt":"Angular knows, at compile time, that TalkCmp uses WatchButtonCmp and RateButtonCmp, so it can instantiate them directly, without any indirection or extra abstractions.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000151","sortNo":21,"contentFormatId":"1","contentTxt":"Now let’s look at a different component that uses the router.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000152","sortNo":22,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000153","sortNo":23,"contentFormatId":"1","contentTxt":"Angular cannot statically figure out what components can be loaded into the outlet, and, as a result, cannot instantiate them directly. Here we need the extra abstraction, we need the component factories for both TalksCmp and SettingsCmp. We can tell Angular to generate those by listing them as entry components.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000154","sortNo":24,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000155","sortNo":25,"contentFormatId":"1","contentTxt":"Even though we do not use TalksCmp or SettingsCmp in any template, the router configuration is still static. And it is cumbersome to declare every component used by the router in the entry components. Because this is so common, Angular supports a special provider token to automatically pre-populate entryComponents.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000156","sortNo":26,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000157","sortNo":27,"contentFormatId":"1","contentTxt":"And when using RouterModule.forRoot or RouterModule.forChild, the router module takes care of it.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000158","sortNo":28,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000159","sortNo":29,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000160","sortNo":30,"contentFormatId":"1","contentTxt":"1. To be more efficient, Angular separates components used statically (declaratively) from the components used dynamically (imperatively).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000161","sortNo":31,"contentFormatId":"1","contentTxt":"2. Angular directly instantiates components used statically; no extra abstraction is required.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000162","sortNo":32,"contentFormatId":"1","contentTxt":"3. Angular generates a component factory for every component listed in entryComponents, so that they can be instantiated imperatively.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000163","sortNo":33,"contentFormatId":"1","contentTxt":"<strong>Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000164","sortNo":34,"contentFormatId":"1","contentTxt":"I’ll cover providers and dependency injection in an upcoming blog post. Here I’d like to just note that NgModules can contain providers. And the providers of the imported modules are merged with the target module’s providers, left to right, i.e., if multiple imported modules define the same provider, the last module wins.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000165","sortNo":35,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000166","sortNo":36,"contentFormatId":"1","contentTxt":"<strong>Injecting NgModules and Module Initialization</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000167","sortNo":37,"contentFormatId":"1","contentTxt":"Angular instantiates NgModules and registers them with dependency injection. This means that you can inject modules into other modules or components, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000168","sortNo":38,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000169","sortNo":39,"contentFormatId":"1","contentTxt":"This can be useful for coordinating the initialization of multiple modules, as shown below:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000170","sortNo":40,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000171","sortNo":41,"contentFormatId":"1","contentTxt":"<strong>Bootstrap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000172","sortNo":42,"contentFormatId":"1","contentTxt":"To bootstrap an Angular application in the JIT mode, you pass a module to bootstrapModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000173","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000174","sortNo":44,"contentFormatId":"1","contentTxt":"This will compile AppModule into a module factory and then use the factory to instantiate the module. If you use AOT, you may need to provide the factory yourself.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000175","sortNo":45,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000176","sortNo":46,"contentFormatId":"1","contentTxt":"I said “may need to” because the CLI and the WebPack plugin take care of it for you. They will replace the bootstrapModule call with bootstrapModuleFactory when needed.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000177","sortNo":47,"contentFormatId":"1","contentTxt":"<strong>Lazy Loading</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000178","sortNo":48,"contentFormatId":"1","contentTxt":"As I mentioned above NgModules are not just the units of compilation, they are also the units of distribution. That is why we bootstrap an NgModule, and not a component — we don’t distribute components, we distribute modules. And that’s why we lazy load NgModules as well.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000179","sortNo":49,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000180","sortNo":50,"contentFormatId":"1","contentTxt":"The loader compiles the modules if the application is running in the JIT mode, and does not in the AOT mode. The default loader ‘@angular/core’ ships with uses SystemJS, but, as most things in Angular, you can provide your own.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000181","sortNo":51,"contentFormatId":"1","contentTxt":"<strong>Summary</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000182","sortNo":52,"contentFormatId":"1","contentTxt":"1. NgModules are the units of compilation. They tell Angular how components should be compiled.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000183","sortNo":53,"contentFormatId":"1","contentTxt":"2. Similar to ES module they have declarations, imports, and exports.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000184","sortNo":54,"contentFormatId":"1","contentTxt":"3. Every component belongs to a NgModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000185","sortNo":55,"contentFormatId":"1","contentTxt":"4. Bootstrap and entry components are configured in NgModules.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000186","sortNo":56,"contentFormatId":"1","contentTxt":"5. NgModules configure dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000187","sortNo":57,"contentFormatId":"1","contentTxt":"6. NgModules are used to bootstrap applications.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000188","sortNo":58,"contentFormatId":"1","contentTxt":"7. NgModules are used to lazy load code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000189","sortNo":59,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701220000000190","sortNo":60,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]
[{"id":"201701230000000066","sortNo":1,"contentFormatId":"1","contentTxt":"This is the fourth post in the Essential Angular series, which aims to be a short, but at the same time, fairly complete overview of the key aspects of Angular. In this post I’ll cover dependency injection.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000067","sortNo":2,"contentFormatId":"1","contentTxt":"<strong>Example App</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000068","sortNo":3,"contentFormatId":"1","contentTxt":"Throughout this series I use the same application in the examples. This application is a list of tech talks that you can filter, watch, and rate.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000069","sortNo":4,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000070","sortNo":5,"contentFormatId":"1","contentTxt":"<strong>Dependency Injection</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000071","sortNo":6,"contentFormatId":"1","contentTxt":"The idea behind dependency injection is very simple. If you have a component that depends on a service. You do not create that service yourself. Instead, you request one in the constructor, and the framework will provide you one. By doing so you can depend on interfaces rather than concrete types. This leads to more decoupled code, which enables testability, and other great things.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000072","sortNo":7,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000073","sortNo":8,"contentFormatId":"1","contentTxt":"Angular comes with a dependency injection system. To see how it can be used, let’s look at the following component, which renders a list of talks using the for directive:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000074","sortNo":9,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000075","sortNo":10,"contentFormatId":"1","contentTxt":"Let’s mock up a simple service that will give us the data.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000076","sortNo":11,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000077","sortNo":12,"contentFormatId":"1","contentTxt":"How can you use this service? One approach is to create an instance of this service in our component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000078","sortNo":13,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000079","sortNo":14,"contentFormatId":"1","contentTxt":"This is fine for a demo app, but not good for real applications. In a real application TalksAppBackend won’t just return an array of objects, it will make http requests to get the data. This means that the unit tests for this component will make real http requests — not a great idea. This problem is caused by the fact that you have coupled TalksCmp to TalksAppBackend and its new operator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000080","sortNo":15,"contentFormatId":"1","contentTxt":"You can solve this problem by injecting an instance of TalksAppBackend into the constructor, so you can easily replace it in tests, like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000081","sortNo":16,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000082","sortNo":17,"contentFormatId":"1","contentTxt":"This tells Angular that TalksCmp depend on TalksAppBackend. Now, you need to tell Angular how to create an instance of TalksAppBackend.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000083","sortNo":18,"contentFormatId":"1","contentTxt":"<strong>Registering Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000084","sortNo":19,"contentFormatId":"1","contentTxt":"To do that you need to register a provider, and there are two places where you can do it. One is in the component decorator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000085","sortNo":20,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000086","sortNo":21,"contentFormatId":"1","contentTxt":"And the other one is in the module decorator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000087","sortNo":22,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000088","sortNo":23,"contentFormatId":"1","contentTxt":"What is the difference and which one should you prefer?","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000089","sortNo":24,"contentFormatId":"1","contentTxt":"Generally, I recommend to register providers at the module level when they do not depend on the DOM, components, or directives. And only UI-related providers that have to be scoped to a particular component should be registered at the component level. Since `TalksAppBackend` has nothing to do with the UI, register it at the module level.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000090","sortNo":25,"contentFormatId":"1","contentTxt":"<strong>Injector Tree</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000091","sortNo":26,"contentFormatId":"1","contentTxt":"Now you know that the dependency injection configuration has two parts:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000092","sortNo":27,"contentFormatId":"1","contentTxt":"1. Registering providers: How and where an object should be created.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000093","sortNo":28,"contentFormatId":"1","contentTxt":"2. Injecting dependencies: What an object depends on.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000094","sortNo":29,"contentFormatId":"1","contentTxt":"And everything an object depends on (services, directives, and elements) is injected into its constructor. To make this work the framework builds a tree of injectors.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000095","sortNo":30,"contentFormatId":"1","contentTxt":"First, every DOM element with a component or a directive on it gets an injector. This injector contains the component instance, all the providers registered by the component, and a few “local” objects (e.g., the element).","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000096","sortNo":31,"contentFormatId":"1","contentTxt":"Second, when bootstrapping an `NgModule`, Angular creates an injector using the module and the providers defined there.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000097","sortNo":32,"contentFormatId":"1","contentTxt":"So the injector tree of the application will look like this:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000098","sortNo":33,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000099","sortNo":34,"contentFormatId":"1","contentTxt":"<strong>Resolution</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000100","sortNo":35,"contentFormatId":"1","contentTxt":"And this is how the dependency resolution algorithm works.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000101","sortNo":36,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000102","sortNo":37,"contentFormatId":"1","contentTxt":"When resolving the backend dependency of TalksCmp, Angular will start with the injector of the talks component itself. Then, if it is unsuccessful, it will climb up to the injector of the app component, and, finally, will move up to the injector created from AppModule. That is why, for TalksAppBackend to be resolved, you need to register it at TalkCmp, AppCmp, or AppModule.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000103","sortNo":38,"contentFormatId":"1","contentTxt":"<strong>Lazy Loading</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000104","sortNo":39,"contentFormatId":"1","contentTxt":"The setup gets more complex once you start using lazy-loading.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000105","sortNo":40,"contentFormatId":"1","contentTxt":"Lazy-loading a module is akin to bootstrapping a module in that it creates a new injector out of the module and plugs it into the injector tree. To see it in action, let’s update our application to load the talks module lazily.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000106","sortNo":41,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000107","sortNo":42,"contentFormatId":"1","contentTxt":"With this change, the injector tree will look as follows:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000108","sortNo":43,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000109","sortNo":44,"contentFormatId":"1","contentTxt":"<strong>Getting Injector</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000110","sortNo":45,"contentFormatId":"1","contentTxt":"You can use ngProbe to poke at an injector associated with an element on the page. You can also see an element’s injector when an exception is thrown.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000111","sortNo":46,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000112","sortNo":47,"contentFormatId":"1","contentTxt":"Right click on any of these objects to store them as a global variable, so you can interact with them in the console.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000113","sortNo":48,"contentFormatId":"1","contentTxt":"<strong>Visualizing Injector Tree</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000114","sortNo":49,"contentFormatId":"1","contentTxt":"If you more of a visual person, use the Angular Augury chrome extension to inspect the component and injector trees.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000115","sortNo":50,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000116","sortNo":51,"contentFormatId":"1","contentTxt":"<strong>Advanced Topics</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000117","sortNo":52,"contentFormatId":"1","contentTxt":"<strong>Controlling Visibility</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000118","sortNo":53,"contentFormatId":"1","contentTxt":"You can be more specific where you want to get dependencies from. For instance, you can ask for another directive on the same element.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000119","sortNo":54,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000120","sortNo":55,"contentFormatId":"1","contentTxt":"Or you can ask for a directive in the same template, i.e., you can only inject an ancestor directive from the same HTML file.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000121","sortNo":56,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000122","sortNo":57,"contentFormatId":"1","contentTxt":"Finally, you can ask to skip the current element, which can be handy for decorating existing providers or building up tree-like structures.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000123","sortNo":58,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000124","sortNo":59,"contentFormatId":"1","contentTxt":"<strong>Optional Dependencies</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000125","sortNo":60,"contentFormatId":"1","contentTxt":"To mark a dependency as optional, use the Optional decorator.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000126","sortNo":61,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000127","sortNo":62,"contentFormatId":"1","contentTxt":"<strong>More on Registering Providers</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000128","sortNo":63,"contentFormatId":"1","contentTxt":"Passing a class into an array of providers is the same as using a provider with useClass, i.e., the two examples below are identical:","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000129","sortNo":64,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000130","sortNo":65,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000131","sortNo":66,"contentFormatId":"1","contentTxt":"When useClass does not suffice, you can configure providers with useValue, useFactory, and useExisting.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000132","sortNo":67,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000133","sortNo":68,"contentFormatId":"1","contentTxt":"As you can see above, we can use the @Inject decorator to configure dependencies when the type parameter does not match the provided token.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000134","sortNo":69,"contentFormatId":"1","contentTxt":"<strong>Aliasing</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000135","sortNo":70,"contentFormatId":"1","contentTxt":"It’s common for components and services to alias themselves.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000136","sortNo":71,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000137","sortNo":72,"contentFormatId":"1","contentTxt":"Now we can use both @Inject(ComponentReexportingItself) and @Inject(‘alias’) to inject this component.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000138","sortNo":73,"contentFormatId":"1","contentTxt":"<strong>Overrides</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000139","sortNo":74,"contentFormatId":"1","contentTxt":"The providers of the imported modules are merged with the target module’s providers, left to right, i.e., if multiple imported modules define the same provider, the last one wins.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000140","sortNo":75,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000141","sortNo":76,"contentFormatId":"1","contentTxt":"The example above will print ‘B’. If we change ModuleC to have its own ‘token’ provider, that one will be used, and the example will print ‘C’.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000142","sortNo":77,"contentFormatId":"2","contentTxt":"","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000143","sortNo":78,"contentFormatId":"1","contentTxt":"<strong>Let’s Recap</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000144","sortNo":79,"contentFormatId":"1","contentTxt":"1. Dependency injection is a key component of Angular.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000145","sortNo":80,"contentFormatId":"1","contentTxt":"2. You can configure dependency injection at the component or module level.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000146","sortNo":81,"contentFormatId":"1","contentTxt":"3. Dependency injection allows us to depend on interfaces rather than concrete types.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000147","sortNo":82,"contentFormatId":"1","contentTxt":"4. This results in more decoupled code.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000148","sortNo":83,"contentFormatId":"1","contentTxt":"5. This improves testability.","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000149","sortNo":84,"contentFormatId":"1","contentTxt":"<strong>source code</strong>","contentBinary":"","contentPoster":"","contentUrl":null},{"id":"201701230000000150","sortNo":85,"contentFormatId":"1","contentTxt":"<a href=\"https://github.com/vsavkin/essential-angular-book-app\">https://github.com/vsavkin/essential-angular-book-app</a>","contentBinary":"","contentPoster":"","contentUrl":null}]